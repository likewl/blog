数据库连接失败panic: Error 1045: Access denied for user 'root'@'localhost' (using password: YES)

goroutine 1 [running]:
main.main()
	/usr/workspace/src/blog/main.go:25 +0x1468
[GIN-debug] [WARNING] Running in "debug" mode. Switch to "release" mode in production.
 - using env:	export GIN_MODE=release
 - using code:	gin.SetMode(gin.ReleaseMode)

[GIN-debug] GET    /static/*filepath         --> github.com/gin-gonic/gin.(*RouterGroup).createStaticHandler.func1 (2 handlers)
[GIN-debug] HEAD   /static/*filepath         --> github.com/gin-gonic/gin.(*RouterGroup).createStaticHandler.func1 (2 handlers)
[GIN-debug] Loaded HTML Templates (30): 
	- tag.html
	- index.html
	- user-edit.html
	- 404.html
	- footer1.html
	- blogs.html
	- login.html
	- tags-edit.html
	- research.html
	- header
	- footer1
	- types-edit.html
	- archives.html
	- type.html
	- header1
	- blogs-input.html
	- admin/index.html
	- about.html
	- header1.html
	- 
	- header.html
	- tags-input.html
	- types.html
	- admin/types.html
	- blog.html
	- pages/index.html
	- blogs-edit.html
	- tags.html
	- admin/tags.html
	- types-input.html

[GIN-debug] GET    /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] POST   /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] PUT    /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] PATCH  /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] HEAD   /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] OPTIONS /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] DELETE /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] CONNECT /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] TRACE  /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] GET    /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] POST   /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] PUT    /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] PATCH  /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] HEAD   /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] OPTIONS /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] DELETE /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] CONNECT /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] TRACE  /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] GET    /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] POST   /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] PUT    /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] PATCH  /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] HEAD   /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] OPTIONS /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] DELETE /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] CONNECT /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] TRACE  /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] GET    /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] POST   /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] PUT    /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] PATCH  /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] HEAD   /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] OPTIONS /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] DELETE /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] CONNECT /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] TRACE  /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] GET    /types                    --> blog/controller/page.TypesHandler (2 handlers)
[GIN-debug] GET    /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] POST   /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] PUT    /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] PATCH  /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] HEAD   /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] OPTIONS /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] DELETE /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] CONNECT /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] TRACE  /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] GET    /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] POST   /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] PUT    /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] PATCH  /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] HEAD   /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] OPTIONS /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] DELETE /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] CONNECT /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] TRACE  /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] GET    /tags                     --> blog/controller/page.TagsHandler (2 handlers)
[GIN-debug] GET    /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] POST   /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] PUT    /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] PATCH  /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] HEAD   /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] OPTIONS /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] DELETE /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] CONNECT /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] TRACE  /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] GET    /archives                 --> blog/controller/page.ArchivesHandler (2 handlers)
[GIN-debug] GET    /about                    --> blog/controller/page.AboutHandler (2 handlers)
[GIN-debug] GET    /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] POST   /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] PUT    /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] PATCH  /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] HEAD   /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] OPTIONS /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] DELETE /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] CONNECT /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] TRACE  /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] GET    /admin/logout             --> blog/controller/admin.LogoutHandler (2 handlers)
[GIN-debug] GET    /admin/                   --> blog/controller/admin.AdminHandler (3 handlers)
[GIN-debug] GET    /admin/index              --> blog/controller/admin.AdminIndexHandler (3 handlers)
[GIN-debug] GET    /admin/type/              --> blog/controller/admin.TypeHandler (3 handlers)
[GIN-debug] GET    /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] POST   /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] PUT    /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] PATCH  /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] HEAD   /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] OPTIONS /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] DELETE /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] CONNECT /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] TRACE  /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] GET    /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] POST   /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] PUT    /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] PATCH  /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] HEAD   /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] OPTIONS /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] DELETE /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] CONNECT /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] TRACE  /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] GET    /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] POST   /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] PUT    /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] PATCH  /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] HEAD   /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] OPTIONS /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] DELETE /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] CONNECT /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] TRACE  /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] GET    /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] POST   /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] PUT    /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] PATCH  /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] HEAD   /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] OPTIONS /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] DELETE /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] CONNECT /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] TRACE  /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] GET    /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] POST   /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] PUT    /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] PATCH  /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] HEAD   /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] OPTIONS /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] DELETE /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] CONNECT /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] TRACE  /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] GET    /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] POST   /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] PUT    /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] PATCH  /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] HEAD   /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] OPTIONS /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] DELETE /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] CONNECT /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] TRACE  /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] GET    /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] POST   /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] PUT    /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] PATCH  /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] HEAD   /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] OPTIONS /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] DELETE /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] CONNECT /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] TRACE  /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] GET    /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] POST   /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] PUT    /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] PATCH  /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] HEAD   /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] OPTIONS /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] DELETE /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] CONNECT /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] TRACE  /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] GET    /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] POST   /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] PUT    /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] PATCH  /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] HEAD   /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] OPTIONS /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] DELETE /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] CONNECT /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] TRACE  /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] Listening and serving HTTP on :8080
[GIN-debug] [ERROR] listen tcp :8080: bind: address already in use
[GIN-debug] [WARNING] Running in "debug" mode. Switch to "release" mode in production.
 - using env:	export GIN_MODE=release
 - using code:	gin.SetMode(gin.ReleaseMode)

[GIN-debug] GET    /static/*filepath         --> github.com/gin-gonic/gin.(*RouterGroup).createStaticHandler.func1 (2 handlers)
[GIN-debug] HEAD   /static/*filepath         --> github.com/gin-gonic/gin.(*RouterGroup).createStaticHandler.func1 (2 handlers)
[GIN-debug] Loaded HTML Templates (30): 
	- tags-input.html
	- types.html
	- archives.html
	- pages/index.html
	- 
	- blogs-input.html
	- tags-edit.html
	- login.html
	- blog.html
	- footer1
	- types-input.html
	- header1
	- index.html
	- tags.html
	- types-edit.html
	- footer1.html
	- header1.html
	- research.html
	- admin/tags.html
	- 404.html
	- about.html
	- admin/types.html
	- user-edit.html
	- tag.html
	- blogs-edit.html
	- blogs.html
	- header.html
	- header
	- type.html
	- admin/index.html

[GIN-debug] GET    /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] POST   /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] PUT    /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] PATCH  /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] HEAD   /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] OPTIONS /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] DELETE /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] CONNECT /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] TRACE  /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] GET    /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] POST   /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] PUT    /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] PATCH  /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] HEAD   /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] OPTIONS /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] DELETE /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] CONNECT /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] TRACE  /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] GET    /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] POST   /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] PUT    /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] PATCH  /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] HEAD   /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] OPTIONS /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] DELETE /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] CONNECT /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] TRACE  /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] GET    /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] POST   /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] PUT    /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] PATCH  /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] HEAD   /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] OPTIONS /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] DELETE /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] CONNECT /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] TRACE  /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] GET    /types                    --> blog/controller/page.TypesHandler (2 handlers)
[GIN-debug] GET    /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] POST   /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] PUT    /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] PATCH  /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] HEAD   /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] OPTIONS /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] DELETE /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] CONNECT /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] TRACE  /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] GET    /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] POST   /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] PUT    /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] PATCH  /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] HEAD   /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] OPTIONS /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] DELETE /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] CONNECT /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] TRACE  /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] GET    /tags                     --> blog/controller/page.TagsHandler (2 handlers)
[GIN-debug] GET    /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] POST   /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] PUT    /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] PATCH  /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] HEAD   /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] OPTIONS /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] DELETE /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] CONNECT /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] TRACE  /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] GET    /archives                 --> blog/controller/page.ArchivesHandler (2 handlers)
[GIN-debug] GET    /about                    --> blog/controller/page.AboutHandler (2 handlers)
[GIN-debug] GET    /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] POST   /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] PUT    /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] PATCH  /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] HEAD   /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] OPTIONS /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] DELETE /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] CONNECT /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] TRACE  /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] GET    /admin/logout             --> blog/controller/admin.LogoutHandler (2 handlers)
[GIN-debug] GET    /admin/                   --> blog/controller/admin.AdminHandler (3 handlers)
[GIN-debug] GET    /admin/index              --> blog/controller/admin.AdminIndexHandler (3 handlers)
[GIN-debug] GET    /admin/type/              --> blog/controller/admin.TypeHandler (3 handlers)
[GIN-debug] GET    /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] POST   /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] PUT    /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] PATCH  /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] HEAD   /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] OPTIONS /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] DELETE /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] CONNECT /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] TRACE  /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] GET    /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] POST   /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] PUT    /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] PATCH  /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] HEAD   /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] OPTIONS /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] DELETE /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] CONNECT /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] TRACE  /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] GET    /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] POST   /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] PUT    /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] PATCH  /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] HEAD   /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] OPTIONS /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] DELETE /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] CONNECT /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] TRACE  /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] GET    /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] POST   /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] PUT    /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] PATCH  /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] HEAD   /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] OPTIONS /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] DELETE /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] CONNECT /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] TRACE  /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] GET    /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] POST   /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] PUT    /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] PATCH  /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] HEAD   /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] OPTIONS /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] DELETE /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] CONNECT /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] TRACE  /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] GET    /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] POST   /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] PUT    /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] PATCH  /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] HEAD   /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] OPTIONS /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] DELETE /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] CONNECT /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] TRACE  /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] GET    /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] POST   /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] PUT    /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] PATCH  /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] HEAD   /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] OPTIONS /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] DELETE /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] CONNECT /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] TRACE  /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] GET    /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] POST   /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] PUT    /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] PATCH  /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] HEAD   /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] OPTIONS /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] DELETE /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] CONNECT /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] TRACE  /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] GET    /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] POST   /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] PUT    /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] PATCH  /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] HEAD   /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] OPTIONS /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] DELETE /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] CONNECT /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] TRACE  /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] Listening and serving HTTP on :8080

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:09:44][0m  [36;1m[0.57ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 13:09:44][0m  [36;1m[0.72ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 13:09:44][0m  [36;1m[0.22ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
3

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 13:09:44][0m  [36;1m[0.31ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 13:09:44][0m  [36;1m[0.25ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 13:09:44][0m  [36;1m[0.32ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 13:09:46][0m  [36;1m[0.53ms][0m  SELECT * FROM `types`    
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:09:46][0m  [36;1m[0.27ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 13:09:46][0m  [36;1m[0.66ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-20 13:09:46][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-20 13:09:47][0m  [36;1m[0.54ms][0m  SELECT * FROM `tags`    
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:09:47][0m  [36;1m[0.26ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 13:09:47][0m  [36;1m[0.67ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:31)[0m 
[33m[2020-07-20 13:09:47][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `tags`    
[36;31m[0 rows affected or returned ][0m 
[GIN-debug] redirecting request 301: /admin/ --> /admin/
中间件开始校验
<nil> 获取user
<nil> 校验错误

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:09:51][0m  [36;1m[0.60ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:09:53][0m  [36;1m[0.58ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
<nil> err
admin 登录了
[GIN-debug] redirecting request 301: /admin/ --> /admin/
中间件开始校验
admin 获取user
admin 校验正确
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:09:53][0m  [36;1m[0.57ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
[GIN-debug] redirecting request 301: /admin/blog/ --> /admin/blog/
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:09:54][0m  [36;1m[0.52ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:38)[0m 
[33m[2020-07-20 13:09:54][0m  [36;1m[0.47ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.recommend,blogs.update_time FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY `blogs`.`id` LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 
&[{1 golang项目简单服务器部署到阿里云(linux) 0 go 是 2020-07-19 18:32:31} {2 mysql5.7 查询数据，group by 报错：Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 't.id' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by？ 0 mysql 是 2020-07-19 18:59:30} {3 解决Linux关闭终端后运行的程序自动停止 0 linux 是 2020-07-19 19:05:36}]
3 ceshi

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 13:09:54][0m  [36;1m[0.21ms][0m  SELECT * FROM `types`    
[36;31m[3 rows affected or returned ][0m 
0
[GIN-debug] redirecting request 301: /admin/user/ --> /admin/user/
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:10:01][0m  [36;1m[0.58ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
[GIN-debug] redirecting request 301: /admin/tag/ --> /admin/tag/
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:11:27][0m  [36;1m[0.56ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
[GIN-debug] redirecting request 301: /admin/type/ --> /admin/type/
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:11:28][0m  [36;1m[0.53ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 13:11:28][0m  [36;1m[0.28ms][0m  SELECT * FROM `types`    
[36;31m[3 rows affected or returned ][0m 
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:11:29][0m  [36;1m[0.68ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:38)[0m 
[33m[2020-07-20 13:11:29][0m  [36;1m[0.69ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.recommend,blogs.update_time FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY `blogs`.`id` LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 
&[{1 golang项目简单服务器部署到阿里云(linux) 0 go 是 2020-07-19 18:32:31} {2 mysql5.7 查询数据，group by 报错：Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 't.id' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by？ 0 mysql 是 2020-07-19 18:59:30} {3 解决Linux关闭终端后运行的程序自动停止 0 linux 是 2020-07-19 19:05:36}]
3 ceshi

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 13:11:29][0m  [36;1m[0.31ms][0m  SELECT * FROM `types`    
[36;31m[3 rows affected or returned ][0m 
0
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:11:32][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 13:11:32][0m  [36;1m[0.27ms][0m  SELECT * FROM `types`    
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-20 13:11:32][0m  [36;1m[0.22ms][0m  SELECT * FROM `tags`    
[36;31m[3 rows affected or returned ][0m 
{0    0         [] 0 {0  []} 0 0 0} ceshi
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:11:39][0m  [36;1m[0.64ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 13:11:39][0m  [36;1m[0.57ms][0m  SELECT * FROM `types`    
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-20 13:11:39][0m  [36;1m[0.22ms][0m  SELECT * FROM `tags`    
[36;31m[3 rows affected or returned ][0m 
{0 golang项目简单服务器部署到阿里云(linux) # 我个人比较推荐使用Xftp和Xshell 
# 重要是个人免费用
# 舒服又好用

# 1.下载安装go安装包：
	## （1）go语言下载地址：
	[Go语言中文网](https://studygolang.com/dl "Go语言中文网")
下载linux版本的安装包。

## （2）使用Xftp将安装包上传至指定的路径：

![](https://img-blog.csdnimg.cn/20190719142701389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
	这里上传到root目录下就行
	方便解压
## （3）解压并移到/usr/local/下：

进入指定目录，查看已有文件并且解压文件：

![](https://img-blog.csdnimg.cn/20190719143211340.png)
```
#在root目录输入ls查看目录文件
ls
#在root解压go包
tar -zxvf go的包名
```

解压完成后发现目录下多了一个go文件夹：
![](https://img-blog.csdnimg.cn/20190719143042938.png)
将文件夹移动到/usr/local/
![](https://img-blog.csdnimg.cn/20190719143137645.png)
# 2.配置环境变量：
## （1）进入目的目录查看go文件夹是否移动成功：
![](https://img-blog.csdnimg.cn/20190719143506382.png)
## （2）在usr下创建文件夹，用来存放自己的项目：
workspace
## （3）进入新建的目录workspace新建三个文件夹：
src
pkg
bin
### 说明：

	src 目录存放的是我们的go源代码，不同工程项目的代码以包名区分
	pkg 编译后生成的文件
	bin文件夹存放go install命名生成的可执行文件（这个文件夹会配置到环境变量中）
## （4）配置环境变量：

进入 /etc 修改profile文件：
![](https://img-blog.csdnimg.cn/20190719144319621.png)
```
#进入etc目录
cd /etc/
#配置 profile
vim profile
```
![](https://img-blog.csdnimg.cn/20190719145650864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
在此文件夹下加入上图的代码，代码如下：
```
// 设置go安装路径
export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin
 
// 设置工程目录
export GOPATH=/usr/workspace
export PATH=$PATH:$GOPATH/bin
```

## （5）刷新环境变量：
```
source /etc/profile
```
##  （6）查看go环境是否配置成功：
```
go version
```
## （7）查看详细配置：
```
go env
```
结果如下：  
![](https://img-blog.csdnimg.cn/20190719145255720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70) 
# 3.上传项目代码：
在刚刚创建的workspace下新创建的三个文件夹中，src 目录存放的是我们的go源代码
# 4运行
```go
go build main.go
//或者
go run main.go
```
最后执行 ./main 就行了。
如果想让项目在后台执行：执行 nohup ./main & ，这样就可以程序在后台运行了。

参考教程https://blog.csdn.net/qq_42410605/article/details/96479892 https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3111860246,1925938903&fm=26&gp=0.jpg 7 原创 是 是 是 是 简单又详细的教程   [] 1 {0  []} 0 0 0} ceshi

[35m(/usr/workspace/src/blog/dao/tags.go:46)[0m 
[33m[2020-07-20 13:11:39][0m  [36;1m[0.63ms][0m  DELETE FROM `tag_blogs`  WHERE (blog_id=1)  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-20 13:11:39][0m  [36;1m[0.50ms][0m  UPDATE `blogs` SET `title` = 'golang项目简单服务器部署到阿里云(linux)', `content` = '# 我个人比较推荐使用Xftp和Xshell 
# 重要是个人免费用
# 舒服又好用

# 1.下载安装go安装包：
	## （1）go语言下载地址：
	[Go语言中文网](https://studygolang.com/dl "Go语言中文网")
下载linux版本的安装包。

## （2）使用Xftp将安装包上传至指定的路径：

![](https://img-blog.csdnimg.cn/20190719142701389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
	这里上传到root目录下就行
	方便解压
## （3）解压并移到/usr/local/下：

进入指定目录，查看已有文件并且解压文件：

![](https://img-blog.csdnimg.cn/20190719143211340.png)
```
#在root目录输入ls查看目录文件
ls
#在root解压go包
tar -zxvf go的包名
```

解压完成后发现目录下多了一个go文件夹：
![](https://img-blog.csdnimg.cn/20190719143042938.png)
将文件夹移动到/usr/local/
![](https://img-blog.csdnimg.cn/20190719143137645.png)
# 2.配置环境变量：
## （1）进入目的目录查看go文件夹是否移动成功：
![](https://img-blog.csdnimg.cn/20190719143506382.png)
## （2）在usr下创建文件夹，用来存放自己的项目：
workspace
## （3）进入新建的目录workspace新建三个文件夹：
src
pkg
bin
### 说明：

	src 目录存放的是我们的go源代码，不同工程项目的代码以包名区分
	pkg 编译后生成的文件
	bin文件夹存放go install命名生成的可执行文件（这个文件夹会配置到环境变量中）
## （4）配置环境变量：

进入 /etc 修改profile文件：
![](https://img-blog.csdnimg.cn/20190719144319621.png)
```
#进入etc目录
cd /etc/
#配置 profile
vim profile
```
![](https://img-blog.csdnimg.cn/20190719145650864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
在此文件夹下加入上图的代码，代码如下：
```
// 设置go安装路径
export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin
 
// 设置工程目录
export GOPATH=/usr/workspace
export PATH=$PATH:$GOPATH/bin
```

## （5）刷新环境变量：
```
source /etc/profile
```
##  （6）查看go环境是否配置成功：
```
go version
```
## （7）查看详细配置：
```
go env
```
结果如下：  
![](https://img-blog.csdnimg.cn/20190719145255720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70) 
# 3.上传项目代码：
在刚刚创建的workspace下新创建的三个文件夹中，src 目录存放的是我们的go源代码
# 4运行
```go
go build main.go
//或者
go run main.go
```
最后执行 ./main 就行了。
如果想让项目在后台执行：执行 nohup ./main & ，这样就可以程序在后台运行了。

参考教程https://blog.csdn.net/qq_42410605/article/details/96479892', `image` = 'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3111860246,1925938903&fm=26&gp=0.jpg', `numb` = 7, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '简单又详细的教程', `creat_time` = '2020-07-19 18:32:31', `update_time` = '2020-07-20 13:11:39', `type_id` = 1, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 1  
[36;31m[1 rows affected or returned ][0m 
[GIN-debug] redirecting request 301: /admin/blog/ --> /admin/blog/?msg=2&page=1
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:11:39][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:38)[0m 
[33m[2020-07-20 13:11:39][0m  [36;1m[0.48ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.recommend,blogs.update_time FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY `blogs`.`id` LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 
&[{1 golang项目简单服务器部署到阿里云(linux) 0 go 是 2020-07-20 13:11:39} {2 mysql5.7 查询数据，group by 报错：Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 't.id' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by？ 0 mysql 是 2020-07-19 18:59:30} {3 解决Linux关闭终端后运行的程序自动停止 0 linux 是 2020-07-19 19:05:36}]
3 ceshi

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 13:11:39][0m  [36;1m[0.22ms][0m  SELECT * FROM `types`    
[36;31m[3 rows affected or returned ][0m 
0
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:11:42][0m  [36;1m[0.52ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 13:11:42][0m  [36;1m[0.21ms][0m  SELECT * FROM `types`    
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-20 13:11:42][0m  [36;1m[0.20ms][0m  SELECT * FROM `tags`    
[36;31m[3 rows affected or returned ][0m 
{0    0         [] 0 {0  []} 0 0 0} ceshi
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:11:56][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 13:11:56][0m  [36;1m[0.51ms][0m  SELECT * FROM `types`    
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-20 13:11:56][0m  [36;1m[0.23ms][0m  SELECT * FROM `tags`    
[36;31m[3 rows affected or returned ][0m 
{0 golang项目简单服务器部署到阿里云(linux) # 我个人比较推荐使用Xftp和Xshell 
# 重要是个人免费用
# 舒服又好用

# 1.下载安装go安装包：
	## （1）go语言下载地址：
	[Go语言中文网](https://studygolang.com/dl "Go语言中文网")
下载linux版本的安装包。

## （2）使用Xftp将安装包上传至指定的路径：

![](https://img-blog.csdnimg.cn/20190719142701389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
	这里上传到root目录下就行
	方便解压
## （3）解压并移到/usr/local/下：

进入指定目录，查看已有文件并且解压文件：

![](https://img-blog.csdnimg.cn/20190719143211340.png)
```
#在root目录输入ls查看目录文件
ls
#在root解压go包
tar -zxvf go的包名
```

解压完成后发现目录下多了一个go文件夹：
![](https://img-blog.csdnimg.cn/20190719143042938.png)
将文件夹移动到/usr/local/
![](https://img-blog.csdnimg.cn/20190719143137645.png)
# 2.配置环境变量：
## （1）进入目的目录查看go文件夹是否移动成功：
![](https://img-blog.csdnimg.cn/20190719143506382.png)
## （2）在usr下创建文件夹，用来存放自己的项目：
workspace
## （3）进入新建的目录workspace新建三个文件夹：
src
pkg
bin
### 说明：

	src 目录存放的是我们的go源代码，不同工程项目的代码以包名区分
	pkg 编译后生成的文件
	bin文件夹存放go install命名生成的可执行文件（这个文件夹会配置到环境变量中）
## （4）配置环境变量：

进入 /etc 修改profile文件：
![](https://img-blog.csdnimg.cn/20190719144319621.png)
```
#进入etc目录
cd /etc/
#配置 profile
vim profile
```
![](https://img-blog.csdnimg.cn/20190719145650864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
在此文件夹下加入上图的代码，代码如下：
```
// 设置go安装路径
export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin
 
// 设置工程目录
export GOPATH=/usr/workspace
export PATH=$PATH:$GOPATH/bin
```

## （5）刷新环境变量：
```
source /etc/profile
```
##  （6）查看go环境是否配置成功：
```
go version
```
## （7）查看详细配置：
```
go env
```
结果如下：  
![](https://img-blog.csdnimg.cn/20190719145255720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70) 
# 3.上传项目代码：
在刚刚创建的workspace下新创建的三个文件夹中，src 目录存放的是我们的go源代码
# 4运行
```go
go build main.go
//或者
go run main.go
```
最后执行 ./main 就行了。
如果想让项目在后台执行：执行 nohup ./main & ，这样就可以程序在后台运行了。

参考教程https://blog.csdn.net/qq_42410605/article/details/96479892 https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3111860246,1925938903&fm=26&gp=0.jpg 7 原创 是 是 是 是 简单又详细的教程   [] 1 {0  []} 0 0 0} ceshi

[35m(/usr/workspace/src/blog/dao/tags.go:46)[0m 
[33m[2020-07-20 13:11:56][0m  [36;1m[0.37ms][0m  DELETE FROM `tag_blogs`  WHERE (blog_id=1)  
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-20 13:11:56][0m  [36;1m[0.43ms][0m  UPDATE `blogs` SET `title` = 'golang项目简单服务器部署到阿里云(linux)', `content` = '# 我个人比较推荐使用Xftp和Xshell 
# 重要是个人免费用
# 舒服又好用

# 1.下载安装go安装包：
	## （1）go语言下载地址：
	[Go语言中文网](https://studygolang.com/dl "Go语言中文网")
下载linux版本的安装包。

## （2）使用Xftp将安装包上传至指定的路径：

![](https://img-blog.csdnimg.cn/20190719142701389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
	这里上传到root目录下就行
	方便解压
## （3）解压并移到/usr/local/下：

进入指定目录，查看已有文件并且解压文件：

![](https://img-blog.csdnimg.cn/20190719143211340.png)
```
#在root目录输入ls查看目录文件
ls
#在root解压go包
tar -zxvf go的包名
```

解压完成后发现目录下多了一个go文件夹：
![](https://img-blog.csdnimg.cn/20190719143042938.png)
将文件夹移动到/usr/local/
![](https://img-blog.csdnimg.cn/20190719143137645.png)
# 2.配置环境变量：
## （1）进入目的目录查看go文件夹是否移动成功：
![](https://img-blog.csdnimg.cn/20190719143506382.png)
## （2）在usr下创建文件夹，用来存放自己的项目：
workspace
## （3）进入新建的目录workspace新建三个文件夹：
src
pkg
bin
### 说明：

	src 目录存放的是我们的go源代码，不同工程项目的代码以包名区分
	pkg 编译后生成的文件
	bin文件夹存放go install命名生成的可执行文件（这个文件夹会配置到环境变量中）
## （4）配置环境变量：

进入 /etc 修改profile文件：
![](https://img-blog.csdnimg.cn/20190719144319621.png)
```
#进入etc目录
cd /etc/
#配置 profile
vim profile
```
![](https://img-blog.csdnimg.cn/20190719145650864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
在此文件夹下加入上图的代码，代码如下：
```
// 设置go安装路径
export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin
 
// 设置工程目录
export GOPATH=/usr/workspace
export PATH=$PATH:$GOPATH/bin
```

## （5）刷新环境变量：
```
source /etc/profile
```
##  （6）查看go环境是否配置成功：
```
go version
```
## （7）查看详细配置：
```
go env
```
结果如下：  
![](https://img-blog.csdnimg.cn/20190719145255720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70) 
# 3.上传项目代码：
在刚刚创建的workspace下新创建的三个文件夹中，src 目录存放的是我们的go源代码
# 4运行
```go
go build main.go
//或者
go run main.go
```
最后执行 ./main 就行了。
如果想让项目在后台执行：执行 nohup ./main & ，这样就可以程序在后台运行了。

参考教程https://blog.csdn.net/qq_42410605/article/details/96479892', `image` = 'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3111860246,1925938903&fm=26&gp=0.jpg', `numb` = 7, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '简单又详细的教程', `creat_time` = '2020-07-19 18:32:31', `update_time` = '2020-07-20 13:11:56', `type_id` = 1, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:47)[0m 
[33m[2020-07-20 13:11:56][0m  [36;1m[0.31ms][0m  INSERT INTO `tag_blogs` (`tag_id`,`blog_id`) VALUES (1,1)  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:47)[0m 
[33m[2020-07-20 13:11:56][0m  [36;1m[0.57ms][0m  INSERT INTO `tag_blogs` (`tag_id`,`blog_id`) VALUES (2,1)  
[36;31m[1 rows affected or returned ][0m 
[GIN-debug] redirecting request 301: /admin/blog/ --> /admin/blog/?msg=2&page=1
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:11:56][0m  [36;1m[0.56ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:38)[0m 
[33m[2020-07-20 13:11:56][0m  [36;1m[0.49ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.recommend,blogs.update_time FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY `blogs`.`id` LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 
&[{1 golang项目简单服务器部署到阿里云(linux) 0 go 是 2020-07-20 13:11:56} {2 mysql5.7 查询数据，group by 报错：Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 't.id' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by？ 0 mysql 是 2020-07-19 18:59:30} {3 解决Linux关闭终端后运行的程序自动停止 0 linux 是 2020-07-19 19:05:36}]
3 ceshi

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 13:11:56][0m  [36;1m[0.24ms][0m  SELECT * FROM `types`    
[36;31m[3 rows affected or returned ][0m 
0

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:12:14][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 13:12:14][0m  [36;1m[0.75ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 13:12:14][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
3

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 13:12:14][0m  [36;1m[0.31ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 13:12:14][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 13:12:14][0m  [36;1m[0.33ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-20 13:12:17][0m  [36;1m[0.45ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 1)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-20 13:12:17][0m  [36;1m[0.50ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=1  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-20 13:12:17][0m  [36;1m[0.41ms][0m  UPDATE `blogs` SET `title` = 'golang项目简单服务器部署到阿里云(linux)', `content` = '# 我个人比较推荐使用Xftp和Xshell 
# 重要是个人免费用
# 舒服又好用

# 1.下载安装go安装包：
	## （1）go语言下载地址：
	[Go语言中文网](https://studygolang.com/dl "Go语言中文网")
下载linux版本的安装包。

## （2）使用Xftp将安装包上传至指定的路径：

![](https://img-blog.csdnimg.cn/20190719142701389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
	这里上传到root目录下就行
	方便解压
## （3）解压并移到/usr/local/下：

进入指定目录，查看已有文件并且解压文件：

![](https://img-blog.csdnimg.cn/20190719143211340.png)
```
#在root目录输入ls查看目录文件
ls
#在root解压go包
tar -zxvf go的包名
```

解压完成后发现目录下多了一个go文件夹：
![](https://img-blog.csdnimg.cn/20190719143042938.png)
将文件夹移动到/usr/local/
![](https://img-blog.csdnimg.cn/20190719143137645.png)
# 2.配置环境变量：
## （1）进入目的目录查看go文件夹是否移动成功：
![](https://img-blog.csdnimg.cn/20190719143506382.png)
## （2）在usr下创建文件夹，用来存放自己的项目：
workspace
## （3）进入新建的目录workspace新建三个文件夹：
src
pkg
bin
### 说明：

	src 目录存放的是我们的go源代码，不同工程项目的代码以包名区分
	pkg 编译后生成的文件
	bin文件夹存放go install命名生成的可执行文件（这个文件夹会配置到环境变量中）
## （4）配置环境变量：

进入 /etc 修改profile文件：
![](https://img-blog.csdnimg.cn/20190719144319621.png)
```
#进入etc目录
cd /etc/
#配置 profile
vim profile
```
![](https://img-blog.csdnimg.cn/20190719145650864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
在此文件夹下加入上图的代码，代码如下：
```
// 设置go安装路径
export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin
 
// 设置工程目录
export GOPATH=/usr/workspace
export PATH=$PATH:$GOPATH/bin
```

## （5）刷新环境变量：
```
source /etc/profile
```
##  （6）查看go环境是否配置成功：
```
go version
```
## （7）查看详细配置：
```
go env
```
结果如下：  
![](https://img-blog.csdnimg.cn/20190719145255720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70) 
# 3.上传项目代码：
在刚刚创建的workspace下新创建的三个文件夹中，src 目录存放的是我们的go源代码
# 4运行
```go
go build main.go
//或者
go run main.go
```
最后执行 ./main 就行了。
如果想让项目在后台执行：执行 nohup ./main & ，这样就可以程序在后台运行了。

参考教程https://blog.csdn.net/qq_42410605/article/details/96479892', `image` = 'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3111860246,1925938903&fm=26&gp=0.jpg', `numb` = 8, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '简单又详细的教程', `creat_time` = '2020-07-19 18:32:31', `update_time` = '2020-07-20 13:11:56', `type_id` = 1, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:12:17][0m  [36;1m[1.86ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:14:58][0m  [36;1m[0.52ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 13:14:58][0m  [36;1m[0.68ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 13:14:58][0m  [36;1m[0.23ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
3

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 13:14:58][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 13:14:58][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 13:14:58][0m  [36;1m[0.33ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-20 13:15:10][0m  [36;1m[0.35ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 3)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-20 13:15:10][0m  [36;1m[0.44ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=3  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-20 13:15:10][0m  [36;1m[0.39ms][0m  UPDATE `blogs` SET `title` = 'mysql5.7 查询数据，group by 报错：Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 't.id' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by？', `content` = '在做归档功能时用到了分组查询
结果出现了这样的错误
```
Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 't.id' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by

```
查询才知道
mysql 5.7 加入的新特性，only_full_group_by，它只允许你的查询字段是包括在 group by 里面的字段，这种模式导致无法我们无法得到想要的字段值，我们可以禁用掉 only_full_group_by：
### 第一步：
```
select @@GLOBAL.sql_mode;
```
得到现有的 sql_mode, 如下：
```
ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION

```
### 第二步：
```
set global sql_mode ='STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION';

set session sql_mode= 'STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION';
```
去除 ONLY_FULL_GROUP_BY，重新设置，就 ok 了。', `image` = 'https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2507389442,2201469096&fm=26&gp=0.jpg', `numb` = 15, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '', `recommend` = '是', `description` = '在做归档功能时用到了分组查询，结果出现了这样的错误，原来是mysql57的新功能
', `creat_time` = '2020-07-19 18:58:22', `update_time` = '2020-07-19 18:59:30', `type_id` = 3, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 2  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:15:10][0m  [36;1m[0.46ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-20 13:15:12][0m  [36;1m[0.40ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 3)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-20 13:15:12][0m  [36;1m[0.47ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=3  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-20 13:15:12][0m  [36;1m[0.51ms][0m  UPDATE `blogs` SET `title` = 'mysql5.7 查询数据，group by 报错：Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 't.id' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by？', `content` = '在做归档功能时用到了分组查询
结果出现了这样的错误
```
Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 't.id' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by

```
查询才知道
mysql 5.7 加入的新特性，only_full_group_by，它只允许你的查询字段是包括在 group by 里面的字段，这种模式导致无法我们无法得到想要的字段值，我们可以禁用掉 only_full_group_by：
### 第一步：
```
select @@GLOBAL.sql_mode;
```
得到现有的 sql_mode, 如下：
```
ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION

```
### 第二步：
```
set global sql_mode ='STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION';

set session sql_mode= 'STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION';
```
去除 ONLY_FULL_GROUP_BY，重新设置，就 ok 了。', `image` = 'https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2507389442,2201469096&fm=26&gp=0.jpg', `numb` = 16, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '', `recommend` = '是', `description` = '在做归档功能时用到了分组查询，结果出现了这样的错误，原来是mysql57的新功能
', `creat_time` = '2020-07-19 18:58:22', `update_time` = '2020-07-19 18:59:30', `type_id` = 3, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 2  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:15:12][0m  [36;1m[1.74ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:15:32][0m  [36;1m[0.52ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:51)[0m 
[33m[2020-07-20 13:15:32][0m  [36;1m[0.41ms][0m  SELECT * FROM `comments`  WHERE ( comment_name = 'like' AND comment_email = '535889315@qq.com') ORDER BY `comments`.`id` ASC LIMIT 1  
[36;31m[0 rows affected or returned ][0m 
进入了1

[35m(/usr/workspace/src/blog/dao/comment.go:11)[0m 
[33m[2020-07-20 13:15:32][0m  [36;1m[0.38ms][0m  INSERT INTO `comments` (`blog_id`,`re_comment_id`,`comment_name`,`re_comment_name`,`comment_email`,`img`,`comment_content`,`comment_time`) VALUES (1,-1,'like','','535889315@qq.com','/static/images/header.jpg','测试评论功能','2020-07-20 13:15:32')  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-20 13:15:32][0m  [36;1m[0.43ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 1)  
[36;31m[1 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-20 13:15:32][0m  [36;1m[0.51ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=1  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-20 13:15:32][0m  [36;1m[0.45ms][0m  UPDATE `blogs` SET `title` = 'golang项目简单服务器部署到阿里云(linux)', `content` = '# 我个人比较推荐使用Xftp和Xshell 
# 重要是个人免费用
# 舒服又好用

# 1.下载安装go安装包：
	## （1）go语言下载地址：
	[Go语言中文网](https://studygolang.com/dl "Go语言中文网")
下载linux版本的安装包。

## （2）使用Xftp将安装包上传至指定的路径：

![](https://img-blog.csdnimg.cn/20190719142701389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
	这里上传到root目录下就行
	方便解压
## （3）解压并移到/usr/local/下：

进入指定目录，查看已有文件并且解压文件：

![](https://img-blog.csdnimg.cn/20190719143211340.png)
```
#在root目录输入ls查看目录文件
ls
#在root解压go包
tar -zxvf go的包名
```

解压完成后发现目录下多了一个go文件夹：
![](https://img-blog.csdnimg.cn/20190719143042938.png)
将文件夹移动到/usr/local/
![](https://img-blog.csdnimg.cn/20190719143137645.png)
# 2.配置环境变量：
## （1）进入目的目录查看go文件夹是否移动成功：
![](https://img-blog.csdnimg.cn/20190719143506382.png)
## （2）在usr下创建文件夹，用来存放自己的项目：
workspace
## （3）进入新建的目录workspace新建三个文件夹：
src
pkg
bin
### 说明：

	src 目录存放的是我们的go源代码，不同工程项目的代码以包名区分
	pkg 编译后生成的文件
	bin文件夹存放go install命名生成的可执行文件（这个文件夹会配置到环境变量中）
## （4）配置环境变量：

进入 /etc 修改profile文件：
![](https://img-blog.csdnimg.cn/20190719144319621.png)
```
#进入etc目录
cd /etc/
#配置 profile
vim profile
```
![](https://img-blog.csdnimg.cn/20190719145650864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
在此文件夹下加入上图的代码，代码如下：
```
// 设置go安装路径
export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin
 
// 设置工程目录
export GOPATH=/usr/workspace
export PATH=$PATH:$GOPATH/bin
```

## （5）刷新环境变量：
```
source /etc/profile
```
##  （6）查看go环境是否配置成功：
```
go version
```
## （7）查看详细配置：
```
go env
```
结果如下：  
![](https://img-blog.csdnimg.cn/20190719145255720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70) 
# 3.上传项目代码：
在刚刚创建的workspace下新创建的三个文件夹中，src 目录存放的是我们的go源代码
# 4运行
```go
go build main.go
//或者
go run main.go
```
最后执行 ./main 就行了。
如果想让项目在后台执行：执行 nohup ./main & ，这样就可以程序在后台运行了。

参考教程https://blog.csdn.net/qq_42410605/article/details/96479892', `image` = 'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3111860246,1925938903&fm=26&gp=0.jpg', `numb` = 9, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '简单又详细的教程', `creat_time` = '2020-07-19 18:32:31', `update_time` = '2020-07-20 13:11:56', `type_id` = 1, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:15:32][0m  [36;1m[0.27ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:15:32][0m  [36;1m[0.36ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 1)  
[36;31m[0 rows affected or returned ][0m 
[]

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-20 13:15:41][0m  [36;1m[0.38ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 2)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-20 13:15:41][0m  [36;1m[0.45ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=2  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-20 13:15:41][0m  [36;1m[0.42ms][0m  UPDATE `blogs` SET `title` = '解决Linux关闭终端后运行的程序自动停止', `content` = '# 问题发现
  昨天博客发布，操作完关闭终端就睡了
  然而今天醒来突然发现终端不能访问了
  查看发现原来博客项目进程被杀死了
# 解决办法
    go build main.go
执行完后

    nohup ./main &
让程序在后台运行就可了


[========]
# ps:这个方法并不完美，因为我也是刚刚接触还不知道怎么切回来', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3696516981,3671280793&fm=26&gp=0.jpg', `numb` = 7, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '', `recommend` = '是', `description` = '昨天博客发布，操作完关闭终端就睡了，然而今天醒来突然发现终端不能访问了，查看发现原来博客项目进程被杀死了', `creat_time` = '2020-07-19 19:05:36', `update_time` = '2020-07-19 19:05:36', `type_id` = 2, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 3  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:15:41][0m  [36;1m[0.28ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:15:56][0m  [36;1m[0.58ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:51)[0m 
[33m[2020-07-20 13:15:56][0m  [36;1m[0.46ms][0m  SELECT * FROM `comments`  WHERE ( comment_name = '测试员1' AND comment_email = 'admin@qq.com') ORDER BY `comments`.`id` ASC LIMIT 1  
[36;31m[0 rows affected or returned ][0m 
进入了3

[35m(/usr/workspace/src/blog/dao/comment.go:11)[0m 
[33m[2020-07-20 13:15:56][0m  [36;1m[0.65ms][0m  INSERT INTO `comments` (`blog_id`,`re_comment_id`,`comment_name`,`re_comment_name`,`comment_email`,`img`,`comment_content`,`comment_time`) VALUES (1,1,'测试员1','like','admin@qq.com','/static/images/头像1.png','测试回复功能','2020-07-20 13:15:56')  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-20 13:15:56][0m  [36;1m[0.42ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 1)  
[36;31m[1 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-20 13:15:56][0m  [36;1m[0.46ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=1  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-20 13:15:56][0m  [36;1m[0.43ms][0m  UPDATE `blogs` SET `title` = 'golang项目简单服务器部署到阿里云(linux)', `content` = '# 我个人比较推荐使用Xftp和Xshell 
# 重要是个人免费用
# 舒服又好用

# 1.下载安装go安装包：
	## （1）go语言下载地址：
	[Go语言中文网](https://studygolang.com/dl "Go语言中文网")
下载linux版本的安装包。

## （2）使用Xftp将安装包上传至指定的路径：

![](https://img-blog.csdnimg.cn/20190719142701389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
	这里上传到root目录下就行
	方便解压
## （3）解压并移到/usr/local/下：

进入指定目录，查看已有文件并且解压文件：

![](https://img-blog.csdnimg.cn/20190719143211340.png)
```
#在root目录输入ls查看目录文件
ls
#在root解压go包
tar -zxvf go的包名
```

解压完成后发现目录下多了一个go文件夹：
![](https://img-blog.csdnimg.cn/20190719143042938.png)
将文件夹移动到/usr/local/
![](https://img-blog.csdnimg.cn/20190719143137645.png)
# 2.配置环境变量：
## （1）进入目的目录查看go文件夹是否移动成功：
![](https://img-blog.csdnimg.cn/20190719143506382.png)
## （2）在usr下创建文件夹，用来存放自己的项目：
workspace
## （3）进入新建的目录workspace新建三个文件夹：
src
pkg
bin
### 说明：

	src 目录存放的是我们的go源代码，不同工程项目的代码以包名区分
	pkg 编译后生成的文件
	bin文件夹存放go install命名生成的可执行文件（这个文件夹会配置到环境变量中）
## （4）配置环境变量：

进入 /etc 修改profile文件：
![](https://img-blog.csdnimg.cn/20190719144319621.png)
```
#进入etc目录
cd /etc/
#配置 profile
vim profile
```
![](https://img-blog.csdnimg.cn/20190719145650864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
在此文件夹下加入上图的代码，代码如下：
```
// 设置go安装路径
export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin
 
// 设置工程目录
export GOPATH=/usr/workspace
export PATH=$PATH:$GOPATH/bin
```

## （5）刷新环境变量：
```
source /etc/profile
```
##  （6）查看go环境是否配置成功：
```
go version
```
## （7）查看详细配置：
```
go env
```
结果如下：  
![](https://img-blog.csdnimg.cn/20190719145255720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70) 
# 3.上传项目代码：
在刚刚创建的workspace下新创建的三个文件夹中，src 目录存放的是我们的go源代码
# 4运行
```go
go build main.go
//或者
go run main.go
```
最后执行 ./main 就行了。
如果想让项目在后台执行：执行 nohup ./main & ，这样就可以程序在后台运行了。

参考教程https://blog.csdn.net/qq_42410605/article/details/96479892', `image` = 'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3111860246,1925938903&fm=26&gp=0.jpg', `numb` = 10, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '简单又详细的教程', `creat_time` = '2020-07-19 18:32:31', `update_time` = '2020-07-20 13:11:56', `type_id` = 1, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:15:56][0m  [36;1m[0.28ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:15:56][0m  [36;1m[0.41ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 1)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:15:56][0m  [36;1m[0.34ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 2)  
[36;31m[0 rows affected or returned ][0m 
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []}]

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-20 13:16:06][0m  [36;1m[0.40ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 1)  
[36;31m[1 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-20 13:16:06][0m  [36;1m[0.46ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=1  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-20 13:16:06][0m  [36;1m[0.43ms][0m  UPDATE `blogs` SET `title` = 'golang项目简单服务器部署到阿里云(linux)', `content` = '# 我个人比较推荐使用Xftp和Xshell 
# 重要是个人免费用
# 舒服又好用

# 1.下载安装go安装包：
	## （1）go语言下载地址：
	[Go语言中文网](https://studygolang.com/dl "Go语言中文网")
下载linux版本的安装包。

## （2）使用Xftp将安装包上传至指定的路径：

![](https://img-blog.csdnimg.cn/20190719142701389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
	这里上传到root目录下就行
	方便解压
## （3）解压并移到/usr/local/下：

进入指定目录，查看已有文件并且解压文件：

![](https://img-blog.csdnimg.cn/20190719143211340.png)
```
#在root目录输入ls查看目录文件
ls
#在root解压go包
tar -zxvf go的包名
```

解压完成后发现目录下多了一个go文件夹：
![](https://img-blog.csdnimg.cn/20190719143042938.png)
将文件夹移动到/usr/local/
![](https://img-blog.csdnimg.cn/20190719143137645.png)
# 2.配置环境变量：
## （1）进入目的目录查看go文件夹是否移动成功：
![](https://img-blog.csdnimg.cn/20190719143506382.png)
## （2）在usr下创建文件夹，用来存放自己的项目：
workspace
## （3）进入新建的目录workspace新建三个文件夹：
src
pkg
bin
### 说明：

	src 目录存放的是我们的go源代码，不同工程项目的代码以包名区分
	pkg 编译后生成的文件
	bin文件夹存放go install命名生成的可执行文件（这个文件夹会配置到环境变量中）
## （4）配置环境变量：

进入 /etc 修改profile文件：
![](https://img-blog.csdnimg.cn/20190719144319621.png)
```
#进入etc目录
cd /etc/
#配置 profile
vim profile
```
![](https://img-blog.csdnimg.cn/20190719145650864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
在此文件夹下加入上图的代码，代码如下：
```
// 设置go安装路径
export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin
 
// 设置工程目录
export GOPATH=/usr/workspace
export PATH=$PATH:$GOPATH/bin
```

## （5）刷新环境变量：
```
source /etc/profile
```
##  （6）查看go环境是否配置成功：
```
go version
```
## （7）查看详细配置：
```
go env
```
结果如下：  
![](https://img-blog.csdnimg.cn/20190719145255720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70) 
# 3.上传项目代码：
在刚刚创建的workspace下新创建的三个文件夹中，src 目录存放的是我们的go源代码
# 4运行
```go
go build main.go
//或者
go run main.go
```
最后执行 ./main 就行了。
如果想让项目在后台执行：执行 nohup ./main & ，这样就可以程序在后台运行了。

参考教程https://blog.csdn.net/qq_42410605/article/details/96479892', `image` = 'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3111860246,1925938903&fm=26&gp=0.jpg', `numb` = 11, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '简单又详细的教程', `creat_time` = '2020-07-19 18:32:31', `update_time` = '2020-07-20 13:11:56', `type_id` = 1, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:16:06][0m  [36;1m[0.25ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:16:06][0m  [36;1m[0.35ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 1)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:16:06][0m  [36;1m[0.31ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 2)  
[36;31m[0 rows affected or returned ][0m 
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []}]

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:16:26][0m  [36;1m[0.62ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:51)[0m 
[33m[2020-07-20 13:16:26][0m  [36;1m[0.48ms][0m  SELECT * FROM `comments`  WHERE ( comment_name = '狗科' AND comment_email = '1037432782@qq.com') ORDER BY `comments`.`id` ASC LIMIT 1  
[36;31m[0 rows affected or returned ][0m 
进入了3

[35m(/usr/workspace/src/blog/dao/comment.go:11)[0m 
[33m[2020-07-20 13:16:26][0m  [36;1m[0.42ms][0m  INSERT INTO `comments` (`blog_id`,`re_comment_id`,`comment_name`,`re_comment_name`,`comment_email`,`img`,`comment_content`,`comment_time`) VALUES (1,-1,'狗科','','1037432782@qq.com','/static/images/头像1.png','测试','2020-07-20 13:16:26')  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-20 13:16:26][0m  [36;1m[0.53ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 1)  
[36;31m[2 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-20 13:16:26][0m  [36;1m[0.51ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=1  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-20 13:16:26][0m  [36;1m[0.48ms][0m  UPDATE `blogs` SET `title` = 'golang项目简单服务器部署到阿里云(linux)', `content` = '# 我个人比较推荐使用Xftp和Xshell 
# 重要是个人免费用
# 舒服又好用

# 1.下载安装go安装包：
	## （1）go语言下载地址：
	[Go语言中文网](https://studygolang.com/dl "Go语言中文网")
下载linux版本的安装包。

## （2）使用Xftp将安装包上传至指定的路径：

![](https://img-blog.csdnimg.cn/20190719142701389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
	这里上传到root目录下就行
	方便解压
## （3）解压并移到/usr/local/下：

进入指定目录，查看已有文件并且解压文件：

![](https://img-blog.csdnimg.cn/20190719143211340.png)
```
#在root目录输入ls查看目录文件
ls
#在root解压go包
tar -zxvf go的包名
```

解压完成后发现目录下多了一个go文件夹：
![](https://img-blog.csdnimg.cn/20190719143042938.png)
将文件夹移动到/usr/local/
![](https://img-blog.csdnimg.cn/20190719143137645.png)
# 2.配置环境变量：
## （1）进入目的目录查看go文件夹是否移动成功：
![](https://img-blog.csdnimg.cn/20190719143506382.png)
## （2）在usr下创建文件夹，用来存放自己的项目：
workspace
## （3）进入新建的目录workspace新建三个文件夹：
src
pkg
bin
### 说明：

	src 目录存放的是我们的go源代码，不同工程项目的代码以包名区分
	pkg 编译后生成的文件
	bin文件夹存放go install命名生成的可执行文件（这个文件夹会配置到环境变量中）
## （4）配置环境变量：

进入 /etc 修改profile文件：
![](https://img-blog.csdnimg.cn/20190719144319621.png)
```
#进入etc目录
cd /etc/
#配置 profile
vim profile
```
![](https://img-blog.csdnimg.cn/20190719145650864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
在此文件夹下加入上图的代码，代码如下：
```
// 设置go安装路径
export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin
 
// 设置工程目录
export GOPATH=/usr/workspace
export PATH=$PATH:$GOPATH/bin
```

## （5）刷新环境变量：
```
source /etc/profile
```
##  （6）查看go环境是否配置成功：
```
go version
```
## （7）查看详细配置：
```
go env
```
结果如下：  
![](https://img-blog.csdnimg.cn/20190719145255720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70) 
# 3.上传项目代码：
在刚刚创建的workspace下新创建的三个文件夹中，src 目录存放的是我们的go源代码
# 4运行
```go
go build main.go
//或者
go run main.go
```
最后执行 ./main 就行了。
如果想让项目在后台执行：执行 nohup ./main & ，这样就可以程序在后台运行了。

参考教程https://blog.csdn.net/qq_42410605/article/details/96479892', `image` = 'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3111860246,1925938903&fm=26&gp=0.jpg', `numb` = 12, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '简单又详细的教程', `creat_time` = '2020-07-19 18:32:31', `update_time` = '2020-07-20 13:11:56', `type_id` = 1, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:16:26][0m  [36;1m[2.31ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:16:26][0m  [36;1m[0.53ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 1)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:16:26][0m  [36;1m[0.34ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 2)  
[36;31m[0 rows affected or returned ][0m 
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []}]
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:16:26][0m  [36;1m[0.42ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 3)  
[36;31m[0 rows affected or returned ][0m 
[]

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:16:57][0m  [36;1m[0.57ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:51)[0m 
[33m[2020-07-20 13:16:57][0m  [36;1m[0.44ms][0m  SELECT * FROM `comments`  WHERE ( comment_name = '肖浩' AND comment_email = '1037432782@qq.com') ORDER BY `comments`.`id` ASC LIMIT 1  
[36;31m[0 rows affected or returned ][0m 
进入了3

[35m(/usr/workspace/src/blog/dao/comment.go:11)[0m 
[33m[2020-07-20 13:16:57][0m  [36;1m[0.66ms][0m  INSERT INTO `comments` (`blog_id`,`re_comment_id`,`comment_name`,`re_comment_name`,`comment_email`,`img`,`comment_content`,`comment_time`) VALUES (1,2,'肖浩','测试员1','1037432782@qq.com','/static/images/头像3.png','测试成功','2020-07-20 13:16:57')  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-20 13:16:58][0m  [36;1m[0.42ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 1)  
[36;31m[2 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-20 13:16:58][0m  [36;1m[0.42ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=1  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-20 13:16:58][0m  [36;1m[0.40ms][0m  UPDATE `blogs` SET `title` = 'golang项目简单服务器部署到阿里云(linux)', `content` = '# 我个人比较推荐使用Xftp和Xshell 
# 重要是个人免费用
# 舒服又好用

# 1.下载安装go安装包：
	## （1）go语言下载地址：
	[Go语言中文网](https://studygolang.com/dl "Go语言中文网")
下载linux版本的安装包。

## （2）使用Xftp将安装包上传至指定的路径：

![](https://img-blog.csdnimg.cn/20190719142701389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
	这里上传到root目录下就行
	方便解压
## （3）解压并移到/usr/local/下：

进入指定目录，查看已有文件并且解压文件：

![](https://img-blog.csdnimg.cn/20190719143211340.png)
```
#在root目录输入ls查看目录文件
ls
#在root解压go包
tar -zxvf go的包名
```

解压完成后发现目录下多了一个go文件夹：
![](https://img-blog.csdnimg.cn/20190719143042938.png)
将文件夹移动到/usr/local/
![](https://img-blog.csdnimg.cn/20190719143137645.png)
# 2.配置环境变量：
## （1）进入目的目录查看go文件夹是否移动成功：
![](https://img-blog.csdnimg.cn/20190719143506382.png)
## （2）在usr下创建文件夹，用来存放自己的项目：
workspace
## （3）进入新建的目录workspace新建三个文件夹：
src
pkg
bin
### 说明：

	src 目录存放的是我们的go源代码，不同工程项目的代码以包名区分
	pkg 编译后生成的文件
	bin文件夹存放go install命名生成的可执行文件（这个文件夹会配置到环境变量中）
## （4）配置环境变量：

进入 /etc 修改profile文件：
![](https://img-blog.csdnimg.cn/20190719144319621.png)
```
#进入etc目录
cd /etc/
#配置 profile
vim profile
```
![](https://img-blog.csdnimg.cn/20190719145650864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
在此文件夹下加入上图的代码，代码如下：
```
// 设置go安装路径
export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin
 
// 设置工程目录
export GOPATH=/usr/workspace
export PATH=$PATH:$GOPATH/bin
```

## （5）刷新环境变量：
```
source /etc/profile
```
##  （6）查看go环境是否配置成功：
```
go version
```
## （7）查看详细配置：
```
go env
```
结果如下：  
![](https://img-blog.csdnimg.cn/20190719145255720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70) 
# 3.上传项目代码：
在刚刚创建的workspace下新创建的三个文件夹中，src 目录存放的是我们的go源代码
# 4运行
```go
go build main.go
//或者
go run main.go
```
最后执行 ./main 就行了。
如果想让项目在后台执行：执行 nohup ./main & ，这样就可以程序在后台运行了。

参考教程https://blog.csdn.net/qq_42410605/article/details/96479892', `image` = 'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3111860246,1925938903&fm=26&gp=0.jpg', `numb` = 13, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '简单又详细的教程', `creat_time` = '2020-07-19 18:32:31', `update_time` = '2020-07-20 13:11:56', `type_id` = 1, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:16:58][0m  [36;1m[0.27ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:16:58][0m  [36;1m[0.44ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 1)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:16:58][0m  [36;1m[0.34ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 2)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:16:58][0m  [36;1m[0.29ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 4)  
[36;31m[0 rows affected or returned ][0m 
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:16:58][0m  [36;1m[0.31ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 3)  
[36;31m[0 rows affected or returned ][0m 
[]

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-20 13:20:36][0m  [36;1m[0.46ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 1)  
[36;31m[2 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-20 13:20:36][0m  [36;1m[0.47ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=1  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-20 13:20:36][0m  [36;1m[0.42ms][0m  UPDATE `blogs` SET `title` = 'golang项目简单服务器部署到阿里云(linux)', `content` = '# 我个人比较推荐使用Xftp和Xshell 
# 重要是个人免费用
# 舒服又好用

# 1.下载安装go安装包：
	## （1）go语言下载地址：
	[Go语言中文网](https://studygolang.com/dl "Go语言中文网")
下载linux版本的安装包。

## （2）使用Xftp将安装包上传至指定的路径：

![](https://img-blog.csdnimg.cn/20190719142701389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
	这里上传到root目录下就行
	方便解压
## （3）解压并移到/usr/local/下：

进入指定目录，查看已有文件并且解压文件：

![](https://img-blog.csdnimg.cn/20190719143211340.png)
```
#在root目录输入ls查看目录文件
ls
#在root解压go包
tar -zxvf go的包名
```

解压完成后发现目录下多了一个go文件夹：
![](https://img-blog.csdnimg.cn/20190719143042938.png)
将文件夹移动到/usr/local/
![](https://img-blog.csdnimg.cn/20190719143137645.png)
# 2.配置环境变量：
## （1）进入目的目录查看go文件夹是否移动成功：
![](https://img-blog.csdnimg.cn/20190719143506382.png)
## （2）在usr下创建文件夹，用来存放自己的项目：
workspace
## （3）进入新建的目录workspace新建三个文件夹：
src
pkg
bin
### 说明：

	src 目录存放的是我们的go源代码，不同工程项目的代码以包名区分
	pkg 编译后生成的文件
	bin文件夹存放go install命名生成的可执行文件（这个文件夹会配置到环境变量中）
## （4）配置环境变量：

进入 /etc 修改profile文件：
![](https://img-blog.csdnimg.cn/20190719144319621.png)
```
#进入etc目录
cd /etc/
#配置 profile
vim profile
```
![](https://img-blog.csdnimg.cn/20190719145650864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
在此文件夹下加入上图的代码，代码如下：
```
// 设置go安装路径
export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin
 
// 设置工程目录
export GOPATH=/usr/workspace
export PATH=$PATH:$GOPATH/bin
```

## （5）刷新环境变量：
```
source /etc/profile
```
##  （6）查看go环境是否配置成功：
```
go version
```
## （7）查看详细配置：
```
go env
```
结果如下：  
![](https://img-blog.csdnimg.cn/20190719145255720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70) 
# 3.上传项目代码：
在刚刚创建的workspace下新创建的三个文件夹中，src 目录存放的是我们的go源代码
# 4运行
```go
go build main.go
//或者
go run main.go
```
最后执行 ./main 就行了。
如果想让项目在后台执行：执行 nohup ./main & ，这样就可以程序在后台运行了。

参考教程https://blog.csdn.net/qq_42410605/article/details/96479892', `image` = 'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3111860246,1925938903&fm=26&gp=0.jpg', `numb` = 14, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '简单又详细的教程', `creat_time` = '2020-07-19 18:32:31', `update_time` = '2020-07-20 13:11:56', `type_id` = 1, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:20:36][0m  [36;1m[0.30ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:20:36][0m  [36;1m[0.39ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 1)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:20:36][0m  [36;1m[0.36ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 2)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:20:36][0m  [36;1m[0.31ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 4)  
[36;31m[0 rows affected or returned ][0m 
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:20:36][0m  [36;1m[0.31ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 3)  
[36;31m[0 rows affected or returned ][0m 
[]

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-20 13:21:17][0m  [36;1m[0.46ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 1)  
[36;31m[2 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-20 13:21:17][0m  [36;1m[0.49ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=1  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-20 13:21:17][0m  [36;1m[0.41ms][0m  UPDATE `blogs` SET `title` = 'golang项目简单服务器部署到阿里云(linux)', `content` = '# 我个人比较推荐使用Xftp和Xshell 
# 重要是个人免费用
# 舒服又好用

# 1.下载安装go安装包：
	## （1）go语言下载地址：
	[Go语言中文网](https://studygolang.com/dl "Go语言中文网")
下载linux版本的安装包。

## （2）使用Xftp将安装包上传至指定的路径：

![](https://img-blog.csdnimg.cn/20190719142701389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
	这里上传到root目录下就行
	方便解压
## （3）解压并移到/usr/local/下：

进入指定目录，查看已有文件并且解压文件：

![](https://img-blog.csdnimg.cn/20190719143211340.png)
```
#在root目录输入ls查看目录文件
ls
#在root解压go包
tar -zxvf go的包名
```

解压完成后发现目录下多了一个go文件夹：
![](https://img-blog.csdnimg.cn/20190719143042938.png)
将文件夹移动到/usr/local/
![](https://img-blog.csdnimg.cn/20190719143137645.png)
# 2.配置环境变量：
## （1）进入目的目录查看go文件夹是否移动成功：
![](https://img-blog.csdnimg.cn/20190719143506382.png)
## （2）在usr下创建文件夹，用来存放自己的项目：
workspace
## （3）进入新建的目录workspace新建三个文件夹：
src
pkg
bin
### 说明：

	src 目录存放的是我们的go源代码，不同工程项目的代码以包名区分
	pkg 编译后生成的文件
	bin文件夹存放go install命名生成的可执行文件（这个文件夹会配置到环境变量中）
## （4）配置环境变量：

进入 /etc 修改profile文件：
![](https://img-blog.csdnimg.cn/20190719144319621.png)
```
#进入etc目录
cd /etc/
#配置 profile
vim profile
```
![](https://img-blog.csdnimg.cn/20190719145650864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
在此文件夹下加入上图的代码，代码如下：
```
// 设置go安装路径
export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin
 
// 设置工程目录
export GOPATH=/usr/workspace
export PATH=$PATH:$GOPATH/bin
```

## （5）刷新环境变量：
```
source /etc/profile
```
##  （6）查看go环境是否配置成功：
```
go version
```
## （7）查看详细配置：
```
go env
```
结果如下：  
![](https://img-blog.csdnimg.cn/20190719145255720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70) 
# 3.上传项目代码：
在刚刚创建的workspace下新创建的三个文件夹中，src 目录存放的是我们的go源代码
# 4运行
```go
go build main.go
//或者
go run main.go
```
最后执行 ./main 就行了。
如果想让项目在后台执行：执行 nohup ./main & ，这样就可以程序在后台运行了。

参考教程https://blog.csdn.net/qq_42410605/article/details/96479892', `image` = 'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3111860246,1925938903&fm=26&gp=0.jpg', `numb` = 15, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '简单又详细的教程', `creat_time` = '2020-07-19 18:32:31', `update_time` = '2020-07-20 13:11:56', `type_id` = 1, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:21:17][0m  [36;1m[0.37ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:21:17][0m  [36;1m[0.54ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 1)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:21:17][0m  [36;1m[0.32ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 2)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:21:17][0m  [36;1m[0.31ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 4)  
[36;31m[0 rows affected or returned ][0m 
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:21:17][0m  [36;1m[0.31ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 3)  
[36;31m[0 rows affected or returned ][0m 
[]

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-20 13:22:32][0m  [36;1m[0.71ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 1)  
[36;31m[2 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-20 13:22:32][0m  [36;1m[0.76ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=1  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-20 13:22:32][0m  [36;1m[0.66ms][0m  UPDATE `blogs` SET `title` = 'golang项目简单服务器部署到阿里云(linux)', `content` = '# 我个人比较推荐使用Xftp和Xshell 
# 重要是个人免费用
# 舒服又好用

# 1.下载安装go安装包：
	## （1）go语言下载地址：
	[Go语言中文网](https://studygolang.com/dl "Go语言中文网")
下载linux版本的安装包。

## （2）使用Xftp将安装包上传至指定的路径：

![](https://img-blog.csdnimg.cn/20190719142701389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
	这里上传到root目录下就行
	方便解压
## （3）解压并移到/usr/local/下：

进入指定目录，查看已有文件并且解压文件：

![](https://img-blog.csdnimg.cn/20190719143211340.png)
```
#在root目录输入ls查看目录文件
ls
#在root解压go包
tar -zxvf go的包名
```

解压完成后发现目录下多了一个go文件夹：
![](https://img-blog.csdnimg.cn/20190719143042938.png)
将文件夹移动到/usr/local/
![](https://img-blog.csdnimg.cn/20190719143137645.png)
# 2.配置环境变量：
## （1）进入目的目录查看go文件夹是否移动成功：
![](https://img-blog.csdnimg.cn/20190719143506382.png)
## （2）在usr下创建文件夹，用来存放自己的项目：
workspace
## （3）进入新建的目录workspace新建三个文件夹：
src
pkg
bin
### 说明：

	src 目录存放的是我们的go源代码，不同工程项目的代码以包名区分
	pkg 编译后生成的文件
	bin文件夹存放go install命名生成的可执行文件（这个文件夹会配置到环境变量中）
## （4）配置环境变量：

进入 /etc 修改profile文件：
![](https://img-blog.csdnimg.cn/20190719144319621.png)
```
#进入etc目录
cd /etc/
#配置 profile
vim profile
```
![](https://img-blog.csdnimg.cn/20190719145650864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
在此文件夹下加入上图的代码，代码如下：
```
// 设置go安装路径
export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin
 
// 设置工程目录
export GOPATH=/usr/workspace
export PATH=$PATH:$GOPATH/bin
```

## （5）刷新环境变量：
```
source /etc/profile
```
##  （6）查看go环境是否配置成功：
```
go version
```
## （7）查看详细配置：
```
go env
```
结果如下：  
![](https://img-blog.csdnimg.cn/20190719145255720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70) 
# 3.上传项目代码：
在刚刚创建的workspace下新创建的三个文件夹中，src 目录存放的是我们的go源代码
# 4运行
```go
go build main.go
//或者
go run main.go
```
最后执行 ./main 就行了。
如果想让项目在后台执行：执行 nohup ./main & ，这样就可以程序在后台运行了。

参考教程https://blog.csdn.net/qq_42410605/article/details/96479892', `image` = 'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3111860246,1925938903&fm=26&gp=0.jpg', `numb` = 16, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '简单又详细的教程', `creat_time` = '2020-07-19 18:32:31', `update_time` = '2020-07-20 13:11:56', `type_id` = 1, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:22:32][0m  [36;1m[0.33ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:22:32][0m  [36;1m[0.42ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 1)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:22:32][0m  [36;1m[0.33ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 2)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:22:32][0m  [36;1m[0.28ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 4)  
[36;31m[0 rows affected or returned ][0m 
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:22:32][0m  [36;1m[0.29ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 3)  
[36;31m[0 rows affected or returned ][0m 
[]

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-20 13:22:39][0m  [36;1m[0.45ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 1)  
[36;31m[2 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-20 13:22:39][0m  [36;1m[0.52ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=1  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-20 13:22:39][0m  [36;1m[0.43ms][0m  UPDATE `blogs` SET `title` = 'golang项目简单服务器部署到阿里云(linux)', `content` = '# 我个人比较推荐使用Xftp和Xshell 
# 重要是个人免费用
# 舒服又好用

# 1.下载安装go安装包：
	## （1）go语言下载地址：
	[Go语言中文网](https://studygolang.com/dl "Go语言中文网")
下载linux版本的安装包。

## （2）使用Xftp将安装包上传至指定的路径：

![](https://img-blog.csdnimg.cn/20190719142701389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
	这里上传到root目录下就行
	方便解压
## （3）解压并移到/usr/local/下：

进入指定目录，查看已有文件并且解压文件：

![](https://img-blog.csdnimg.cn/20190719143211340.png)
```
#在root目录输入ls查看目录文件
ls
#在root解压go包
tar -zxvf go的包名
```

解压完成后发现目录下多了一个go文件夹：
![](https://img-blog.csdnimg.cn/20190719143042938.png)
将文件夹移动到/usr/local/
![](https://img-blog.csdnimg.cn/20190719143137645.png)
# 2.配置环境变量：
## （1）进入目的目录查看go文件夹是否移动成功：
![](https://img-blog.csdnimg.cn/20190719143506382.png)
## （2）在usr下创建文件夹，用来存放自己的项目：
workspace
## （3）进入新建的目录workspace新建三个文件夹：
src
pkg
bin
### 说明：

	src 目录存放的是我们的go源代码，不同工程项目的代码以包名区分
	pkg 编译后生成的文件
	bin文件夹存放go install命名生成的可执行文件（这个文件夹会配置到环境变量中）
## （4）配置环境变量：

进入 /etc 修改profile文件：
![](https://img-blog.csdnimg.cn/20190719144319621.png)
```
#进入etc目录
cd /etc/
#配置 profile
vim profile
```
![](https://img-blog.csdnimg.cn/20190719145650864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
在此文件夹下加入上图的代码，代码如下：
```
// 设置go安装路径
export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin
 
// 设置工程目录
export GOPATH=/usr/workspace
export PATH=$PATH:$GOPATH/bin
```

## （5）刷新环境变量：
```
source /etc/profile
```
##  （6）查看go环境是否配置成功：
```
go version
```
## （7）查看详细配置：
```
go env
```
结果如下：  
![](https://img-blog.csdnimg.cn/20190719145255720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70) 
# 3.上传项目代码：
在刚刚创建的workspace下新创建的三个文件夹中，src 目录存放的是我们的go源代码
# 4运行
```go
go build main.go
//或者
go run main.go
```
最后执行 ./main 就行了。
如果想让项目在后台执行：执行 nohup ./main & ，这样就可以程序在后台运行了。

参考教程https://blog.csdn.net/qq_42410605/article/details/96479892', `image` = 'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3111860246,1925938903&fm=26&gp=0.jpg', `numb` = 17, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '简单又详细的教程', `creat_time` = '2020-07-19 18:32:31', `update_time` = '2020-07-20 13:11:56', `type_id` = 1, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:22:39][0m  [36;1m[0.28ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:22:39][0m  [36;1m[0.46ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 1)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:22:39][0m  [36;1m[0.35ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 2)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:22:39][0m  [36;1m[0.34ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 4)  
[36;31m[0 rows affected or returned ][0m 
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:22:39][0m  [36;1m[0.34ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 3)  
[36;31m[0 rows affected or returned ][0m 
[]

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-20 13:22:43][0m  [36;1m[0.45ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 1)  
[36;31m[2 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-20 13:22:43][0m  [36;1m[0.47ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=1  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-20 13:22:43][0m  [36;1m[0.43ms][0m  UPDATE `blogs` SET `title` = 'golang项目简单服务器部署到阿里云(linux)', `content` = '# 我个人比较推荐使用Xftp和Xshell 
# 重要是个人免费用
# 舒服又好用

# 1.下载安装go安装包：
	## （1）go语言下载地址：
	[Go语言中文网](https://studygolang.com/dl "Go语言中文网")
下载linux版本的安装包。

## （2）使用Xftp将安装包上传至指定的路径：

![](https://img-blog.csdnimg.cn/20190719142701389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
	这里上传到root目录下就行
	方便解压
## （3）解压并移到/usr/local/下：

进入指定目录，查看已有文件并且解压文件：

![](https://img-blog.csdnimg.cn/20190719143211340.png)
```
#在root目录输入ls查看目录文件
ls
#在root解压go包
tar -zxvf go的包名
```

解压完成后发现目录下多了一个go文件夹：
![](https://img-blog.csdnimg.cn/20190719143042938.png)
将文件夹移动到/usr/local/
![](https://img-blog.csdnimg.cn/20190719143137645.png)
# 2.配置环境变量：
## （1）进入目的目录查看go文件夹是否移动成功：
![](https://img-blog.csdnimg.cn/20190719143506382.png)
## （2）在usr下创建文件夹，用来存放自己的项目：
workspace
## （3）进入新建的目录workspace新建三个文件夹：
src
pkg
bin
### 说明：

	src 目录存放的是我们的go源代码，不同工程项目的代码以包名区分
	pkg 编译后生成的文件
	bin文件夹存放go install命名生成的可执行文件（这个文件夹会配置到环境变量中）
## （4）配置环境变量：

进入 /etc 修改profile文件：
![](https://img-blog.csdnimg.cn/20190719144319621.png)
```
#进入etc目录
cd /etc/
#配置 profile
vim profile
```
![](https://img-blog.csdnimg.cn/20190719145650864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
在此文件夹下加入上图的代码，代码如下：
```
// 设置go安装路径
export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin
 
// 设置工程目录
export GOPATH=/usr/workspace
export PATH=$PATH:$GOPATH/bin
```

## （5）刷新环境变量：
```
source /etc/profile
```
##  （6）查看go环境是否配置成功：
```
go version
```
## （7）查看详细配置：
```
go env
```
结果如下：  
![](https://img-blog.csdnimg.cn/20190719145255720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70) 
# 3.上传项目代码：
在刚刚创建的workspace下新创建的三个文件夹中，src 目录存放的是我们的go源代码
# 4运行
```go
go build main.go
//或者
go run main.go
```
最后执行 ./main 就行了。
如果想让项目在后台执行：执行 nohup ./main & ，这样就可以程序在后台运行了。

参考教程https://blog.csdn.net/qq_42410605/article/details/96479892', `image` = 'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3111860246,1925938903&fm=26&gp=0.jpg', `numb` = 18, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '简单又详细的教程', `creat_time` = '2020-07-19 18:32:31', `update_time` = '2020-07-20 13:11:56', `type_id` = 1, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:22:43][0m  [36;1m[0.28ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:22:43][0m  [36;1m[0.39ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 1)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:22:43][0m  [36;1m[0.36ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 2)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:22:43][0m  [36;1m[0.32ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 4)  
[36;31m[0 rows affected or returned ][0m 
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:22:43][0m  [36;1m[0.35ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 3)  
[36;31m[0 rows affected or returned ][0m 
[]

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:22:47][0m  [36;1m[0.53ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 13:22:47][0m  [36;1m[0.72ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 13:22:47][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
3

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 13:22:47][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 13:22:47][0m  [36;1m[0.27ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 13:22:47][0m  [36;1m[0.35ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 13:22:48][0m  [36;1m[0.50ms][0m  SELECT * FROM `types`    
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:22:48][0m  [36;1m[0.26ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 13:22:48][0m  [36;1m[0.66ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-20 13:22:48][0m  [36;1m[0.18ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-20 13:22:49][0m  [36;1m[0.53ms][0m  SELECT * FROM `tags`    
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:22:49][0m  [36;1m[0.28ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 13:22:49][0m  [36;1m[0.63ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:31)[0m 
[33m[2020-07-20 13:22:49][0m  [36;1m[0.18ms][0m  SELECT count(*) FROM `tags`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:22:50][0m  [36;1m[0.62ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:22:51][0m  [36;1m[0.77ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 13:22:51][0m  [36;1m[0.30ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:137)[0m 
[33m[2020-07-20 13:22:51][0m  [36;1m[0.92ms][0m   SELECT * FROM `blogs` GROUP BY YEAR DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:150)[0m 
[33m[2020-07-20 13:22:51][0m  [36;1m[1.43ms][0m   SELECT * FROM `blogs` where year = 2020 GROUP BY month DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:162)[0m 
[33m[2020-07-20 13:22:51][0m  [36;1m[0.95ms][0m   SELECT * FROM `blogs` where year = 2020 and month = 7 ORDER BY `id` DESC  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 13:22:51][0m  [36;1m[0.60ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=3  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 13:22:51][0m  [36;1m[0.53ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=2  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 13:22:51][0m  [36;1m[0.54ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:22:52][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:22:53][0m  [36;1m[0.58ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 13:22:53][0m  [36;1m[0.22ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:137)[0m 
[33m[2020-07-20 13:22:53][0m  [36;1m[0.64ms][0m   SELECT * FROM `blogs` GROUP BY YEAR DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:150)[0m 
[33m[2020-07-20 13:22:53][0m  [36;1m[0.73ms][0m   SELECT * FROM `blogs` where year = 2020 GROUP BY month DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:162)[0m 
[33m[2020-07-20 13:22:53][0m  [36;1m[0.57ms][0m   SELECT * FROM `blogs` where year = 2020 and month = 7 ORDER BY `id` DESC  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 13:22:53][0m  [36;1m[0.40ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=3  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 13:22:53][0m  [36;1m[0.37ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=2  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 13:22:53][0m  [36;1m[0.40ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-20 13:22:53][0m  [36;1m[0.56ms][0m  SELECT * FROM `tags`    
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:22:53][0m  [36;1m[0.29ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 13:22:53][0m  [36;1m[0.77ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:31)[0m 
[33m[2020-07-20 13:22:53][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `tags`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 13:22:54][0m  [36;1m[0.49ms][0m  SELECT * FROM `types`    
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:22:54][0m  [36;1m[0.24ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 13:22:54][0m  [36;1m[0.65ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-20 13:22:54][0m  [36;1m[0.18ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:22:55][0m  [36;1m[0.56ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 13:22:55][0m  [36;1m[0.72ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 13:22:55][0m  [36;1m[0.22ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
3

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 13:22:55][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 13:22:55][0m  [36;1m[0.28ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 13:22:55][0m  [36;1m[0.35ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-20 13:22:57][0m  [36;1m[0.36ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 3)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-20 13:22:57][0m  [36;1m[0.43ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=3  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-20 13:22:57][0m  [36;1m[0.38ms][0m  UPDATE `blogs` SET `title` = 'mysql5.7 查询数据，group by 报错：Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 't.id' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by？', `content` = '在做归档功能时用到了分组查询
结果出现了这样的错误
```
Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 't.id' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by

```
查询才知道
mysql 5.7 加入的新特性，only_full_group_by，它只允许你的查询字段是包括在 group by 里面的字段，这种模式导致无法我们无法得到想要的字段值，我们可以禁用掉 only_full_group_by：
### 第一步：
```
select @@GLOBAL.sql_mode;
```
得到现有的 sql_mode, 如下：
```
ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION

```
### 第二步：
```
set global sql_mode ='STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION';

set session sql_mode= 'STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION';
```
去除 ONLY_FULL_GROUP_BY，重新设置，就 ok 了。', `image` = 'https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2507389442,2201469096&fm=26&gp=0.jpg', `numb` = 17, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '', `recommend` = '是', `description` = '在做归档功能时用到了分组查询，结果出现了这样的错误，原来是mysql57的新功能
', `creat_time` = '2020-07-19 18:58:22', `update_time` = '2020-07-19 18:59:30', `type_id` = 3, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 2  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:22:57][0m  [36;1m[0.28ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:23:05][0m  [36;1m[0.56ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 13:23:05][0m  [36;1m[0.22ms][0m  SELECT * FROM `types`    
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-20 13:23:05][0m  [36;1m[0.21ms][0m  SELECT * FROM `tags`    
[36;31m[3 rows affected or returned ][0m 
{0    0         [] 0 {0  []} 0 0 0} ceshi

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:24:21][0m  [36;1m[0.53ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 13:24:21][0m  [36;1m[0.71ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 13:24:21][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
3

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 13:24:21][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 13:24:21][0m  [36;1m[0.24ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 13:24:21][0m  [36;1m[0.31ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-20 13:24:23][0m  [36;1m[0.37ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 3)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-20 13:24:23][0m  [36;1m[0.45ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=3  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-20 13:24:23][0m  [36;1m[0.40ms][0m  UPDATE `blogs` SET `title` = 'mysql5.7 查询数据，group by 报错：Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 't.id' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by？', `content` = '在做归档功能时用到了分组查询
结果出现了这样的错误
```
Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 't.id' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by

```
查询才知道
mysql 5.7 加入的新特性，only_full_group_by，它只允许你的查询字段是包括在 group by 里面的字段，这种模式导致无法我们无法得到想要的字段值，我们可以禁用掉 only_full_group_by：
### 第一步：
```
select @@GLOBAL.sql_mode;
```
得到现有的 sql_mode, 如下：
```
ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION

```
### 第二步：
```
set global sql_mode ='STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION';

set session sql_mode= 'STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION';
```
去除 ONLY_FULL_GROUP_BY，重新设置，就 ok 了。', `image` = 'https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2507389442,2201469096&fm=26&gp=0.jpg', `numb` = 18, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '', `recommend` = '是', `description` = '在做归档功能时用到了分组查询，结果出现了这样的错误，原来是mysql57的新功能
', `creat_time` = '2020-07-19 18:58:22', `update_time` = '2020-07-19 18:59:30', `type_id` = 3, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 2  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:24:23][0m  [36;1m[0.50ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:24:27][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 13:24:27][0m  [36;1m[0.68ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 13:24:27][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
3

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 13:24:27][0m  [36;1m[0.31ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 13:24:27][0m  [36;1m[0.24ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 13:24:27][0m  [36;1m[0.30ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:24:28][0m  [36;1m[0.63ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 13:24:28][0m  [36;1m[0.26ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:137)[0m 
[33m[2020-07-20 13:24:28][0m  [36;1m[0.69ms][0m   SELECT * FROM `blogs` GROUP BY YEAR DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:150)[0m 
[33m[2020-07-20 13:24:28][0m  [36;1m[1.76ms][0m   SELECT * FROM `blogs` where year = 2020 GROUP BY month DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:162)[0m 
[33m[2020-07-20 13:24:28][0m  [36;1m[0.57ms][0m   SELECT * FROM `blogs` where year = 2020 and month = 7 ORDER BY `id` DESC  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 13:24:28][0m  [36;1m[0.40ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=3  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 13:24:28][0m  [36;1m[0.38ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=2  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 13:24:28][0m  [36;1m[0.35ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:24:30][0m  [36;1m[0.53ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:24:31][0m  [36;1m[0.57ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 13:24:31][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:137)[0m 
[33m[2020-07-20 13:24:31][0m  [36;1m[0.58ms][0m   SELECT * FROM `blogs` GROUP BY YEAR DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:150)[0m 
[33m[2020-07-20 13:24:31][0m  [36;1m[0.65ms][0m   SELECT * FROM `blogs` where year = 2020 GROUP BY month DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:162)[0m 
[33m[2020-07-20 13:24:31][0m  [36;1m[0.55ms][0m   SELECT * FROM `blogs` where year = 2020 and month = 7 ORDER BY `id` DESC  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 13:24:31][0m  [36;1m[0.37ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=3  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 13:24:31][0m  [36;1m[0.32ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=2  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 13:24:31][0m  [36;1m[0.35ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:24:32][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 13:24:32][0m  [36;1m[0.68ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 13:24:32][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
3

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 13:24:32][0m  [36;1m[0.31ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 13:24:32][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 13:24:32][0m  [36;1m[0.30ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:24:33][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 13:24:33][0m  [36;1m[0.27ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:137)[0m 
[33m[2020-07-20 13:24:33][0m  [36;1m[0.66ms][0m   SELECT * FROM `blogs` GROUP BY YEAR DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:150)[0m 
[33m[2020-07-20 13:24:33][0m  [36;1m[2.21ms][0m   SELECT * FROM `blogs` where year = 2020 GROUP BY month DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:162)[0m 
[33m[2020-07-20 13:24:33][0m  [36;1m[0.62ms][0m   SELECT * FROM `blogs` where year = 2020 and month = 7 ORDER BY `id` DESC  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 13:24:33][0m  [36;1m[0.41ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=3  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 13:24:33][0m  [36;1m[0.37ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=2  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 13:24:33][0m  [36;1m[0.34ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:24:35][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:24:36][0m  [36;1m[0.52ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 13:24:36][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:137)[0m 
[33m[2020-07-20 13:24:36][0m  [36;1m[0.61ms][0m   SELECT * FROM `blogs` GROUP BY YEAR DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:150)[0m 
[33m[2020-07-20 13:24:36][0m  [36;1m[0.67ms][0m   SELECT * FROM `blogs` where year = 2020 GROUP BY month DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:162)[0m 
[33m[2020-07-20 13:24:36][0m  [36;1m[0.51ms][0m   SELECT * FROM `blogs` where year = 2020 and month = 7 ORDER BY `id` DESC  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 13:24:36][0m  [36;1m[0.38ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=3  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 13:24:36][0m  [36;1m[0.33ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=2  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 13:24:36][0m  [36;1m[0.34ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-20 13:24:37][0m  [36;1m[0.51ms][0m  SELECT * FROM `tags`    
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:24:37][0m  [36;1m[0.26ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 13:24:37][0m  [36;1m[0.66ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:31)[0m 
[33m[2020-07-20 13:24:37][0m  [36;1m[0.23ms][0m  SELECT count(*) FROM `tags`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:24:38][0m  [36;1m[0.63ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:24:39][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 13:24:39][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:137)[0m 
[33m[2020-07-20 13:24:39][0m  [36;1m[0.65ms][0m   SELECT * FROM `blogs` GROUP BY YEAR DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:150)[0m 
[33m[2020-07-20 13:24:39][0m  [36;1m[0.65ms][0m   SELECT * FROM `blogs` where year = 2020 GROUP BY month DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:162)[0m 
[33m[2020-07-20 13:24:39][0m  [36;1m[0.58ms][0m   SELECT * FROM `blogs` where year = 2020 and month = 7 ORDER BY `id` DESC  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 13:24:39][0m  [36;1m[0.37ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=3  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 13:24:39][0m  [36;1m[0.37ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=2  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 13:24:39][0m  [36;1m[0.33ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:24:55][0m  [36;1m[0.51ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 13:24:55][0m  [36;1m[0.63ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 13:24:55][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
3

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 13:24:55][0m  [36;1m[0.28ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 13:24:55][0m  [36;1m[0.25ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 13:24:55][0m  [36;1m[0.31ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 13:24:57][0m  [36;1m[0.53ms][0m  SELECT * FROM `types`    
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:24:57][0m  [36;1m[0.24ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 13:24:57][0m  [36;1m[0.71ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-20 13:24:57][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:24:58][0m  [36;1m[0.56ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 13:24:58][0m  [36;1m[0.68ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 13:24:58][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
3

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 13:24:58][0m  [36;1m[0.32ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 13:24:58][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 13:24:58][0m  [36;1m[0.30ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 13:24:59][0m  [36;1m[0.51ms][0m  SELECT * FROM `types`    
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:24:59][0m  [36;1m[0.28ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 13:24:59][0m  [36;1m[0.68ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-20 13:24:59][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:25:00][0m  [36;1m[0.53ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 13:25:00][0m  [36;1m[0.69ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 13:25:00][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
3

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 13:25:00][0m  [36;1m[0.27ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 13:25:00][0m  [36;1m[0.24ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 13:25:00][0m  [36;1m[0.32ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:26:15][0m  [36;1m[0.58ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 13:26:15][0m  [36;1m[0.77ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 13:26:15][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
3

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 13:26:15][0m  [36;1m[0.34ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 13:26:15][0m  [36;1m[0.28ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 13:26:15][0m  [36;1m[0.32ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 13:26:16][0m  [36;1m[0.56ms][0m  SELECT * FROM `types`    
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:26:16][0m  [36;1m[0.28ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 13:26:16][0m  [36;1m[0.70ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-20 13:26:16][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:26:17][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 13:26:17][0m  [36;1m[0.67ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 13:26:17][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
3

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 13:26:17][0m  [36;1m[0.32ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 13:26:17][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 13:26:17][0m  [36;1m[0.34ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:26:19][0m  [36;1m[0.57ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 13:26:19][0m  [36;1m[0.70ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 13:26:19][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
3

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 13:26:19][0m  [36;1m[0.29ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 13:26:19][0m  [36;1m[0.27ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 13:26:19][0m  [36;1m[0.31ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 13:26:20][0m  [36;1m[0.52ms][0m  SELECT * FROM `types`    
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:26:20][0m  [36;1m[0.25ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 13:26:20][0m  [36;1m[0.66ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-20 13:26:20][0m  [36;1m[0.18ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:26:21][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 13:26:21][0m  [36;1m[0.69ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 13:26:21][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
3

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 13:26:21][0m  [36;1m[0.26ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 13:26:21][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 13:26:21][0m  [36;1m[0.33ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-20 13:26:22][0m  [36;1m[0.36ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 2)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-20 13:26:22][0m  [36;1m[0.43ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=2  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-20 13:26:22][0m  [36;1m[0.38ms][0m  UPDATE `blogs` SET `title` = '解决Linux关闭终端后运行的程序自动停止', `content` = '# 问题发现
  昨天博客发布，操作完关闭终端就睡了
  然而今天醒来突然发现终端不能访问了
  查看发现原来博客项目进程被杀死了
# 解决办法
    go build main.go
执行完后

    nohup ./main &
让程序在后台运行就可了


[========]
# ps:这个方法并不完美，因为我也是刚刚接触还不知道怎么切回来', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3696516981,3671280793&fm=26&gp=0.jpg', `numb` = 8, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '', `recommend` = '是', `description` = '昨天博客发布，操作完关闭终端就睡了，然而今天醒来突然发现终端不能访问了，查看发现原来博客项目进程被杀死了', `creat_time` = '2020-07-19 19:05:36', `update_time` = '2020-07-19 19:05:36', `type_id` = 2, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 3  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:26:22][0m  [36;1m[0.29ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:29:29][0m  [36;1m[0.59ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:38)[0m 
[33m[2020-07-20 13:29:29][0m  [36;1m[0.50ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.recommend,blogs.update_time FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY `blogs`.`id` LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 
&[{1 golang项目简单服务器部署到阿里云(linux) 0 go 是 2020-07-20 13:11:56} {2 mysql5.7 查询数据，group by 报错：Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 't.id' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by？ 0 mysql 是 2020-07-19 18:59:30} {3 解决Linux关闭终端后运行的程序自动停止 0 linux 是 2020-07-19 19:05:36}]
3 ceshi

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 13:29:29][0m  [36;1m[0.23ms][0m  SELECT * FROM `types`    
[36;31m[3 rows affected or returned ][0m 
0

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-20 13:29:34][0m  [36;1m[0.40ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 2)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-20 13:29:34][0m  [36;1m[0.43ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=2  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-20 13:29:34][0m  [36;1m[0.44ms][0m  UPDATE `blogs` SET `title` = '解决Linux关闭终端后运行的程序自动停止', `content` = '# 问题发现
  昨天博客发布，操作完关闭终端就睡了
  然而今天醒来突然发现终端不能访问了
  查看发现原来博客项目进程被杀死了
# 解决办法
    go build main.go
执行完后

    nohup ./main &
让程序在后台运行就可了


[========]
# ps:这个方法并不完美，因为我也是刚刚接触还不知道怎么切回来', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3696516981,3671280793&fm=26&gp=0.jpg', `numb` = 9, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '昨天博客发布，操作完关闭终端就睡了，然而今天醒来突然发现终端不能访问了，查看发现原来博客项目进程被杀死了', `creat_time` = '2020-07-19 19:05:36', `update_time` = '2020-07-19 19:05:36', `type_id` = 2, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 3  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:29:34][0m  [36;1m[0.33ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:29:47][0m  [36;1m[0.52ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 13:29:47][0m  [36;1m[0.69ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 13:29:47][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
3

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 13:29:47][0m  [36;1m[0.29ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 13:29:47][0m  [36;1m[0.28ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 13:29:47][0m  [36;1m[0.31ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-20 13:29:49][0m  [36;1m[0.45ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 1)  
[36;31m[2 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-20 13:29:49][0m  [36;1m[0.43ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=1  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-20 13:29:49][0m  [36;1m[0.39ms][0m  UPDATE `blogs` SET `title` = 'golang项目简单服务器部署到阿里云(linux)', `content` = '# 我个人比较推荐使用Xftp和Xshell 
# 重要是个人免费用
# 舒服又好用

# 1.下载安装go安装包：
	## （1）go语言下载地址：
	[Go语言中文网](https://studygolang.com/dl "Go语言中文网")
下载linux版本的安装包。

## （2）使用Xftp将安装包上传至指定的路径：

![](https://img-blog.csdnimg.cn/20190719142701389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
	这里上传到root目录下就行
	方便解压
## （3）解压并移到/usr/local/下：

进入指定目录，查看已有文件并且解压文件：

![](https://img-blog.csdnimg.cn/20190719143211340.png)
```
#在root目录输入ls查看目录文件
ls
#在root解压go包
tar -zxvf go的包名
```

解压完成后发现目录下多了一个go文件夹：
![](https://img-blog.csdnimg.cn/20190719143042938.png)
将文件夹移动到/usr/local/
![](https://img-blog.csdnimg.cn/20190719143137645.png)
# 2.配置环境变量：
## （1）进入目的目录查看go文件夹是否移动成功：
![](https://img-blog.csdnimg.cn/20190719143506382.png)
## （2）在usr下创建文件夹，用来存放自己的项目：
workspace
## （3）进入新建的目录workspace新建三个文件夹：
src
pkg
bin
### 说明：

	src 目录存放的是我们的go源代码，不同工程项目的代码以包名区分
	pkg 编译后生成的文件
	bin文件夹存放go install命名生成的可执行文件（这个文件夹会配置到环境变量中）
## （4）配置环境变量：

进入 /etc 修改profile文件：
![](https://img-blog.csdnimg.cn/20190719144319621.png)
```
#进入etc目录
cd /etc/
#配置 profile
vim profile
```
![](https://img-blog.csdnimg.cn/20190719145650864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
在此文件夹下加入上图的代码，代码如下：
```
// 设置go安装路径
export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin
 
// 设置工程目录
export GOPATH=/usr/workspace
export PATH=$PATH:$GOPATH/bin
```

## （5）刷新环境变量：
```
source /etc/profile
```
##  （6）查看go环境是否配置成功：
```
go version
```
## （7）查看详细配置：
```
go env
```
结果如下：  
![](https://img-blog.csdnimg.cn/20190719145255720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70) 
# 3.上传项目代码：
在刚刚创建的workspace下新创建的三个文件夹中，src 目录存放的是我们的go源代码
# 4运行
```go
go build main.go
//或者
go run main.go
```
最后执行 ./main 就行了。
如果想让项目在后台执行：执行 nohup ./main & ，这样就可以程序在后台运行了。

参考教程https://blog.csdn.net/qq_42410605/article/details/96479892', `image` = 'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3111860246,1925938903&fm=26&gp=0.jpg', `numb` = 19, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '简单又详细的教程', `creat_time` = '2020-07-19 18:32:31', `update_time` = '2020-07-20 13:11:56', `type_id` = 1, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:29:49][0m  [36;1m[0.27ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:29:49][0m  [36;1m[0.40ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 1)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:29:49][0m  [36;1m[0.36ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 2)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:29:49][0m  [36;1m[0.30ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 4)  
[36;31m[0 rows affected or returned ][0m 
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:29:49][0m  [36;1m[0.35ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 3)  
[36;31m[0 rows affected or returned ][0m 
[]

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:30:17][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:51)[0m 
[33m[2020-07-20 13:30:17][0m  [36;1m[0.51ms][0m  SELECT * FROM `comments`  WHERE ( comment_name = 'like' AND comment_email = '535889315@qq.com') ORDER BY `comments`.`id` ASC LIMIT 1  
[36;31m[1 rows affected or returned ][0m 
进入了1

[35m(/usr/workspace/src/blog/dao/comment.go:11)[0m 
[33m[2020-07-20 13:30:17][0m  [36;1m[0.33ms][0m  INSERT INTO `comments` (`blog_id`,`re_comment_id`,`comment_name`,`re_comment_name`,`comment_email`,`img`,`comment_content`,`comment_time`) VALUES (1,3,'like','狗科','535889315@qq.com','/static/images/header.jpg','？？？','2020-07-20 13:30:17')  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-20 13:30:17][0m  [36;1m[0.41ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 1)  
[36;31m[2 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-20 13:30:17][0m  [36;1m[0.46ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=1  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-20 13:30:17][0m  [36;1m[0.45ms][0m  UPDATE `blogs` SET `title` = 'golang项目简单服务器部署到阿里云(linux)', `content` = '# 我个人比较推荐使用Xftp和Xshell 
# 重要是个人免费用
# 舒服又好用

# 1.下载安装go安装包：
	## （1）go语言下载地址：
	[Go语言中文网](https://studygolang.com/dl "Go语言中文网")
下载linux版本的安装包。

## （2）使用Xftp将安装包上传至指定的路径：

![](https://img-blog.csdnimg.cn/20190719142701389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
	这里上传到root目录下就行
	方便解压
## （3）解压并移到/usr/local/下：

进入指定目录，查看已有文件并且解压文件：

![](https://img-blog.csdnimg.cn/20190719143211340.png)
```
#在root目录输入ls查看目录文件
ls
#在root解压go包
tar -zxvf go的包名
```

解压完成后发现目录下多了一个go文件夹：
![](https://img-blog.csdnimg.cn/20190719143042938.png)
将文件夹移动到/usr/local/
![](https://img-blog.csdnimg.cn/20190719143137645.png)
# 2.配置环境变量：
## （1）进入目的目录查看go文件夹是否移动成功：
![](https://img-blog.csdnimg.cn/20190719143506382.png)
## （2）在usr下创建文件夹，用来存放自己的项目：
workspace
## （3）进入新建的目录workspace新建三个文件夹：
src
pkg
bin
### 说明：

	src 目录存放的是我们的go源代码，不同工程项目的代码以包名区分
	pkg 编译后生成的文件
	bin文件夹存放go install命名生成的可执行文件（这个文件夹会配置到环境变量中）
## （4）配置环境变量：

进入 /etc 修改profile文件：
![](https://img-blog.csdnimg.cn/20190719144319621.png)
```
#进入etc目录
cd /etc/
#配置 profile
vim profile
```
![](https://img-blog.csdnimg.cn/20190719145650864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
在此文件夹下加入上图的代码，代码如下：
```
// 设置go安装路径
export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin
 
// 设置工程目录
export GOPATH=/usr/workspace
export PATH=$PATH:$GOPATH/bin
```

## （5）刷新环境变量：
```
source /etc/profile
```
##  （6）查看go环境是否配置成功：
```
go version
```
## （7）查看详细配置：
```
go env
```
结果如下：  
![](https://img-blog.csdnimg.cn/20190719145255720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70) 
# 3.上传项目代码：
在刚刚创建的workspace下新创建的三个文件夹中，src 目录存放的是我们的go源代码
# 4运行
```go
go build main.go
//或者
go run main.go
```
最后执行 ./main 就行了。
如果想让项目在后台执行：执行 nohup ./main & ，这样就可以程序在后台运行了。

参考教程https://blog.csdn.net/qq_42410605/article/details/96479892', `image` = 'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3111860246,1925938903&fm=26&gp=0.jpg', `numb` = 20, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '简单又详细的教程', `creat_time` = '2020-07-19 18:32:31', `update_time` = '2020-07-20 13:11:56', `type_id` = 1, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:30:17][0m  [36;1m[0.28ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:30:17][0m  [36;1m[0.44ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 1)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:30:17][0m  [36;1m[0.37ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 2)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:30:17][0m  [36;1m[0.37ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 4)  
[36;31m[0 rows affected or returned ][0m 
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:30:17][0m  [36;1m[0.36ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 3)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:30:17][0m  [36;1m[0.32ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 5)  
[36;31m[0 rows affected or returned ][0m 
[{5 1 3 like 狗科 535889315@qq.com /static/images/header.jpg ？？？ 2020-07-20 13:30:17 <nil> []}]
[{5 1 3 like 狗科 535889315@qq.com /static/images/header.jpg ？？？ 2020-07-20 13:30:17 <nil> []}]

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-20 13:30:28][0m  [36;1m[0.44ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 1)  
[36;31m[2 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-20 13:30:28][0m  [36;1m[0.43ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=1  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-20 13:30:28][0m  [36;1m[0.41ms][0m  UPDATE `blogs` SET `title` = 'golang项目简单服务器部署到阿里云(linux)', `content` = '# 我个人比较推荐使用Xftp和Xshell 
# 重要是个人免费用
# 舒服又好用

# 1.下载安装go安装包：
	## （1）go语言下载地址：
	[Go语言中文网](https://studygolang.com/dl "Go语言中文网")
下载linux版本的安装包。

## （2）使用Xftp将安装包上传至指定的路径：

![](https://img-blog.csdnimg.cn/20190719142701389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
	这里上传到root目录下就行
	方便解压
## （3）解压并移到/usr/local/下：

进入指定目录，查看已有文件并且解压文件：

![](https://img-blog.csdnimg.cn/20190719143211340.png)
```
#在root目录输入ls查看目录文件
ls
#在root解压go包
tar -zxvf go的包名
```

解压完成后发现目录下多了一个go文件夹：
![](https://img-blog.csdnimg.cn/20190719143042938.png)
将文件夹移动到/usr/local/
![](https://img-blog.csdnimg.cn/20190719143137645.png)
# 2.配置环境变量：
## （1）进入目的目录查看go文件夹是否移动成功：
![](https://img-blog.csdnimg.cn/20190719143506382.png)
## （2）在usr下创建文件夹，用来存放自己的项目：
workspace
## （3）进入新建的目录workspace新建三个文件夹：
src
pkg
bin
### 说明：

	src 目录存放的是我们的go源代码，不同工程项目的代码以包名区分
	pkg 编译后生成的文件
	bin文件夹存放go install命名生成的可执行文件（这个文件夹会配置到环境变量中）
## （4）配置环境变量：

进入 /etc 修改profile文件：
![](https://img-blog.csdnimg.cn/20190719144319621.png)
```
#进入etc目录
cd /etc/
#配置 profile
vim profile
```
![](https://img-blog.csdnimg.cn/20190719145650864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
在此文件夹下加入上图的代码，代码如下：
```
// 设置go安装路径
export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin
 
// 设置工程目录
export GOPATH=/usr/workspace
export PATH=$PATH:$GOPATH/bin
```

## （5）刷新环境变量：
```
source /etc/profile
```
##  （6）查看go环境是否配置成功：
```
go version
```
## （7）查看详细配置：
```
go env
```
结果如下：  
![](https://img-blog.csdnimg.cn/20190719145255720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70) 
# 3.上传项目代码：
在刚刚创建的workspace下新创建的三个文件夹中，src 目录存放的是我们的go源代码
# 4运行
```go
go build main.go
//或者
go run main.go
```
最后执行 ./main 就行了。
如果想让项目在后台执行：执行 nohup ./main & ，这样就可以程序在后台运行了。

参考教程https://blog.csdn.net/qq_42410605/article/details/96479892', `image` = 'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3111860246,1925938903&fm=26&gp=0.jpg', `numb` = 21, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '简单又详细的教程', `creat_time` = '2020-07-19 18:32:31', `update_time` = '2020-07-20 13:11:56', `type_id` = 1, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:30:28][0m  [36;1m[1.76ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:30:28][0m  [36;1m[0.39ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 1)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:30:28][0m  [36;1m[0.37ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 2)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:30:28][0m  [36;1m[0.30ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 4)  
[36;31m[0 rows affected or returned ][0m 
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:30:28][0m  [36;1m[0.35ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 3)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:30:28][0m  [36;1m[0.34ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 5)  
[36;31m[0 rows affected or returned ][0m 
[{5 1 3 like 狗科 535889315@qq.com /static/images/header.jpg ？？？ 2020-07-20 13:30:17 <nil> []}]
[{5 1 3 like 狗科 535889315@qq.com /static/images/header.jpg ？？？ 2020-07-20 13:30:17 <nil> []}]

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-20 13:30:46][0m  [36;1m[0.44ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 1)  
[36;31m[2 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-20 13:30:46][0m  [36;1m[0.50ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=1  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-20 13:30:46][0m  [36;1m[0.42ms][0m  UPDATE `blogs` SET `title` = 'golang项目简单服务器部署到阿里云(linux)', `content` = '# 我个人比较推荐使用Xftp和Xshell 
# 重要是个人免费用
# 舒服又好用

# 1.下载安装go安装包：
	## （1）go语言下载地址：
	[Go语言中文网](https://studygolang.com/dl "Go语言中文网")
下载linux版本的安装包。

## （2）使用Xftp将安装包上传至指定的路径：

![](https://img-blog.csdnimg.cn/20190719142701389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
	这里上传到root目录下就行
	方便解压
## （3）解压并移到/usr/local/下：

进入指定目录，查看已有文件并且解压文件：

![](https://img-blog.csdnimg.cn/20190719143211340.png)
```
#在root目录输入ls查看目录文件
ls
#在root解压go包
tar -zxvf go的包名
```

解压完成后发现目录下多了一个go文件夹：
![](https://img-blog.csdnimg.cn/20190719143042938.png)
将文件夹移动到/usr/local/
![](https://img-blog.csdnimg.cn/20190719143137645.png)
# 2.配置环境变量：
## （1）进入目的目录查看go文件夹是否移动成功：
![](https://img-blog.csdnimg.cn/20190719143506382.png)
## （2）在usr下创建文件夹，用来存放自己的项目：
workspace
## （3）进入新建的目录workspace新建三个文件夹：
src
pkg
bin
### 说明：

	src 目录存放的是我们的go源代码，不同工程项目的代码以包名区分
	pkg 编译后生成的文件
	bin文件夹存放go install命名生成的可执行文件（这个文件夹会配置到环境变量中）
## （4）配置环境变量：

进入 /etc 修改profile文件：
![](https://img-blog.csdnimg.cn/20190719144319621.png)
```
#进入etc目录
cd /etc/
#配置 profile
vim profile
```
![](https://img-blog.csdnimg.cn/20190719145650864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
在此文件夹下加入上图的代码，代码如下：
```
// 设置go安装路径
export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin
 
// 设置工程目录
export GOPATH=/usr/workspace
export PATH=$PATH:$GOPATH/bin
```

## （5）刷新环境变量：
```
source /etc/profile
```
##  （6）查看go环境是否配置成功：
```
go version
```
## （7）查看详细配置：
```
go env
```
结果如下：  
![](https://img-blog.csdnimg.cn/20190719145255720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70) 
# 3.上传项目代码：
在刚刚创建的workspace下新创建的三个文件夹中，src 目录存放的是我们的go源代码
# 4运行
```go
go build main.go
//或者
go run main.go
```
最后执行 ./main 就行了。
如果想让项目在后台执行：执行 nohup ./main & ，这样就可以程序在后台运行了。

参考教程https://blog.csdn.net/qq_42410605/article/details/96479892', `image` = 'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3111860246,1925938903&fm=26&gp=0.jpg', `numb` = 22, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '简单又详细的教程', `creat_time` = '2020-07-19 18:32:31', `update_time` = '2020-07-20 13:11:56', `type_id` = 1, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:30:46][0m  [36;1m[0.32ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:30:47][0m  [36;1m[0.48ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 1)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:30:47][0m  [36;1m[0.36ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 2)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:30:47][0m  [36;1m[0.35ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 4)  
[36;31m[0 rows affected or returned ][0m 
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:30:47][0m  [36;1m[0.36ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 3)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:30:47][0m  [36;1m[0.32ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 5)  
[36;31m[0 rows affected or returned ][0m 
[{5 1 3 like 狗科 535889315@qq.com /static/images/header.jpg ？？？ 2020-07-20 13:30:17 <nil> []}]
[{5 1 3 like 狗科 535889315@qq.com /static/images/header.jpg ？？？ 2020-07-20 13:30:17 <nil> []}]

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-20 13:31:46][0m  [36;1m[0.41ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 1)  
[36;31m[2 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-20 13:31:46][0m  [36;1m[0.43ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=1  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-20 13:31:46][0m  [36;1m[0.38ms][0m  UPDATE `blogs` SET `title` = 'golang项目简单服务器部署到阿里云(linux)', `content` = '# 我个人比较推荐使用Xftp和Xshell 
# 重要是个人免费用
# 舒服又好用

# 1.下载安装go安装包：
	## （1）go语言下载地址：
	[Go语言中文网](https://studygolang.com/dl "Go语言中文网")
下载linux版本的安装包。

## （2）使用Xftp将安装包上传至指定的路径：

![](https://img-blog.csdnimg.cn/20190719142701389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
	这里上传到root目录下就行
	方便解压
## （3）解压并移到/usr/local/下：

进入指定目录，查看已有文件并且解压文件：

![](https://img-blog.csdnimg.cn/20190719143211340.png)
```
#在root目录输入ls查看目录文件
ls
#在root解压go包
tar -zxvf go的包名
```

解压完成后发现目录下多了一个go文件夹：
![](https://img-blog.csdnimg.cn/20190719143042938.png)
将文件夹移动到/usr/local/
![](https://img-blog.csdnimg.cn/20190719143137645.png)
# 2.配置环境变量：
## （1）进入目的目录查看go文件夹是否移动成功：
![](https://img-blog.csdnimg.cn/20190719143506382.png)
## （2）在usr下创建文件夹，用来存放自己的项目：
workspace
## （3）进入新建的目录workspace新建三个文件夹：
src
pkg
bin
### 说明：

	src 目录存放的是我们的go源代码，不同工程项目的代码以包名区分
	pkg 编译后生成的文件
	bin文件夹存放go install命名生成的可执行文件（这个文件夹会配置到环境变量中）
## （4）配置环境变量：

进入 /etc 修改profile文件：
![](https://img-blog.csdnimg.cn/20190719144319621.png)
```
#进入etc目录
cd /etc/
#配置 profile
vim profile
```
![](https://img-blog.csdnimg.cn/20190719145650864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
在此文件夹下加入上图的代码，代码如下：
```
// 设置go安装路径
export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin
 
// 设置工程目录
export GOPATH=/usr/workspace
export PATH=$PATH:$GOPATH/bin
```

## （5）刷新环境变量：
```
source /etc/profile
```
##  （6）查看go环境是否配置成功：
```
go version
```
## （7）查看详细配置：
```
go env
```
结果如下：  
![](https://img-blog.csdnimg.cn/20190719145255720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70) 
# 3.上传项目代码：
在刚刚创建的workspace下新创建的三个文件夹中，src 目录存放的是我们的go源代码
# 4运行
```go
go build main.go
//或者
go run main.go
```
最后执行 ./main 就行了。
如果想让项目在后台执行：执行 nohup ./main & ，这样就可以程序在后台运行了。

参考教程https://blog.csdn.net/qq_42410605/article/details/96479892', `image` = 'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3111860246,1925938903&fm=26&gp=0.jpg', `numb` = 23, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '简单又详细的教程', `creat_time` = '2020-07-19 18:32:31', `update_time` = '2020-07-20 13:11:56', `type_id` = 1, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:31:46][0m  [36;1m[1.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:31:46][0m  [36;1m[0.44ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 1)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:31:46][0m  [36;1m[0.36ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 2)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:31:46][0m  [36;1m[0.33ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 4)  
[36;31m[0 rows affected or returned ][0m 
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:31:46][0m  [36;1m[0.36ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 3)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:31:46][0m  [36;1m[0.30ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 5)  
[36;31m[0 rows affected or returned ][0m 
[{5 1 3 like 狗科 535889315@qq.com /static/images/header.jpg ？？？ 2020-07-20 13:30:17 <nil> []}]
[{5 1 3 like 狗科 535889315@qq.com /static/images/header.jpg ？？？ 2020-07-20 13:30:17 <nil> []}]

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-20 13:34:33][0m  [36;1m[0.43ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 1)  
[36;31m[2 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-20 13:34:33][0m  [36;1m[0.49ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=1  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-20 13:34:33][0m  [36;1m[0.38ms][0m  UPDATE `blogs` SET `title` = 'golang项目简单服务器部署到阿里云(linux)', `content` = '# 我个人比较推荐使用Xftp和Xshell 
# 重要是个人免费用
# 舒服又好用

# 1.下载安装go安装包：
	## （1）go语言下载地址：
	[Go语言中文网](https://studygolang.com/dl "Go语言中文网")
下载linux版本的安装包。

## （2）使用Xftp将安装包上传至指定的路径：

![](https://img-blog.csdnimg.cn/20190719142701389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
	这里上传到root目录下就行
	方便解压
## （3）解压并移到/usr/local/下：

进入指定目录，查看已有文件并且解压文件：

![](https://img-blog.csdnimg.cn/20190719143211340.png)
```
#在root目录输入ls查看目录文件
ls
#在root解压go包
tar -zxvf go的包名
```

解压完成后发现目录下多了一个go文件夹：
![](https://img-blog.csdnimg.cn/20190719143042938.png)
将文件夹移动到/usr/local/
![](https://img-blog.csdnimg.cn/20190719143137645.png)
# 2.配置环境变量：
## （1）进入目的目录查看go文件夹是否移动成功：
![](https://img-blog.csdnimg.cn/20190719143506382.png)
## （2）在usr下创建文件夹，用来存放自己的项目：
workspace
## （3）进入新建的目录workspace新建三个文件夹：
src
pkg
bin
### 说明：

	src 目录存放的是我们的go源代码，不同工程项目的代码以包名区分
	pkg 编译后生成的文件
	bin文件夹存放go install命名生成的可执行文件（这个文件夹会配置到环境变量中）
## （4）配置环境变量：

进入 /etc 修改profile文件：
![](https://img-blog.csdnimg.cn/20190719144319621.png)
```
#进入etc目录
cd /etc/
#配置 profile
vim profile
```
![](https://img-blog.csdnimg.cn/20190719145650864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
在此文件夹下加入上图的代码，代码如下：
```
// 设置go安装路径
export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin
 
// 设置工程目录
export GOPATH=/usr/workspace
export PATH=$PATH:$GOPATH/bin
```

## （5）刷新环境变量：
```
source /etc/profile
```
##  （6）查看go环境是否配置成功：
```
go version
```
## （7）查看详细配置：
```
go env
```
结果如下：  
![](https://img-blog.csdnimg.cn/20190719145255720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70) 
# 3.上传项目代码：
在刚刚创建的workspace下新创建的三个文件夹中，src 目录存放的是我们的go源代码
# 4运行
```go
go build main.go
//或者
go run main.go
```
最后执行 ./main 就行了。
如果想让项目在后台执行：执行 nohup ./main & ，这样就可以程序在后台运行了。

参考教程https://blog.csdn.net/qq_42410605/article/details/96479892', `image` = 'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3111860246,1925938903&fm=26&gp=0.jpg', `numb` = 24, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '简单又详细的教程', `creat_time` = '2020-07-19 18:32:31', `update_time` = '2020-07-20 13:11:56', `type_id` = 1, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:34:33][0m  [36;1m[0.25ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:34:33][0m  [36;1m[0.38ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 1)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:34:33][0m  [36;1m[0.34ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 2)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:34:33][0m  [36;1m[0.29ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 4)  
[36;31m[0 rows affected or returned ][0m 
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:34:33][0m  [36;1m[0.33ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 3)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:34:33][0m  [36;1m[0.31ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 5)  
[36;31m[0 rows affected or returned ][0m 
[{5 1 3 like 狗科 535889315@qq.com /static/images/header.jpg ？？？ 2020-07-20 13:30:17 <nil> []}]
[{5 1 3 like 狗科 535889315@qq.com /static/images/header.jpg ？？？ 2020-07-20 13:30:17 <nil> []}]

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-20 13:34:37][0m  [36;1m[0.41ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 1)  
[36;31m[2 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-20 13:34:37][0m  [36;1m[0.44ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=1  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-20 13:34:37][0m  [36;1m[0.39ms][0m  UPDATE `blogs` SET `title` = 'golang项目简单服务器部署到阿里云(linux)', `content` = '# 我个人比较推荐使用Xftp和Xshell 
# 重要是个人免费用
# 舒服又好用

# 1.下载安装go安装包：
	## （1）go语言下载地址：
	[Go语言中文网](https://studygolang.com/dl "Go语言中文网")
下载linux版本的安装包。

## （2）使用Xftp将安装包上传至指定的路径：

![](https://img-blog.csdnimg.cn/20190719142701389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
	这里上传到root目录下就行
	方便解压
## （3）解压并移到/usr/local/下：

进入指定目录，查看已有文件并且解压文件：

![](https://img-blog.csdnimg.cn/20190719143211340.png)
```
#在root目录输入ls查看目录文件
ls
#在root解压go包
tar -zxvf go的包名
```

解压完成后发现目录下多了一个go文件夹：
![](https://img-blog.csdnimg.cn/20190719143042938.png)
将文件夹移动到/usr/local/
![](https://img-blog.csdnimg.cn/20190719143137645.png)
# 2.配置环境变量：
## （1）进入目的目录查看go文件夹是否移动成功：
![](https://img-blog.csdnimg.cn/20190719143506382.png)
## （2）在usr下创建文件夹，用来存放自己的项目：
workspace
## （3）进入新建的目录workspace新建三个文件夹：
src
pkg
bin
### 说明：

	src 目录存放的是我们的go源代码，不同工程项目的代码以包名区分
	pkg 编译后生成的文件
	bin文件夹存放go install命名生成的可执行文件（这个文件夹会配置到环境变量中）
## （4）配置环境变量：

进入 /etc 修改profile文件：
![](https://img-blog.csdnimg.cn/20190719144319621.png)
```
#进入etc目录
cd /etc/
#配置 profile
vim profile
```
![](https://img-blog.csdnimg.cn/20190719145650864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
在此文件夹下加入上图的代码，代码如下：
```
// 设置go安装路径
export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin
 
// 设置工程目录
export GOPATH=/usr/workspace
export PATH=$PATH:$GOPATH/bin
```

## （5）刷新环境变量：
```
source /etc/profile
```
##  （6）查看go环境是否配置成功：
```
go version
```
## （7）查看详细配置：
```
go env
```
结果如下：  
![](https://img-blog.csdnimg.cn/20190719145255720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70) 
# 3.上传项目代码：
在刚刚创建的workspace下新创建的三个文件夹中，src 目录存放的是我们的go源代码
# 4运行
```go
go build main.go
//或者
go run main.go
```
最后执行 ./main 就行了。
如果想让项目在后台执行：执行 nohup ./main & ，这样就可以程序在后台运行了。

参考教程https://blog.csdn.net/qq_42410605/article/details/96479892', `image` = 'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3111860246,1925938903&fm=26&gp=0.jpg', `numb` = 25, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '简单又详细的教程', `creat_time` = '2020-07-19 18:32:31', `update_time` = '2020-07-20 13:11:56', `type_id` = 1, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:34:37][0m  [36;1m[0.26ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:34:37][0m  [36;1m[0.39ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 1)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:34:37][0m  [36;1m[2.57ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 2)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:34:37][0m  [36;1m[0.30ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 4)  
[36;31m[0 rows affected or returned ][0m 
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:34:37][0m  [36;1m[0.34ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 3)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:34:37][0m  [36;1m[0.30ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 5)  
[36;31m[0 rows affected or returned ][0m 
[{5 1 3 like 狗科 535889315@qq.com /static/images/header.jpg ？？？ 2020-07-20 13:30:17 <nil> []}]
[{5 1 3 like 狗科 535889315@qq.com /static/images/header.jpg ？？？ 2020-07-20 13:30:17 <nil> []}]

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-20 13:34:42][0m  [36;1m[0.48ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 1)  
[36;31m[2 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-20 13:34:42][0m  [36;1m[0.54ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=1  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-20 13:34:42][0m  [36;1m[0.56ms][0m  UPDATE `blogs` SET `title` = 'golang项目简单服务器部署到阿里云(linux)', `content` = '# 我个人比较推荐使用Xftp和Xshell 
# 重要是个人免费用
# 舒服又好用

# 1.下载安装go安装包：
	## （1）go语言下载地址：
	[Go语言中文网](https://studygolang.com/dl "Go语言中文网")
下载linux版本的安装包。

## （2）使用Xftp将安装包上传至指定的路径：

![](https://img-blog.csdnimg.cn/20190719142701389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
	这里上传到root目录下就行
	方便解压
## （3）解压并移到/usr/local/下：

进入指定目录，查看已有文件并且解压文件：

![](https://img-blog.csdnimg.cn/20190719143211340.png)
```
#在root目录输入ls查看目录文件
ls
#在root解压go包
tar -zxvf go的包名
```

解压完成后发现目录下多了一个go文件夹：
![](https://img-blog.csdnimg.cn/20190719143042938.png)
将文件夹移动到/usr/local/
![](https://img-blog.csdnimg.cn/20190719143137645.png)
# 2.配置环境变量：
## （1）进入目的目录查看go文件夹是否移动成功：
![](https://img-blog.csdnimg.cn/20190719143506382.png)
## （2）在usr下创建文件夹，用来存放自己的项目：
workspace
## （3）进入新建的目录workspace新建三个文件夹：
src
pkg
bin
### 说明：

	src 目录存放的是我们的go源代码，不同工程项目的代码以包名区分
	pkg 编译后生成的文件
	bin文件夹存放go install命名生成的可执行文件（这个文件夹会配置到环境变量中）
## （4）配置环境变量：

进入 /etc 修改profile文件：
![](https://img-blog.csdnimg.cn/20190719144319621.png)
```
#进入etc目录
cd /etc/
#配置 profile
vim profile
```
![](https://img-blog.csdnimg.cn/20190719145650864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
在此文件夹下加入上图的代码，代码如下：
```
// 设置go安装路径
export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin
 
// 设置工程目录
export GOPATH=/usr/workspace
export PATH=$PATH:$GOPATH/bin
```

## （5）刷新环境变量：
```
source /etc/profile
```
##  （6）查看go环境是否配置成功：
```
go version
```
## （7）查看详细配置：
```
go env
```
结果如下：  
![](https://img-blog.csdnimg.cn/20190719145255720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70) 
# 3.上传项目代码：
在刚刚创建的workspace下新创建的三个文件夹中，src 目录存放的是我们的go源代码
# 4运行
```go
go build main.go
//或者
go run main.go
```
最后执行 ./main 就行了。
如果想让项目在后台执行：执行 nohup ./main & ，这样就可以程序在后台运行了。

参考教程https://blog.csdn.net/qq_42410605/article/details/96479892', `image` = 'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3111860246,1925938903&fm=26&gp=0.jpg', `numb` = 26, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '简单又详细的教程', `creat_time` = '2020-07-19 18:32:31', `update_time` = '2020-07-20 13:11:56', `type_id` = 1, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:34:42][0m  [36;1m[0.34ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:34:42][0m  [36;1m[0.47ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 1)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:34:42][0m  [36;1m[0.46ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 2)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:34:42][0m  [36;1m[0.36ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 4)  
[36;31m[0 rows affected or returned ][0m 
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:34:42][0m  [36;1m[0.44ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 3)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:34:42][0m  [36;1m[0.36ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 5)  
[36;31m[0 rows affected or returned ][0m 
[{5 1 3 like 狗科 535889315@qq.com /static/images/header.jpg ？？？ 2020-07-20 13:30:17 <nil> []}]
[{5 1 3 like 狗科 535889315@qq.com /static/images/header.jpg ？？？ 2020-07-20 13:30:17 <nil> []}]

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-20 13:34:52][0m  [36;1m[0.44ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 1)  
[36;31m[2 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-20 13:34:52][0m  [36;1m[0.47ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=1  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-20 13:34:52][0m  [36;1m[0.40ms][0m  UPDATE `blogs` SET `title` = 'golang项目简单服务器部署到阿里云(linux)', `content` = '# 我个人比较推荐使用Xftp和Xshell 
# 重要是个人免费用
# 舒服又好用

# 1.下载安装go安装包：
	## （1）go语言下载地址：
	[Go语言中文网](https://studygolang.com/dl "Go语言中文网")
下载linux版本的安装包。

## （2）使用Xftp将安装包上传至指定的路径：

![](https://img-blog.csdnimg.cn/20190719142701389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
	这里上传到root目录下就行
	方便解压
## （3）解压并移到/usr/local/下：

进入指定目录，查看已有文件并且解压文件：

![](https://img-blog.csdnimg.cn/20190719143211340.png)
```
#在root目录输入ls查看目录文件
ls
#在root解压go包
tar -zxvf go的包名
```

解压完成后发现目录下多了一个go文件夹：
![](https://img-blog.csdnimg.cn/20190719143042938.png)
将文件夹移动到/usr/local/
![](https://img-blog.csdnimg.cn/20190719143137645.png)
# 2.配置环境变量：
## （1）进入目的目录查看go文件夹是否移动成功：
![](https://img-blog.csdnimg.cn/20190719143506382.png)
## （2）在usr下创建文件夹，用来存放自己的项目：
workspace
## （3）进入新建的目录workspace新建三个文件夹：
src
pkg
bin
### 说明：

	src 目录存放的是我们的go源代码，不同工程项目的代码以包名区分
	pkg 编译后生成的文件
	bin文件夹存放go install命名生成的可执行文件（这个文件夹会配置到环境变量中）
## （4）配置环境变量：

进入 /etc 修改profile文件：
![](https://img-blog.csdnimg.cn/20190719144319621.png)
```
#进入etc目录
cd /etc/
#配置 profile
vim profile
```
![](https://img-blog.csdnimg.cn/20190719145650864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
在此文件夹下加入上图的代码，代码如下：
```
// 设置go安装路径
export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin
 
// 设置工程目录
export GOPATH=/usr/workspace
export PATH=$PATH:$GOPATH/bin
```

## （5）刷新环境变量：
```
source /etc/profile
```
##  （6）查看go环境是否配置成功：
```
go version
```
## （7）查看详细配置：
```
go env
```
结果如下：  
![](https://img-blog.csdnimg.cn/20190719145255720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70) 
# 3.上传项目代码：
在刚刚创建的workspace下新创建的三个文件夹中，src 目录存放的是我们的go源代码
# 4运行
```go
go build main.go
//或者
go run main.go
```
最后执行 ./main 就行了。
如果想让项目在后台执行：执行 nohup ./main & ，这样就可以程序在后台运行了。

参考教程https://blog.csdn.net/qq_42410605/article/details/96479892', `image` = 'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3111860246,1925938903&fm=26&gp=0.jpg', `numb` = 27, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '简单又详细的教程', `creat_time` = '2020-07-19 18:32:31', `update_time` = '2020-07-20 13:11:56', `type_id` = 1, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:34:52][0m  [36;1m[0.29ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:34:52][0m  [36;1m[0.47ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 1)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:34:52][0m  [36;1m[0.34ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 2)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:34:52][0m  [36;1m[0.37ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 4)  
[36;31m[0 rows affected or returned ][0m 
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:34:52][0m  [36;1m[0.35ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 3)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:34:52][0m  [36;1m[0.28ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 5)  
[36;31m[0 rows affected or returned ][0m 
[{5 1 3 like 狗科 535889315@qq.com /static/images/header.jpg ？？？ 2020-07-20 13:30:17 <nil> []}]
[{5 1 3 like 狗科 535889315@qq.com /static/images/header.jpg ？？？ 2020-07-20 13:30:17 <nil> []}]

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-20 13:35:04][0m  [36;1m[0.42ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 1)  
[36;31m[2 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-20 13:35:04][0m  [36;1m[0.46ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=1  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-20 13:35:04][0m  [36;1m[0.41ms][0m  UPDATE `blogs` SET `title` = 'golang项目简单服务器部署到阿里云(linux)', `content` = '# 我个人比较推荐使用Xftp和Xshell 
# 重要是个人免费用
# 舒服又好用

# 1.下载安装go安装包：
	## （1）go语言下载地址：
	[Go语言中文网](https://studygolang.com/dl "Go语言中文网")
下载linux版本的安装包。

## （2）使用Xftp将安装包上传至指定的路径：

![](https://img-blog.csdnimg.cn/20190719142701389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
	这里上传到root目录下就行
	方便解压
## （3）解压并移到/usr/local/下：

进入指定目录，查看已有文件并且解压文件：

![](https://img-blog.csdnimg.cn/20190719143211340.png)
```
#在root目录输入ls查看目录文件
ls
#在root解压go包
tar -zxvf go的包名
```

解压完成后发现目录下多了一个go文件夹：
![](https://img-blog.csdnimg.cn/20190719143042938.png)
将文件夹移动到/usr/local/
![](https://img-blog.csdnimg.cn/20190719143137645.png)
# 2.配置环境变量：
## （1）进入目的目录查看go文件夹是否移动成功：
![](https://img-blog.csdnimg.cn/20190719143506382.png)
## （2）在usr下创建文件夹，用来存放自己的项目：
workspace
## （3）进入新建的目录workspace新建三个文件夹：
src
pkg
bin
### 说明：

	src 目录存放的是我们的go源代码，不同工程项目的代码以包名区分
	pkg 编译后生成的文件
	bin文件夹存放go install命名生成的可执行文件（这个文件夹会配置到环境变量中）
## （4）配置环境变量：

进入 /etc 修改profile文件：
![](https://img-blog.csdnimg.cn/20190719144319621.png)
```
#进入etc目录
cd /etc/
#配置 profile
vim profile
```
![](https://img-blog.csdnimg.cn/20190719145650864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
在此文件夹下加入上图的代码，代码如下：
```
// 设置go安装路径
export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin
 
// 设置工程目录
export GOPATH=/usr/workspace
export PATH=$PATH:$GOPATH/bin
```

## （5）刷新环境变量：
```
source /etc/profile
```
##  （6）查看go环境是否配置成功：
```
go version
```
## （7）查看详细配置：
```
go env
```
结果如下：  
![](https://img-blog.csdnimg.cn/20190719145255720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70) 
# 3.上传项目代码：
在刚刚创建的workspace下新创建的三个文件夹中，src 目录存放的是我们的go源代码
# 4运行
```go
go build main.go
//或者
go run main.go
```
最后执行 ./main 就行了。
如果想让项目在后台执行：执行 nohup ./main & ，这样就可以程序在后台运行了。

参考教程https://blog.csdn.net/qq_42410605/article/details/96479892', `image` = 'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3111860246,1925938903&fm=26&gp=0.jpg', `numb` = 28, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '简单又详细的教程', `creat_time` = '2020-07-19 18:32:31', `update_time` = '2020-07-20 13:11:56', `type_id` = 1, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:35:04][0m  [36;1m[0.32ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:35:04][0m  [36;1m[0.50ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 1)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:35:04][0m  [36;1m[0.37ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 2)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:35:04][0m  [36;1m[0.33ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 4)  
[36;31m[0 rows affected or returned ][0m 
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:35:04][0m  [36;1m[0.42ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 3)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:35:04][0m  [36;1m[0.33ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 5)  
[36;31m[0 rows affected or returned ][0m 
[{5 1 3 like 狗科 535889315@qq.com /static/images/header.jpg ？？？ 2020-07-20 13:30:17 <nil> []}]
[{5 1 3 like 狗科 535889315@qq.com /static/images/header.jpg ？？？ 2020-07-20 13:30:17 <nil> []}]

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-20 13:35:06][0m  [36;1m[0.41ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 1)  
[36;31m[2 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-20 13:35:06][0m  [36;1m[0.45ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=1  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-20 13:35:06][0m  [36;1m[0.41ms][0m  UPDATE `blogs` SET `title` = 'golang项目简单服务器部署到阿里云(linux)', `content` = '# 我个人比较推荐使用Xftp和Xshell 
# 重要是个人免费用
# 舒服又好用

# 1.下载安装go安装包：
	## （1）go语言下载地址：
	[Go语言中文网](https://studygolang.com/dl "Go语言中文网")
下载linux版本的安装包。

## （2）使用Xftp将安装包上传至指定的路径：

![](https://img-blog.csdnimg.cn/20190719142701389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
	这里上传到root目录下就行
	方便解压
## （3）解压并移到/usr/local/下：

进入指定目录，查看已有文件并且解压文件：

![](https://img-blog.csdnimg.cn/20190719143211340.png)
```
#在root目录输入ls查看目录文件
ls
#在root解压go包
tar -zxvf go的包名
```

解压完成后发现目录下多了一个go文件夹：
![](https://img-blog.csdnimg.cn/20190719143042938.png)
将文件夹移动到/usr/local/
![](https://img-blog.csdnimg.cn/20190719143137645.png)
# 2.配置环境变量：
## （1）进入目的目录查看go文件夹是否移动成功：
![](https://img-blog.csdnimg.cn/20190719143506382.png)
## （2）在usr下创建文件夹，用来存放自己的项目：
workspace
## （3）进入新建的目录workspace新建三个文件夹：
src
pkg
bin
### 说明：

	src 目录存放的是我们的go源代码，不同工程项目的代码以包名区分
	pkg 编译后生成的文件
	bin文件夹存放go install命名生成的可执行文件（这个文件夹会配置到环境变量中）
## （4）配置环境变量：

进入 /etc 修改profile文件：
![](https://img-blog.csdnimg.cn/20190719144319621.png)
```
#进入etc目录
cd /etc/
#配置 profile
vim profile
```
![](https://img-blog.csdnimg.cn/20190719145650864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
在此文件夹下加入上图的代码，代码如下：
```
// 设置go安装路径
export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin
 
// 设置工程目录
export GOPATH=/usr/workspace
export PATH=$PATH:$GOPATH/bin
```

## （5）刷新环境变量：
```
source /etc/profile
```
##  （6）查看go环境是否配置成功：
```
go version
```
## （7）查看详细配置：
```
go env
```
结果如下：  
![](https://img-blog.csdnimg.cn/20190719145255720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70) 
# 3.上传项目代码：
在刚刚创建的workspace下新创建的三个文件夹中，src 目录存放的是我们的go源代码
# 4运行
```go
go build main.go
//或者
go run main.go
```
最后执行 ./main 就行了。
如果想让项目在后台执行：执行 nohup ./main & ，这样就可以程序在后台运行了。

参考教程https://blog.csdn.net/qq_42410605/article/details/96479892', `image` = 'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3111860246,1925938903&fm=26&gp=0.jpg', `numb` = 29, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '简单又详细的教程', `creat_time` = '2020-07-19 18:32:31', `update_time` = '2020-07-20 13:11:56', `type_id` = 1, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:35:06][0m  [36;1m[0.26ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:35:06][0m  [36;1m[0.38ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 1)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:35:06][0m  [36;1m[0.40ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 2)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:35:06][0m  [36;1m[0.29ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 4)  
[36;31m[0 rows affected or returned ][0m 
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:35:06][0m  [36;1m[0.33ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 3)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:35:06][0m  [36;1m[0.29ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 5)  
[36;31m[0 rows affected or returned ][0m 
[{5 1 3 like 狗科 535889315@qq.com /static/images/header.jpg ？？？ 2020-07-20 13:30:17 <nil> []}]
[{5 1 3 like 狗科 535889315@qq.com /static/images/header.jpg ？？？ 2020-07-20 13:30:17 <nil> []}]

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-20 13:35:14][0m  [36;1m[0.46ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 1)  
[36;31m[2 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-20 13:35:14][0m  [36;1m[0.47ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=1  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-20 13:35:14][0m  [36;1m[0.62ms][0m  UPDATE `blogs` SET `title` = 'golang项目简单服务器部署到阿里云(linux)', `content` = '# 我个人比较推荐使用Xftp和Xshell 
# 重要是个人免费用
# 舒服又好用

# 1.下载安装go安装包：
	## （1）go语言下载地址：
	[Go语言中文网](https://studygolang.com/dl "Go语言中文网")
下载linux版本的安装包。

## （2）使用Xftp将安装包上传至指定的路径：

![](https://img-blog.csdnimg.cn/20190719142701389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
	这里上传到root目录下就行
	方便解压
## （3）解压并移到/usr/local/下：

进入指定目录，查看已有文件并且解压文件：

![](https://img-blog.csdnimg.cn/20190719143211340.png)
```
#在root目录输入ls查看目录文件
ls
#在root解压go包
tar -zxvf go的包名
```

解压完成后发现目录下多了一个go文件夹：
![](https://img-blog.csdnimg.cn/20190719143042938.png)
将文件夹移动到/usr/local/
![](https://img-blog.csdnimg.cn/20190719143137645.png)
# 2.配置环境变量：
## （1）进入目的目录查看go文件夹是否移动成功：
![](https://img-blog.csdnimg.cn/20190719143506382.png)
## （2）在usr下创建文件夹，用来存放自己的项目：
workspace
## （3）进入新建的目录workspace新建三个文件夹：
src
pkg
bin
### 说明：

	src 目录存放的是我们的go源代码，不同工程项目的代码以包名区分
	pkg 编译后生成的文件
	bin文件夹存放go install命名生成的可执行文件（这个文件夹会配置到环境变量中）
## （4）配置环境变量：

进入 /etc 修改profile文件：
![](https://img-blog.csdnimg.cn/20190719144319621.png)
```
#进入etc目录
cd /etc/
#配置 profile
vim profile
```
![](https://img-blog.csdnimg.cn/20190719145650864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
在此文件夹下加入上图的代码，代码如下：
```
// 设置go安装路径
export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin
 
// 设置工程目录
export GOPATH=/usr/workspace
export PATH=$PATH:$GOPATH/bin
```

## （5）刷新环境变量：
```
source /etc/profile
```
##  （6）查看go环境是否配置成功：
```
go version
```
## （7）查看详细配置：
```
go env
```
结果如下：  
![](https://img-blog.csdnimg.cn/20190719145255720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70) 
# 3.上传项目代码：
在刚刚创建的workspace下新创建的三个文件夹中，src 目录存放的是我们的go源代码
# 4运行
```go
go build main.go
//或者
go run main.go
```
最后执行 ./main 就行了。
如果想让项目在后台执行：执行 nohup ./main & ，这样就可以程序在后台运行了。

参考教程https://blog.csdn.net/qq_42410605/article/details/96479892', `image` = 'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3111860246,1925938903&fm=26&gp=0.jpg', `numb` = 30, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '简单又详细的教程', `creat_time` = '2020-07-19 18:32:31', `update_time` = '2020-07-20 13:11:56', `type_id` = 1, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:35:14][0m  [36;1m[1.83ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:35:14][0m  [36;1m[0.50ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 1)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:35:14][0m  [36;1m[0.40ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 2)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:35:14][0m  [36;1m[0.33ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 4)  
[36;31m[0 rows affected or returned ][0m 
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:35:14][0m  [36;1m[0.35ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 3)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:35:14][0m  [36;1m[0.29ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 5)  
[36;31m[0 rows affected or returned ][0m 
[{5 1 3 like 狗科 535889315@qq.com /static/images/header.jpg ？？？ 2020-07-20 13:30:17 <nil> []}]
[{5 1 3 like 狗科 535889315@qq.com /static/images/header.jpg ？？？ 2020-07-20 13:30:17 <nil> []}]

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-20 13:37:02][0m  [36;1m[0.43ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 1)  
[36;31m[2 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-20 13:37:02][0m  [36;1m[0.46ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=1  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-20 13:37:02][0m  [36;1m[0.40ms][0m  UPDATE `blogs` SET `title` = 'golang项目简单服务器部署到阿里云(linux)', `content` = '# 我个人比较推荐使用Xftp和Xshell 
# 重要是个人免费用
# 舒服又好用

# 1.下载安装go安装包：
	## （1）go语言下载地址：
	[Go语言中文网](https://studygolang.com/dl "Go语言中文网")
下载linux版本的安装包。

## （2）使用Xftp将安装包上传至指定的路径：

![](https://img-blog.csdnimg.cn/20190719142701389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
	这里上传到root目录下就行
	方便解压
## （3）解压并移到/usr/local/下：

进入指定目录，查看已有文件并且解压文件：

![](https://img-blog.csdnimg.cn/20190719143211340.png)
```
#在root目录输入ls查看目录文件
ls
#在root解压go包
tar -zxvf go的包名
```

解压完成后发现目录下多了一个go文件夹：
![](https://img-blog.csdnimg.cn/20190719143042938.png)
将文件夹移动到/usr/local/
![](https://img-blog.csdnimg.cn/20190719143137645.png)
# 2.配置环境变量：
## （1）进入目的目录查看go文件夹是否移动成功：
![](https://img-blog.csdnimg.cn/20190719143506382.png)
## （2）在usr下创建文件夹，用来存放自己的项目：
workspace
## （3）进入新建的目录workspace新建三个文件夹：
src
pkg
bin
### 说明：

	src 目录存放的是我们的go源代码，不同工程项目的代码以包名区分
	pkg 编译后生成的文件
	bin文件夹存放go install命名生成的可执行文件（这个文件夹会配置到环境变量中）
## （4）配置环境变量：

进入 /etc 修改profile文件：
![](https://img-blog.csdnimg.cn/20190719144319621.png)
```
#进入etc目录
cd /etc/
#配置 profile
vim profile
```
![](https://img-blog.csdnimg.cn/20190719145650864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
在此文件夹下加入上图的代码，代码如下：
```
// 设置go安装路径
export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin
 
// 设置工程目录
export GOPATH=/usr/workspace
export PATH=$PATH:$GOPATH/bin
```

## （5）刷新环境变量：
```
source /etc/profile
```
##  （6）查看go环境是否配置成功：
```
go version
```
## （7）查看详细配置：
```
go env
```
结果如下：  
![](https://img-blog.csdnimg.cn/20190719145255720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70) 
# 3.上传项目代码：
在刚刚创建的workspace下新创建的三个文件夹中，src 目录存放的是我们的go源代码
# 4运行
```go
go build main.go
//或者
go run main.go
```
最后执行 ./main 就行了。
如果想让项目在后台执行：执行 nohup ./main & ，这样就可以程序在后台运行了。

参考教程https://blog.csdn.net/qq_42410605/article/details/96479892', `image` = 'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3111860246,1925938903&fm=26&gp=0.jpg', `numb` = 31, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '简单又详细的教程', `creat_time` = '2020-07-19 18:32:31', `update_time` = '2020-07-20 13:11:56', `type_id` = 1, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:37:02][0m  [36;1m[0.27ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:37:02][0m  [36;1m[0.38ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 1)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:37:02][0m  [36;1m[0.34ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 2)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:37:02][0m  [36;1m[0.31ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 4)  
[36;31m[0 rows affected or returned ][0m 
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:37:02][0m  [36;1m[0.34ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 3)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:37:02][0m  [36;1m[0.30ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 5)  
[36;31m[0 rows affected or returned ][0m 
[{5 1 3 like 狗科 535889315@qq.com /static/images/header.jpg ？？？ 2020-07-20 13:30:17 <nil> []}]
[{5 1 3 like 狗科 535889315@qq.com /static/images/header.jpg ？？？ 2020-07-20 13:30:17 <nil> []}]

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-20 13:37:18][0m  [36;1m[0.44ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 1)  
[36;31m[2 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-20 13:37:18][0m  [36;1m[0.62ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=1  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-20 13:37:18][0m  [36;1m[0.48ms][0m  UPDATE `blogs` SET `title` = 'golang项目简单服务器部署到阿里云(linux)', `content` = '# 我个人比较推荐使用Xftp和Xshell 
# 重要是个人免费用
# 舒服又好用

# 1.下载安装go安装包：
	## （1）go语言下载地址：
	[Go语言中文网](https://studygolang.com/dl "Go语言中文网")
下载linux版本的安装包。

## （2）使用Xftp将安装包上传至指定的路径：

![](https://img-blog.csdnimg.cn/20190719142701389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
	这里上传到root目录下就行
	方便解压
## （3）解压并移到/usr/local/下：

进入指定目录，查看已有文件并且解压文件：

![](https://img-blog.csdnimg.cn/20190719143211340.png)
```
#在root目录输入ls查看目录文件
ls
#在root解压go包
tar -zxvf go的包名
```

解压完成后发现目录下多了一个go文件夹：
![](https://img-blog.csdnimg.cn/20190719143042938.png)
将文件夹移动到/usr/local/
![](https://img-blog.csdnimg.cn/20190719143137645.png)
# 2.配置环境变量：
## （1）进入目的目录查看go文件夹是否移动成功：
![](https://img-blog.csdnimg.cn/20190719143506382.png)
## （2）在usr下创建文件夹，用来存放自己的项目：
workspace
## （3）进入新建的目录workspace新建三个文件夹：
src
pkg
bin
### 说明：

	src 目录存放的是我们的go源代码，不同工程项目的代码以包名区分
	pkg 编译后生成的文件
	bin文件夹存放go install命名生成的可执行文件（这个文件夹会配置到环境变量中）
## （4）配置环境变量：

进入 /etc 修改profile文件：
![](https://img-blog.csdnimg.cn/20190719144319621.png)
```
#进入etc目录
cd /etc/
#配置 profile
vim profile
```
![](https://img-blog.csdnimg.cn/20190719145650864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
在此文件夹下加入上图的代码，代码如下：
```
// 设置go安装路径
export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin
 
// 设置工程目录
export GOPATH=/usr/workspace
export PATH=$PATH:$GOPATH/bin
```

## （5）刷新环境变量：
```
source /etc/profile
```
##  （6）查看go环境是否配置成功：
```
go version
```
## （7）查看详细配置：
```
go env
```
结果如下：  
![](https://img-blog.csdnimg.cn/20190719145255720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70) 
# 3.上传项目代码：
在刚刚创建的workspace下新创建的三个文件夹中，src 目录存放的是我们的go源代码
# 4运行
```go
go build main.go
//或者
go run main.go
```
最后执行 ./main 就行了。
如果想让项目在后台执行：执行 nohup ./main & ，这样就可以程序在后台运行了。

参考教程https://blog.csdn.net/qq_42410605/article/details/96479892', `image` = 'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3111860246,1925938903&fm=26&gp=0.jpg', `numb` = 32, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '简单又详细的教程', `creat_time` = '2020-07-19 18:32:31', `update_time` = '2020-07-20 13:11:56', `type_id` = 1, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:37:18][0m  [36;1m[0.28ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:37:18][0m  [36;1m[0.46ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 1)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:37:18][0m  [36;1m[0.35ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 2)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:37:18][0m  [36;1m[0.37ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 4)  
[36;31m[0 rows affected or returned ][0m 
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:37:18][0m  [36;1m[0.39ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 3)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:37:18][0m  [36;1m[0.38ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 5)  
[36;31m[0 rows affected or returned ][0m 
[{5 1 3 like 狗科 535889315@qq.com /static/images/header.jpg ？？？ 2020-07-20 13:30:17 <nil> []}]
[{5 1 3 like 狗科 535889315@qq.com /static/images/header.jpg ？？？ 2020-07-20 13:30:17 <nil> []}]

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-20 13:37:56][0m  [36;1m[0.44ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 1)  
[36;31m[2 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-20 13:37:56][0m  [36;1m[0.48ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=1  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-20 13:37:56][0m  [36;1m[0.40ms][0m  UPDATE `blogs` SET `title` = 'golang项目简单服务器部署到阿里云(linux)', `content` = '# 我个人比较推荐使用Xftp和Xshell 
# 重要是个人免费用
# 舒服又好用

# 1.下载安装go安装包：
	## （1）go语言下载地址：
	[Go语言中文网](https://studygolang.com/dl "Go语言中文网")
下载linux版本的安装包。

## （2）使用Xftp将安装包上传至指定的路径：

![](https://img-blog.csdnimg.cn/20190719142701389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
	这里上传到root目录下就行
	方便解压
## （3）解压并移到/usr/local/下：

进入指定目录，查看已有文件并且解压文件：

![](https://img-blog.csdnimg.cn/20190719143211340.png)
```
#在root目录输入ls查看目录文件
ls
#在root解压go包
tar -zxvf go的包名
```

解压完成后发现目录下多了一个go文件夹：
![](https://img-blog.csdnimg.cn/20190719143042938.png)
将文件夹移动到/usr/local/
![](https://img-blog.csdnimg.cn/20190719143137645.png)
# 2.配置环境变量：
## （1）进入目的目录查看go文件夹是否移动成功：
![](https://img-blog.csdnimg.cn/20190719143506382.png)
## （2）在usr下创建文件夹，用来存放自己的项目：
workspace
## （3）进入新建的目录workspace新建三个文件夹：
src
pkg
bin
### 说明：

	src 目录存放的是我们的go源代码，不同工程项目的代码以包名区分
	pkg 编译后生成的文件
	bin文件夹存放go install命名生成的可执行文件（这个文件夹会配置到环境变量中）
## （4）配置环境变量：

进入 /etc 修改profile文件：
![](https://img-blog.csdnimg.cn/20190719144319621.png)
```
#进入etc目录
cd /etc/
#配置 profile
vim profile
```
![](https://img-blog.csdnimg.cn/20190719145650864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
在此文件夹下加入上图的代码，代码如下：
```
// 设置go安装路径
export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin
 
// 设置工程目录
export GOPATH=/usr/workspace
export PATH=$PATH:$GOPATH/bin
```

## （5）刷新环境变量：
```
source /etc/profile
```
##  （6）查看go环境是否配置成功：
```
go version
```
## （7）查看详细配置：
```
go env
```
结果如下：  
![](https://img-blog.csdnimg.cn/20190719145255720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70) 
# 3.上传项目代码：
在刚刚创建的workspace下新创建的三个文件夹中，src 目录存放的是我们的go源代码
# 4运行
```go
go build main.go
//或者
go run main.go
```
最后执行 ./main 就行了。
如果想让项目在后台执行：执行 nohup ./main & ，这样就可以程序在后台运行了。

参考教程https://blog.csdn.net/qq_42410605/article/details/96479892', `image` = 'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3111860246,1925938903&fm=26&gp=0.jpg', `numb` = 33, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '简单又详细的教程', `creat_time` = '2020-07-19 18:32:31', `update_time` = '2020-07-20 13:11:56', `type_id` = 1, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:37:56][0m  [36;1m[0.31ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:37:56][0m  [36;1m[0.45ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 1)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:37:56][0m  [36;1m[0.39ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 2)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:37:56][0m  [36;1m[0.33ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 4)  
[36;31m[0 rows affected or returned ][0m 
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:37:56][0m  [36;1m[0.44ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 3)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:37:56][0m  [36;1m[0.35ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 5)  
[36;31m[0 rows affected or returned ][0m 
[{5 1 3 like 狗科 535889315@qq.com /static/images/header.jpg ？？？ 2020-07-20 13:30:17 <nil> []}]
[{5 1 3 like 狗科 535889315@qq.com /static/images/header.jpg ？？？ 2020-07-20 13:30:17 <nil> []}]

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-20 13:41:08][0m  [36;1m[0.48ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 1)  
[36;31m[2 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-20 13:41:08][0m  [36;1m[0.43ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=1  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-20 13:41:08][0m  [36;1m[0.38ms][0m  UPDATE `blogs` SET `title` = 'golang项目简单服务器部署到阿里云(linux)', `content` = '# 我个人比较推荐使用Xftp和Xshell 
# 重要是个人免费用
# 舒服又好用

# 1.下载安装go安装包：
	## （1）go语言下载地址：
	[Go语言中文网](https://studygolang.com/dl "Go语言中文网")
下载linux版本的安装包。

## （2）使用Xftp将安装包上传至指定的路径：

![](https://img-blog.csdnimg.cn/20190719142701389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
	这里上传到root目录下就行
	方便解压
## （3）解压并移到/usr/local/下：

进入指定目录，查看已有文件并且解压文件：

![](https://img-blog.csdnimg.cn/20190719143211340.png)
```
#在root目录输入ls查看目录文件
ls
#在root解压go包
tar -zxvf go的包名
```

解压完成后发现目录下多了一个go文件夹：
![](https://img-blog.csdnimg.cn/20190719143042938.png)
将文件夹移动到/usr/local/
![](https://img-blog.csdnimg.cn/20190719143137645.png)
# 2.配置环境变量：
## （1）进入目的目录查看go文件夹是否移动成功：
![](https://img-blog.csdnimg.cn/20190719143506382.png)
## （2）在usr下创建文件夹，用来存放自己的项目：
workspace
## （3）进入新建的目录workspace新建三个文件夹：
src
pkg
bin
### 说明：

	src 目录存放的是我们的go源代码，不同工程项目的代码以包名区分
	pkg 编译后生成的文件
	bin文件夹存放go install命名生成的可执行文件（这个文件夹会配置到环境变量中）
## （4）配置环境变量：

进入 /etc 修改profile文件：
![](https://img-blog.csdnimg.cn/20190719144319621.png)
```
#进入etc目录
cd /etc/
#配置 profile
vim profile
```
![](https://img-blog.csdnimg.cn/20190719145650864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
在此文件夹下加入上图的代码，代码如下：
```
// 设置go安装路径
export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin
 
// 设置工程目录
export GOPATH=/usr/workspace
export PATH=$PATH:$GOPATH/bin
```

## （5）刷新环境变量：
```
source /etc/profile
```
##  （6）查看go环境是否配置成功：
```
go version
```
## （7）查看详细配置：
```
go env
```
结果如下：  
![](https://img-blog.csdnimg.cn/20190719145255720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70) 
# 3.上传项目代码：
在刚刚创建的workspace下新创建的三个文件夹中，src 目录存放的是我们的go源代码
# 4运行
```go
go build main.go
//或者
go run main.go
```
最后执行 ./main 就行了。
如果想让项目在后台执行：执行 nohup ./main & ，这样就可以程序在后台运行了。

参考教程https://blog.csdn.net/qq_42410605/article/details/96479892', `image` = 'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3111860246,1925938903&fm=26&gp=0.jpg', `numb` = 34, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '简单又详细的教程', `creat_time` = '2020-07-19 18:32:31', `update_time` = '2020-07-20 13:11:56', `type_id` = 1, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:41:08][0m  [36;1m[0.25ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:41:08][0m  [36;1m[0.44ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 1)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:41:08][0m  [36;1m[0.35ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 2)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:41:08][0m  [36;1m[0.31ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 4)  
[36;31m[0 rows affected or returned ][0m 
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:41:08][0m  [36;1m[0.36ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 3)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:41:08][0m  [36;1m[0.29ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 5)  
[36;31m[0 rows affected or returned ][0m 
[{5 1 3 like 狗科 535889315@qq.com /static/images/header.jpg ？？？ 2020-07-20 13:30:17 <nil> []}]
[{5 1 3 like 狗科 535889315@qq.com /static/images/header.jpg ？？？ 2020-07-20 13:30:17 <nil> []}]

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-20 13:41:16][0m  [36;1m[0.43ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 1)  
[36;31m[2 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-20 13:41:16][0m  [36;1m[0.44ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=1  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-20 13:41:16][0m  [36;1m[0.42ms][0m  UPDATE `blogs` SET `title` = 'golang项目简单服务器部署到阿里云(linux)', `content` = '# 我个人比较推荐使用Xftp和Xshell 
# 重要是个人免费用
# 舒服又好用

# 1.下载安装go安装包：
	## （1）go语言下载地址：
	[Go语言中文网](https://studygolang.com/dl "Go语言中文网")
下载linux版本的安装包。

## （2）使用Xftp将安装包上传至指定的路径：

![](https://img-blog.csdnimg.cn/20190719142701389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
	这里上传到root目录下就行
	方便解压
## （3）解压并移到/usr/local/下：

进入指定目录，查看已有文件并且解压文件：

![](https://img-blog.csdnimg.cn/20190719143211340.png)
```
#在root目录输入ls查看目录文件
ls
#在root解压go包
tar -zxvf go的包名
```

解压完成后发现目录下多了一个go文件夹：
![](https://img-blog.csdnimg.cn/20190719143042938.png)
将文件夹移动到/usr/local/
![](https://img-blog.csdnimg.cn/20190719143137645.png)
# 2.配置环境变量：
## （1）进入目的目录查看go文件夹是否移动成功：
![](https://img-blog.csdnimg.cn/20190719143506382.png)
## （2）在usr下创建文件夹，用来存放自己的项目：
workspace
## （3）进入新建的目录workspace新建三个文件夹：
src
pkg
bin
### 说明：

	src 目录存放的是我们的go源代码，不同工程项目的代码以包名区分
	pkg 编译后生成的文件
	bin文件夹存放go install命名生成的可执行文件（这个文件夹会配置到环境变量中）
## （4）配置环境变量：

进入 /etc 修改profile文件：
![](https://img-blog.csdnimg.cn/20190719144319621.png)
```
#进入etc目录
cd /etc/
#配置 profile
vim profile
```
![](https://img-blog.csdnimg.cn/20190719145650864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
在此文件夹下加入上图的代码，代码如下：
```
// 设置go安装路径
export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin
 
// 设置工程目录
export GOPATH=/usr/workspace
export PATH=$PATH:$GOPATH/bin
```

## （5）刷新环境变量：
```
source /etc/profile
```
##  （6）查看go环境是否配置成功：
```
go version
```
## （7）查看详细配置：
```
go env
```
结果如下：  
![](https://img-blog.csdnimg.cn/20190719145255720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70) 
# 3.上传项目代码：
在刚刚创建的workspace下新创建的三个文件夹中，src 目录存放的是我们的go源代码
# 4运行
```go
go build main.go
//或者
go run main.go
```
最后执行 ./main 就行了。
如果想让项目在后台执行：执行 nohup ./main & ，这样就可以程序在后台运行了。

参考教程https://blog.csdn.net/qq_42410605/article/details/96479892', `image` = 'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3111860246,1925938903&fm=26&gp=0.jpg', `numb` = 35, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '简单又详细的教程', `creat_time` = '2020-07-19 18:32:31', `update_time` = '2020-07-20 13:11:56', `type_id` = 1, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:41:16][0m  [36;1m[0.29ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:41:16][0m  [36;1m[1.71ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 1)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:41:16][0m  [36;1m[0.35ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 2)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:41:16][0m  [36;1m[0.32ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 4)  
[36;31m[0 rows affected or returned ][0m 
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:41:16][0m  [36;1m[0.38ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 3)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:41:16][0m  [36;1m[0.32ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 5)  
[36;31m[0 rows affected or returned ][0m 
[{5 1 3 like 狗科 535889315@qq.com /static/images/header.jpg ？？？ 2020-07-20 13:30:17 <nil> []}]
[{5 1 3 like 狗科 535889315@qq.com /static/images/header.jpg ？？？ 2020-07-20 13:30:17 <nil> []}]

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:41:50][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 13:41:50][0m  [36;1m[0.72ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 13:41:50][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
3

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 13:41:50][0m  [36;1m[0.29ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 13:41:50][0m  [36;1m[0.25ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 13:41:50][0m  [36;1m[0.31ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:41:51][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:41:53][0m  [36;1m[0.62ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 13:41:53][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:137)[0m 
[33m[2020-07-20 13:41:53][0m  [36;1m[0.60ms][0m   SELECT * FROM `blogs` GROUP BY YEAR DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:150)[0m 
[33m[2020-07-20 13:41:53][0m  [36;1m[0.67ms][0m   SELECT * FROM `blogs` where year = 2020 GROUP BY month DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:162)[0m 
[33m[2020-07-20 13:41:53][0m  [36;1m[0.51ms][0m   SELECT * FROM `blogs` where year = 2020 and month = 7 ORDER BY `id` DESC  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 13:41:53][0m  [36;1m[0.36ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=3  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 13:41:53][0m  [36;1m[0.32ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=2  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 13:41:53][0m  [36;1m[0.45ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-20 13:41:54][0m  [36;1m[0.59ms][0m  SELECT * FROM `tags`    
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:41:54][0m  [36;1m[0.32ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 13:41:54][0m  [36;1m[0.76ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:31)[0m 
[33m[2020-07-20 13:41:54][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `tags`    
[36;31m[0 rows affected or returned ][0m 
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:43:31][0m  [36;1m[0.61ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 13:43:31][0m  [36;1m[0.26ms][0m  SELECT * FROM `types`    
[36;31m[3 rows affected or returned ][0m 
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:43:32][0m  [36;1m[0.58ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:38)[0m 
[33m[2020-07-20 13:43:32][0m  [36;1m[0.51ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.recommend,blogs.update_time FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY `blogs`.`id` LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 
&[{1 golang项目简单服务器部署到阿里云(linux) 0 go 是 2020-07-20 13:11:56} {2 mysql5.7 查询数据，group by 报错：Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 't.id' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by？ 0 mysql 是 2020-07-19 18:59:30} {3 解决Linux关闭终端后运行的程序自动停止 0 linux 是 2020-07-19 19:05:36}]
3 ceshi

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 13:43:32][0m  [36;1m[0.22ms][0m  SELECT * FROM `types`    
[36;31m[3 rows affected or returned ][0m 
0
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:43:33][0m  [36;1m[0.57ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:43:34][0m  [36;1m[0.57ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 13:43:34][0m  [36;1m[0.24ms][0m  SELECT * FROM `types`    
[36;31m[3 rows affected or returned ][0m 
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:43:34][0m  [36;1m[0.53ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:38)[0m 
[33m[2020-07-20 13:43:34][0m  [36;1m[0.49ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.recommend,blogs.update_time FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY `blogs`.`id` LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 
&[{1 golang项目简单服务器部署到阿里云(linux) 0 go 是 2020-07-20 13:11:56} {2 mysql5.7 查询数据，group by 报错：Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 't.id' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by？ 0 mysql 是 2020-07-19 18:59:30} {3 解决Linux关闭终端后运行的程序自动停止 0 linux 是 2020-07-19 19:05:36}]
3 ceshi

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 13:43:34][0m  [36;1m[0.21ms][0m  SELECT * FROM `types`    
[36;31m[3 rows affected or returned ][0m 
0
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:43:45][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 13:43:45][0m  [36;1m[0.26ms][0m  SELECT * FROM `types`    
[36;31m[3 rows affected or returned ][0m 
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:43:46][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:38)[0m 
[33m[2020-07-20 13:43:46][0m  [36;1m[0.52ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.recommend,blogs.update_time FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY `blogs`.`id` LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 
&[{1 golang项目简单服务器部署到阿里云(linux) 0 go 是 2020-07-20 13:11:56} {2 mysql5.7 查询数据，group by 报错：Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 't.id' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by？ 0 mysql 是 2020-07-19 18:59:30} {3 解决Linux关闭终端后运行的程序自动停止 0 linux 是 2020-07-19 19:05:36}]
3 ceshi

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 13:43:46][0m  [36;1m[0.22ms][0m  SELECT * FROM `types`    
[36;31m[3 rows affected or returned ][0m 
0
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:44:08][0m  [36;1m[0.56ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 13:44:08][0m  [36;1m[0.28ms][0m  SELECT * FROM `types`    
[36;31m[3 rows affected or returned ][0m 
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:44:09][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:38)[0m 
[33m[2020-07-20 13:44:09][0m  [36;1m[0.47ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.recommend,blogs.update_time FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY `blogs`.`id` LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 
&[{1 golang项目简单服务器部署到阿里云(linux) 0 go 是 2020-07-20 13:11:56} {2 mysql5.7 查询数据，group by 报错：Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 't.id' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by？ 0 mysql 是 2020-07-19 18:59:30} {3 解决Linux关闭终端后运行的程序自动停止 0 linux 是 2020-07-19 19:05:36}]
3 ceshi

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 13:44:09][0m  [36;1m[0.21ms][0m  SELECT * FROM `types`    
[36;31m[3 rows affected or returned ][0m 
0
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:44:12][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:44:14][0m  [36;1m[0.80ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:38)[0m 
[33m[2020-07-20 13:44:14][0m  [36;1m[0.52ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.recommend,blogs.update_time FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY `blogs`.`id` LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 
&[{1 golang项目简单服务器部署到阿里云(linux) 0 go 是 2020-07-20 13:11:56} {2 mysql5.7 查询数据，group by 报错：Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 't.id' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by？ 0 mysql 是 2020-07-19 18:59:30} {3 解决Linux关闭终端后运行的程序自动停止 0 linux 是 2020-07-19 19:05:36}]
3 ceshi

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 13:44:14][0m  [36;1m[0.22ms][0m  SELECT * FROM `types`    
[36;31m[3 rows affected or returned ][0m 
0

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:44:18][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 13:44:18][0m  [36;1m[0.67ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 13:44:18][0m  [36;1m[0.18ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
3

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 13:44:18][0m  [36;1m[0.28ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 13:44:18][0m  [36;1m[0.24ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 13:44:18][0m  [36;1m[0.30ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-20 13:44:33][0m  [36;1m[0.46ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 1)  
[36;31m[2 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-20 13:44:33][0m  [36;1m[0.46ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=1  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-20 13:44:33][0m  [36;1m[0.42ms][0m  UPDATE `blogs` SET `title` = 'golang项目简单服务器部署到阿里云(linux)', `content` = '# 我个人比较推荐使用Xftp和Xshell 
# 重要是个人免费用
# 舒服又好用

# 1.下载安装go安装包：
	## （1）go语言下载地址：
	[Go语言中文网](https://studygolang.com/dl "Go语言中文网")
下载linux版本的安装包。

## （2）使用Xftp将安装包上传至指定的路径：

![](https://img-blog.csdnimg.cn/20190719142701389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
	这里上传到root目录下就行
	方便解压
## （3）解压并移到/usr/local/下：

进入指定目录，查看已有文件并且解压文件：

![](https://img-blog.csdnimg.cn/20190719143211340.png)
```
#在root目录输入ls查看目录文件
ls
#在root解压go包
tar -zxvf go的包名
```

解压完成后发现目录下多了一个go文件夹：
![](https://img-blog.csdnimg.cn/20190719143042938.png)
将文件夹移动到/usr/local/
![](https://img-blog.csdnimg.cn/20190719143137645.png)
# 2.配置环境变量：
## （1）进入目的目录查看go文件夹是否移动成功：
![](https://img-blog.csdnimg.cn/20190719143506382.png)
## （2）在usr下创建文件夹，用来存放自己的项目：
workspace
## （3）进入新建的目录workspace新建三个文件夹：
src
pkg
bin
### 说明：

	src 目录存放的是我们的go源代码，不同工程项目的代码以包名区分
	pkg 编译后生成的文件
	bin文件夹存放go install命名生成的可执行文件（这个文件夹会配置到环境变量中）
## （4）配置环境变量：

进入 /etc 修改profile文件：
![](https://img-blog.csdnimg.cn/20190719144319621.png)
```
#进入etc目录
cd /etc/
#配置 profile
vim profile
```
![](https://img-blog.csdnimg.cn/20190719145650864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
在此文件夹下加入上图的代码，代码如下：
```
// 设置go安装路径
export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin
 
// 设置工程目录
export GOPATH=/usr/workspace
export PATH=$PATH:$GOPATH/bin
```

## （5）刷新环境变量：
```
source /etc/profile
```
##  （6）查看go环境是否配置成功：
```
go version
```
## （7）查看详细配置：
```
go env
```
结果如下：  
![](https://img-blog.csdnimg.cn/20190719145255720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70) 
# 3.上传项目代码：
在刚刚创建的workspace下新创建的三个文件夹中，src 目录存放的是我们的go源代码
# 4运行
```go
go build main.go
//或者
go run main.go
```
最后执行 ./main 就行了。
如果想让项目在后台执行：执行 nohup ./main & ，这样就可以程序在后台运行了。

参考教程https://blog.csdn.net/qq_42410605/article/details/96479892', `image` = 'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3111860246,1925938903&fm=26&gp=0.jpg', `numb` = 36, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '简单又详细的教程', `creat_time` = '2020-07-19 18:32:31', `update_time` = '2020-07-20 13:11:56', `type_id` = 1, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:44:33][0m  [36;1m[0.26ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:44:33][0m  [36;1m[0.39ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 1)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:44:33][0m  [36;1m[0.37ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 2)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:44:33][0m  [36;1m[0.31ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 4)  
[36;31m[0 rows affected or returned ][0m 
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:44:33][0m  [36;1m[2.48ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 3)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:44:33][0m  [36;1m[0.32ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 5)  
[36;31m[0 rows affected or returned ][0m 
[{5 1 3 like 狗科 535889315@qq.com /static/images/header.jpg ？？？ 2020-07-20 13:30:17 <nil> []}]
[{5 1 3 like 狗科 535889315@qq.com /static/images/header.jpg ？？？ 2020-07-20 13:30:17 <nil> []}]

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 13:45:34][0m  [36;1m[0.52ms][0m  SELECT * FROM `types`    
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:45:34][0m  [36;1m[0.24ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 13:45:34][0m  [36;1m[0.65ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-20 13:45:34][0m  [36;1m[0.18ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 13:45:37][0m  [36;1m[0.53ms][0m  SELECT * FROM `types`    
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:45:37][0m  [36;1m[0.24ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 13:45:37][0m  [36;1m[0.66ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-20 13:45:37][0m  [36;1m[0.18ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-20 13:45:40][0m  [36;1m[0.41ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 2)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-20 13:45:40][0m  [36;1m[0.53ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=2  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-20 13:45:40][0m  [36;1m[0.39ms][0m  UPDATE `blogs` SET `title` = '解决Linux关闭终端后运行的程序自动停止', `content` = '# 问题发现
  昨天博客发布，操作完关闭终端就睡了
  然而今天醒来突然发现终端不能访问了
  查看发现原来博客项目进程被杀死了
# 解决办法
    go build main.go
执行完后

    nohup ./main &
让程序在后台运行就可了


[========]
# ps:这个方法并不完美，因为我也是刚刚接触还不知道怎么切回来', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3696516981,3671280793&fm=26&gp=0.jpg', `numb` = 10, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '昨天博客发布，操作完关闭终端就睡了，然而今天醒来突然发现终端不能访问了，查看发现原来博客项目进程被杀死了', `creat_time` = '2020-07-19 19:05:36', `update_time` = '2020-07-19 19:05:36', `type_id` = 2, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 3  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:45:40][0m  [36;1m[0.27ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:45:42][0m  [36;1m[0.60ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 13:45:42][0m  [36;1m[0.85ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 13:45:42][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
3

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 13:45:42][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 13:45:42][0m  [36;1m[0.31ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 13:45:42][0m  [36;1m[0.38ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 13:45:44][0m  [36;1m[0.52ms][0m  SELECT * FROM `types`    
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:45:44][0m  [36;1m[0.23ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 13:45:44][0m  [36;1m[0.70ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-20 13:45:44][0m  [36;1m[0.17ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-20 13:45:46][0m  [36;1m[0.45ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 1)  
[36;31m[2 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-20 13:45:46][0m  [36;1m[0.48ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=1  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-20 13:45:46][0m  [36;1m[0.43ms][0m  UPDATE `blogs` SET `title` = 'golang项目简单服务器部署到阿里云(linux)', `content` = '# 我个人比较推荐使用Xftp和Xshell 
# 重要是个人免费用
# 舒服又好用

# 1.下载安装go安装包：
	## （1）go语言下载地址：
	[Go语言中文网](https://studygolang.com/dl "Go语言中文网")
下载linux版本的安装包。

## （2）使用Xftp将安装包上传至指定的路径：

![](https://img-blog.csdnimg.cn/20190719142701389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
	这里上传到root目录下就行
	方便解压
## （3）解压并移到/usr/local/下：

进入指定目录，查看已有文件并且解压文件：

![](https://img-blog.csdnimg.cn/20190719143211340.png)
```
#在root目录输入ls查看目录文件
ls
#在root解压go包
tar -zxvf go的包名
```

解压完成后发现目录下多了一个go文件夹：
![](https://img-blog.csdnimg.cn/20190719143042938.png)
将文件夹移动到/usr/local/
![](https://img-blog.csdnimg.cn/20190719143137645.png)
# 2.配置环境变量：
## （1）进入目的目录查看go文件夹是否移动成功：
![](https://img-blog.csdnimg.cn/20190719143506382.png)
## （2）在usr下创建文件夹，用来存放自己的项目：
workspace
## （3）进入新建的目录workspace新建三个文件夹：
src
pkg
bin
### 说明：

	src 目录存放的是我们的go源代码，不同工程项目的代码以包名区分
	pkg 编译后生成的文件
	bin文件夹存放go install命名生成的可执行文件（这个文件夹会配置到环境变量中）
## （4）配置环境变量：

进入 /etc 修改profile文件：
![](https://img-blog.csdnimg.cn/20190719144319621.png)
```
#进入etc目录
cd /etc/
#配置 profile
vim profile
```
![](https://img-blog.csdnimg.cn/20190719145650864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
在此文件夹下加入上图的代码，代码如下：
```
// 设置go安装路径
export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin
 
// 设置工程目录
export GOPATH=/usr/workspace
export PATH=$PATH:$GOPATH/bin
```

## （5）刷新环境变量：
```
source /etc/profile
```
##  （6）查看go环境是否配置成功：
```
go version
```
## （7）查看详细配置：
```
go env
```
结果如下：  
![](https://img-blog.csdnimg.cn/20190719145255720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70) 
# 3.上传项目代码：
在刚刚创建的workspace下新创建的三个文件夹中，src 目录存放的是我们的go源代码
# 4运行
```go
go build main.go
//或者
go run main.go
```
最后执行 ./main 就行了。
如果想让项目在后台执行：执行 nohup ./main & ，这样就可以程序在后台运行了。

参考教程https://blog.csdn.net/qq_42410605/article/details/96479892', `image` = 'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3111860246,1925938903&fm=26&gp=0.jpg', `numb` = 37, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '简单又详细的教程', `creat_time` = '2020-07-19 18:32:31', `update_time` = '2020-07-20 13:11:56', `type_id` = 1, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:45:46][0m  [36;1m[0.28ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:45:46][0m  [36;1m[0.44ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 1)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:45:46][0m  [36;1m[0.34ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 2)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:45:46][0m  [36;1m[0.29ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 4)  
[36;31m[0 rows affected or returned ][0m 
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:45:46][0m  [36;1m[0.38ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 3)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 13:45:46][0m  [36;1m[0.31ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 5)  
[36;31m[0 rows affected or returned ][0m 
[{5 1 3 like 狗科 535889315@qq.com /static/images/header.jpg ？？？ 2020-07-20 13:30:17 <nil> []}]
[{5 1 3 like 狗科 535889315@qq.com /static/images/header.jpg ？？？ 2020-07-20 13:30:17 <nil> []}]

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-20 13:45:50][0m  [36;1m[0.53ms][0m  SELECT * FROM `tags`    
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:45:50][0m  [36;1m[0.25ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:68)[0m 
[33m[2020-07-20 13:45:50][0m  [36;1m[0.42ms][0m  SELECT * FROM `tags`  WHERE (tag_name='linux指令') ORDER BY `tags`.`id` ASC LIMIT 1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:76)[0m 
[33m[2020-07-20 13:45:50][0m  [36;1m[0.89ms][0m   SELECT b.id,b.title,b.type_id,t.tag_name,b.description,b.recommend,b.numb,b.update_time,b.image,a.`type_name`  FROM `blogs` b LEFT JOIN `tag_blogs` tb ON b.id = tb.`blog_id` LEFT JOIN tags t ON tb.`tag_id`=t.`id` LEFT JOIN `types` a ON b.type_id = a.`id` WHERE t.`id`=2 ORDER BY b.id  DESC LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:31)[0m 
[33m[2020-07-20 13:45:50][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `tags`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:45:53][0m  [36;1m[0.59ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 13:45:53][0m  [36;1m[0.69ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 13:45:53][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
3

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 13:45:53][0m  [36;1m[0.31ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 13:45:53][0m  [36;1m[0.25ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 13:45:53][0m  [36;1m[0.40ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:45:54][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:45:55][0m  [36;1m[0.58ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 13:45:55][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:137)[0m 
[33m[2020-07-20 13:45:55][0m  [36;1m[0.62ms][0m   SELECT * FROM `blogs` GROUP BY YEAR DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:150)[0m 
[33m[2020-07-20 13:45:55][0m  [36;1m[0.70ms][0m   SELECT * FROM `blogs` where year = 2020 GROUP BY month DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:162)[0m 
[33m[2020-07-20 13:45:55][0m  [36;1m[0.51ms][0m   SELECT * FROM `blogs` where year = 2020 and month = 7 ORDER BY `id` DESC  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 13:45:55][0m  [36;1m[0.40ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=3  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 13:45:55][0m  [36;1m[0.34ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=2  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 13:45:55][0m  [36;1m[0.35ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:45:56][0m  [36;1m[0.59ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:46:49][0m  [36;1m[0.57ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 13:46:49][0m  [36;1m[0.69ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 13:46:49][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
3

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 13:46:49][0m  [36;1m[0.29ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 13:46:49][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 13:46:49][0m  [36;1m[0.31ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 13:47:06][0m  [36;1m[0.54ms][0m  SELECT * FROM `types`    
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:47:06][0m  [36;1m[0.26ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 13:47:06][0m  [36;1m[0.64ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-20 13:47:06][0m  [36;1m[0.18ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:47:09][0m  [36;1m[0.59ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:47:12][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:38)[0m 
[33m[2020-07-20 13:47:12][0m  [36;1m[0.49ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.recommend,blogs.update_time FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY `blogs`.`id` LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 
&[{1 golang项目简单服务器部署到阿里云(linux) 0 go 是 2020-07-20 13:11:56} {2 mysql5.7 查询数据，group by 报错：Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 't.id' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by？ 0 mysql 是 2020-07-19 18:59:30} {3 解决Linux关闭终端后运行的程序自动停止 0 linux 是 2020-07-19 19:05:36}]
3 ceshi

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 13:47:12][0m  [36;1m[0.24ms][0m  SELECT * FROM `types`    
[36;31m[3 rows affected or returned ][0m 
0
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:47:13][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 13:47:13][0m  [36;1m[0.24ms][0m  SELECT * FROM `types`    
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-20 13:47:13][0m  [36;1m[0.20ms][0m  SELECT * FROM `tags`    
[36;31m[3 rows affected or returned ][0m 
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:47:17][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 13:47:17][0m  [36;1m[0.23ms][0m  SELECT * FROM `types`    
[36;31m[3 rows affected or returned ][0m 
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:47:19][0m  [36;1m[0.56ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:47:38][0m  [36;1m[0.51ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
[GIN-debug] redirecting request 301: /admin/type/ --> /admin/type/
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:47:38][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 13:47:38][0m  [36;1m[0.23ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:47:39][0m  [36;1m[0.56ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:47:41][0m  [36;1m[0.59ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:47:44][0m  [36;1m[0.61ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
[GIN-debug] redirecting request 301: /admin/tag/ --> /admin/tag/?msg=3&page=1
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:47:44][0m  [36;1m[0.56ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:47:45][0m  [36;1m[0.57ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:47:51][0m  [36;1m[0.58ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
[GIN-debug] redirecting request 301: /admin/tag/ --> /admin/tag/?msg=3&page=1
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:47:51][0m  [36;1m[0.53ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:47:52][0m  [36;1m[0.52ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 13:47:52][0m  [36;1m[0.26ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:47:53][0m  [36;1m[0.56ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:38)[0m 
[33m[2020-07-20 13:47:53][0m  [36;1m[0.47ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.recommend,blogs.update_time FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY `blogs`.`id` LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 
&[{1 golang项目简单服务器部署到阿里云(linux) 0 go 是 2020-07-20 13:11:56} {2 mysql5.7 查询数据，group by 报错：Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 't.id' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by？ 0 mysql 是 2020-07-19 18:59:30} {3 解决Linux关闭终端后运行的程序自动停止 0 linux 是 2020-07-19 19:05:36}]
3 ceshi

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 13:47:53][0m  [36;1m[0.21ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 
0
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 13:47:54][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 13:47:54][0m  [36;1m[0.25ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-20 13:47:54][0m  [36;1m[0.26ms][0m  SELECT * FROM `tags`    
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-20 14:03:23][0m  [36;1m[0.64ms][0m  SELECT * FROM `tags`    
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 14:03:23][0m  [36;1m[0.28ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 14:03:23][0m  [36;1m[0.91ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:31)[0m 
[33m[2020-07-20 14:03:23][0m  [36;1m[0.30ms][0m  SELECT count(*) FROM `tags`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-20 14:03:24][0m  [36;1m[0.64ms][0m  SELECT * FROM `tags`    
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 14:03:24][0m  [36;1m[0.28ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 14:03:24][0m  [36;1m[0.66ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:31)[0m 
[33m[2020-07-20 14:03:24][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `tags`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 14:03:25][0m  [36;1m[0.53ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 14:03:25][0m  [36;1m[0.26ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 14:03:25][0m  [36;1m[0.74ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-20 14:03:25][0m  [36;1m[0.22ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-20 14:03:26][0m  [36;1m[0.56ms][0m  SELECT * FROM `tags`    
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 14:03:26][0m  [36;1m[0.28ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 14:03:26][0m  [36;1m[0.69ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:31)[0m 
[33m[2020-07-20 14:03:26][0m  [36;1m[0.24ms][0m  SELECT count(*) FROM `tags`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 14:03:27][0m  [36;1m[0.53ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 14:03:27][0m  [36;1m[0.25ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 14:03:27][0m  [36;1m[0.66ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-20 14:03:27][0m  [36;1m[0.22ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 14:03:28][0m  [36;1m[0.57ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 14:03:28][0m  [36;1m[0.67ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 14:03:28][0m  [36;1m[0.22ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
3

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 14:03:28][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 14:03:28][0m  [36;1m[0.29ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 14:03:28][0m  [36;1m[0.34ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-20 14:03:29][0m  [36;1m[0.58ms][0m  SELECT * FROM `tags`    
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 14:03:29][0m  [36;1m[0.28ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 14:03:29][0m  [36;1m[0.67ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:31)[0m 
[33m[2020-07-20 14:03:29][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `tags`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 14:03:30][0m  [36;1m[0.53ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 14:03:30][0m  [36;1m[0.26ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 14:03:30][0m  [36;1m[0.67ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-20 14:03:30][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 14:03:31][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 14:03:31][0m  [36;1m[0.70ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 14:03:31][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
3

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 14:03:31][0m  [36;1m[0.29ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 14:03:31][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 14:03:31][0m  [36;1m[0.32ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 14:36:21][0m  [36;1m[0.59ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 14:36:21][0m  [36;1m[0.73ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 14:36:21][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
3

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 14:36:21][0m  [36;1m[0.34ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 14:36:21][0m  [36;1m[0.28ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 14:36:21][0m  [36;1m[0.34ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 14:38:36][0m  [36;1m[0.60ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 14:38:36][0m  [36;1m[0.72ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 14:38:36][0m  [36;1m[0.24ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
3

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 14:38:36][0m  [36;1m[0.32ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 14:38:36][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 14:38:36][0m  [36;1m[0.36ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 14:38:39][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 14:39:22][0m  [36;1m[0.56ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 14:39:22][0m  [36;1m[0.72ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 14:39:22][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
3

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 14:39:22][0m  [36;1m[0.33ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 14:39:22][0m  [36;1m[0.25ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 14:39:22][0m  [36;1m[0.35ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 14:40:15][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 14:40:15][0m  [36;1m[0.67ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 14:40:15][0m  [36;1m[0.23ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
3

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 14:40:15][0m  [36;1m[0.33ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 14:40:15][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 14:40:15][0m  [36;1m[0.36ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-20 14:54:20][0m  [36;1m[0.44ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 2)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-20 14:54:20][0m  [36;1m[0.45ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=2  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-20 14:54:20][0m  [36;1m[0.40ms][0m  UPDATE `blogs` SET `title` = '解决Linux关闭终端后运行的程序自动停止', `content` = '# 问题发现
  昨天博客发布，操作完关闭终端就睡了
  然而今天醒来突然发现终端不能访问了
  查看发现原来博客项目进程被杀死了
# 解决办法
    go build main.go
执行完后

    nohup ./main &
让程序在后台运行就可了


[========]
# ps:这个方法并不完美，因为我也是刚刚接触还不知道怎么切回来', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3696516981,3671280793&fm=26&gp=0.jpg', `numb` = 11, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '昨天博客发布，操作完关闭终端就睡了，然而今天醒来突然发现终端不能访问了，查看发现原来博客项目进程被杀死了', `creat_time` = '2020-07-19 19:05:36', `update_time` = '2020-07-19 19:05:36', `type_id` = 2, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 3  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 14:54:20][0m  [36;1m[0.28ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-20 14:54:24][0m  [36;1m[0.59ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 1)  
[36;31m[2 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-20 14:54:24][0m  [36;1m[0.63ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=1  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-20 14:54:24][0m  [36;1m[0.57ms][0m  UPDATE `blogs` SET `title` = 'golang项目简单服务器部署到阿里云(linux)', `content` = '# 我个人比较推荐使用Xftp和Xshell 
# 重要是个人免费用
# 舒服又好用

# 1.下载安装go安装包：
	## （1）go语言下载地址：
	[Go语言中文网](https://studygolang.com/dl "Go语言中文网")
下载linux版本的安装包。

## （2）使用Xftp将安装包上传至指定的路径：

![](https://img-blog.csdnimg.cn/20190719142701389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
	这里上传到root目录下就行
	方便解压
## （3）解压并移到/usr/local/下：

进入指定目录，查看已有文件并且解压文件：

![](https://img-blog.csdnimg.cn/20190719143211340.png)
```
#在root目录输入ls查看目录文件
ls
#在root解压go包
tar -zxvf go的包名
```

解压完成后发现目录下多了一个go文件夹：
![](https://img-blog.csdnimg.cn/20190719143042938.png)
将文件夹移动到/usr/local/
![](https://img-blog.csdnimg.cn/20190719143137645.png)
# 2.配置环境变量：
## （1）进入目的目录查看go文件夹是否移动成功：
![](https://img-blog.csdnimg.cn/20190719143506382.png)
## （2）在usr下创建文件夹，用来存放自己的项目：
workspace
## （3）进入新建的目录workspace新建三个文件夹：
src
pkg
bin
### 说明：

	src 目录存放的是我们的go源代码，不同工程项目的代码以包名区分
	pkg 编译后生成的文件
	bin文件夹存放go install命名生成的可执行文件（这个文件夹会配置到环境变量中）
## （4）配置环境变量：

进入 /etc 修改profile文件：
![](https://img-blog.csdnimg.cn/20190719144319621.png)
```
#进入etc目录
cd /etc/
#配置 profile
vim profile
```
![](https://img-blog.csdnimg.cn/20190719145650864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
在此文件夹下加入上图的代码，代码如下：
```
// 设置go安装路径
export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin
 
// 设置工程目录
export GOPATH=/usr/workspace
export PATH=$PATH:$GOPATH/bin
```

## （5）刷新环境变量：
```
source /etc/profile
```
##  （6）查看go环境是否配置成功：
```
go version
```
## （7）查看详细配置：
```
go env
```
结果如下：  
![](https://img-blog.csdnimg.cn/20190719145255720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70) 
# 3.上传项目代码：
在刚刚创建的workspace下新创建的三个文件夹中，src 目录存放的是我们的go源代码
# 4运行
```go
go build main.go
//或者
go run main.go
```
最后执行 ./main 就行了。
如果想让项目在后台执行：执行 nohup ./main & ，这样就可以程序在后台运行了。

参考教程https://blog.csdn.net/qq_42410605/article/details/96479892', `image` = 'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3111860246,1925938903&fm=26&gp=0.jpg', `numb` = 38, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '简单又详细的教程', `creat_time` = '2020-07-19 18:32:31', `update_time` = '2020-07-20 13:11:56', `type_id` = 1, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 14:54:24][0m  [36;1m[0.38ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 14:54:24][0m  [36;1m[3.82ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 1)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 14:54:24][0m  [36;1m[0.48ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 2)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 14:54:24][0m  [36;1m[0.40ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 4)  
[36;31m[0 rows affected or returned ][0m 
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 14:54:24][0m  [36;1m[0.46ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 3)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 14:54:24][0m  [36;1m[0.41ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 5)  
[36;31m[0 rows affected or returned ][0m 
[{5 1 3 like 狗科 535889315@qq.com /static/images/header.jpg ？？？ 2020-07-20 13:30:17 <nil> []}]
[{5 1 3 like 狗科 535889315@qq.com /static/images/header.jpg ？？？ 2020-07-20 13:30:17 <nil> []}]
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 15:24:23][0m  [36;1m[0.58ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 15:24:23][0m  [36;1m[0.50ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-20 15:24:23][0m  [36;1m[0.25ms][0m  SELECT * FROM `tags`    
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:47)[0m 
[33m[2020-07-20 15:24:23][0m  [36;1m[0.30ms][0m  INSERT INTO `tag_blogs` (`tag_id`,`blog_id`) VALUES (4,4)  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:47)[0m 
[33m[2020-07-20 15:24:23][0m  [36;1m[0.47ms][0m  INSERT INTO `tag_blogs` (`tag_id`,`blog_id`) VALUES (5,4)  
[36;31m[1 rows affected or returned ][0m 
[GIN-debug] redirecting request 301: /admin/blog/ --> /admin/blog/?msg=3&page=1
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 15:24:23][0m  [36;1m[0.52ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:38)[0m 
[33m[2020-07-20 15:24:23][0m  [36;1m[0.49ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.recommend,blogs.update_time FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY `blogs`.`id` LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 
&[{1 golang项目简单服务器部署到阿里云(linux) 0 go 是 2020-07-20 13:11:56} {2 mysql5.7 查询数据，group by 报错：Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 't.id' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by？ 0 mysql 是 2020-07-19 18:59:30} {3 解决Linux关闭终端后运行的程序自动停止 0 linux 是 2020-07-19 19:05:36} {4 本博客开源公告 0 博客公告 是 2020-07-20 15:24:23}]
4 ceshi

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 15:24:23][0m  [36;1m[0.21ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 
0

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 15:24:32][0m  [36;1m[0.59ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 15:24:32][0m  [36;1m[0.74ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 15:24:32][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 15:24:32][0m  [36;1m[0.32ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 15:24:32][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 15:24:32][0m  [36;1m[0.32ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-20 15:24:35][0m  [36;1m[0.38ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 4)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-20 15:24:35][0m  [36;1m[0.49ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=4  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-20 15:24:35][0m  [36;1m[0.49ms][0m  UPDATE `blogs` SET `title` = '本博客开源公告', `content` = '今天本博客评论功能发布
# 自今天起，本博客基本功能已经完成
## 发布V1.0版本并开源
## 博客语言说明
#### 本博客后端是用golang 的gin框架+gorm编写
前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的
#### 博客效果参考本站
#一、博客简介
## 1.博客目录

    blog
    ├────controller
	├────└───admin
	|	|	├──adminblog.go
	|	|	├───adminController.go
	|	|	├──adminTag.go
	|	|	├──adminType.go
	|	|	└──adminUser.go
	|	└──page
	|		├──404.go
	|		├───about.go
	|		├──archives.go
	|		├──blog.go
	|		├──comment.go
	|		├──pagesController.go
	|		├──researchController.go
	|		└──tagsController.go
    ├── dao
	│	├──blogs.go
	│	├──comment.go
	│	├──sql.go
	│	├──tags.go
	│	├──types.go
	│	└──user.go
    ├── logic
    │   └── user.go
    ├── middlerware
	│	├──function.go
	│	├──getImg.go
	│	├──getTime.go
	│	├──markdown.go
	│	├──select.go
	│	└──session.go
    ├── model
	│	├──blog.go
	│	├──commnent.go
	│	├──tag.go
	│	├──type.go
	│	└──user/go
    ├── static
	│	└──静态文件（头像、图片、logo、css、js等）
    ├── templates
	│	└──html模板文件
    ├── go.mod（依赖）
    └── main.go
    

## 2.相关功能实现简介
### 1、评论及回复功能
comment的结构体属性如下
```go
package model

type Comment struct {
	Id     int //评论id
	BlogId int //博文id
	ReCommentId    int    //父评论id
	CommentName string //评论人姓名
	ReCommentName  string //父评论人姓名
	CommentEmail   string
	Img            string
	CommentContent string `gorm:"type:text" form:"CommentContent" json:"CommentContent"` //评论内容
	CommentTime    string ` json:"comment_time,omitempty"`
	Parent         *Comment
	Comments       []Comment
}
```
#### 实现方法
##### 1先通过查找父评论为-1的顶级评论
父评论Id为-1说明他不是任何评论的子评论
##### 2在html上遍历所有的顶级评论
在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论
###### （1）递归存储每个顶级评论的子评论
这里我用一个切片来储存一个顶级评论的所有子评论
```go
var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
	var comments []model.Comment
	DB.Debug().Where("re_comment_id = -1 AND blog_id = ?", id).Find(&comments)
	return &comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
	if count != 0 {
		fmt.Println("if判断1")
		var comments []model.Comment
		DB.Debug().Where("re_comment_id = ?", id).Find(&comments)
		count = len(comments)
		if count != 0 {
			fmt.Println("if判断2")
			for _, comment := range comments {
				fmt.Println("for判断1")
				Comments = append(Comments, comment)
				SelectCommentByComment(comment.Id, count)
			}
		}
	}
	fmt.Println(Comments)
	return &Comments

}
```
ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来
###### （2）出现问题的原因
因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量
###### （3）解决问题
```go
func ClearComments() bool {
	var comments []model.Comment
	Comments = comments
	return true
}

```
这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现
#### 这里我还加了一个小小的随机头像功能
```go
if  CommentName == user.Name && CommentEmail == user.UserEmail {
		fmt.Println("进入了1")
		comment.Img =user.UserImg
		//找相同评论人
	}else if CommentName == one.CommentName && CommentEmail == one.CommentEmail {
		fmt.Println("进入了2")
		comment.Img =one.Img
		//随机选头像
	}else{
		fmt.Println("进入了3")
		comment.Img =middleware.GetImg()
	}
```
##### 123分别代表三种不同的用户群体
1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
![](/static/images/%e5%a4%b4%e5%83%8f1.png)![](/static/images/%e5%a4%b4%e5%83%8f2.png)![](/static/images/%e5%a4%b4%e5%83%8f3.png)![](/static/images/%e5%a4%b4%e5%83%8f4.png)![](/static/images/%e5%a4%b4%e5%83%8f5.png)![](/static/images/%e5%a4%b4%e5%83%8f6.png)
### 2、归档功能
#### blog的结构体属性如下
```go
package model

type Blog struct {
	Id           int
	Title        string    `form:"title" json:"title"`                          //标题
	Content      string    `gorm:"type:longtext" form:"content" json:"content"` //内容
	Image        string    `gorm:"type:text" form:"image" json:"image"`         //首图
	Numb         int       `form:"numb" json:"numb"`                            //次数
	Flag         string    `form:"flag" json:"flag"`                            //原创或者转载
	Appreciation string    `form:"appreciation" json:"appreciation"`            //打赏开关
	ShareInfo    string    `form:"shareInfo" json:"shareInfo"`                  //版权开关
	Comment      string    `form:"comment" json:"comment"`                      //评论开关
	Recommend    string    `form:"recommend" json:"recommend"`                  //推荐开关
	Description  string    `gorm:"type:text" form:"description" json:"description"`
	CreatTime    string    `form:"creatTime"  json:"creat_time,omitempty"`   //创建时间
	UpdateTime   string    `form:"updateTime"  json:"update_time,omitempty"` //更新时间
	Comments     []Comment `form:"comments" json:"comments"`
	TypeId       int       `form:"typeId" json:"typeId"`
	Type         Type      `form:"type" gorm:"ForeignKey:TypeId"`
	Year         int       `form:"year" json:"year"`
	Month        int       `form:"month" json:"month"`
	Day          int       `form:"day" json:"day"`
}

```
#### 实现方法
我的思路是创建三个时间节点
year month day 
利用sql分组查询
##### Group By分组查询步骤
###### （1）先按照年份查询
###### （2）再按照年份遍历每个月份
并将所有保存在一个切片中
###### （3）按照月份遍历每个月的所有文章
保存在一个Map中，key是对应的月份，value是每个月份的所有文章
#### 自此归档功能实现


## 3.已知BUG
### 后台退出功能
后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧

开源地址
[github](https://github.com/likewl/blog "github")
[gitee](https://gitee.com/nculike/blog "gitee")', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1535821573,4166447487&fm=26&gp=0.jpg', `numb` = 1, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '本博客后端是用golang 的gin框架+gorm编写', `creat_time` = '2020-07-20 15:24:23', `update_time` = '2020-07-20 15:24:23', `type_id` = 4, `year` = 2020, `month` = 7, `day` = 20  WHERE `blogs`.`id` = 4  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 15:24:35][0m  [36;1m[1.42ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 15:27:10][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 15:27:10][0m  [36;1m[0.72ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 15:27:10][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 15:27:10][0m  [36;1m[0.31ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 15:27:10][0m  [36;1m[0.25ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 15:27:10][0m  [36;1m[0.33ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 15:32:05][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 15:32:05][0m  [36;1m[0.25ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-20 15:32:05][0m  [36;1m[0.24ms][0m  SELECT * FROM `tags`    
[36;31m[5 rows affected or returned ][0m 
{0    0         [] 0 {0  []} 0 0 0} ceshi

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 15:45:03][0m  [36;1m[0.56ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 15:45:03][0m  [36;1m[0.73ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 15:45:03][0m  [36;1m[0.24ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 15:45:03][0m  [36;1m[0.31ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 15:45:03][0m  [36;1m[0.27ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 15:45:03][0m  [36;1m[0.32ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 15:59:07][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 15:59:07][0m  [36;1m[0.69ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 15:59:07][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 15:59:07][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 15:59:07][0m  [36;1m[0.25ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 15:59:07][0m  [36;1m[0.34ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 16:57:55][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 16:57:55][0m  [36;1m[0.71ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 16:57:55][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 16:57:55][0m  [36;1m[0.29ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 16:57:55][0m  [36;1m[0.27ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 16:57:55][0m  [36;1m[0.33ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 16:58:11][0m  [36;1m[0.53ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 16:58:11][0m  [36;1m[0.69ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 16:58:11][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 16:58:11][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 16:58:11][0m  [36;1m[0.27ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 16:58:11][0m  [36;1m[0.32ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 16:58:16][0m  [36;1m[0.56ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 16:58:16][0m  [36;1m[0.76ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 16:58:16][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 16:58:16][0m  [36;1m[0.29ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 16:58:16][0m  [36;1m[0.28ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 16:58:16][0m  [36;1m[0.37ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 16:58:55][0m  [36;1m[0.50ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 16:59:03][0m  [36;1m[0.50ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 16:59:03][0m  [36;1m[0.24ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 16:59:03][0m  [36;1m[2.33ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-20 16:59:03][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 16:59:06][0m  [36;1m[0.66ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 16:59:11][0m  [36;1m[0.62ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 16:59:14][0m  [36;1m[0.53ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 16:59:14][0m  [36;1m[0.69ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 16:59:14][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 16:59:14][0m  [36;1m[0.28ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 16:59:14][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 16:59:14][0m  [36;1m[0.34ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 16:59:15][0m  [36;1m[0.51ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 16:59:15][0m  [36;1m[0.26ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 16:59:15][0m  [36;1m[0.67ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-20 16:59:15][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 16:59:30][0m  [36;1m[0.58ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 16:59:30][0m  [36;1m[0.70ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 16:59:30][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 16:59:30][0m  [36;1m[0.36ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 16:59:30][0m  [36;1m[0.28ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 16:59:30][0m  [36;1m[0.33ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 17:20:46][0m  [36;1m[0.60ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 17:20:46][0m  [36;1m[0.25ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:137)[0m 
[33m[2020-07-20 17:20:46][0m  [36;1m[0.64ms][0m   SELECT * FROM `blogs` GROUP BY YEAR DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:150)[0m 
[33m[2020-07-20 17:20:46][0m  [36;1m[1.00ms][0m   SELECT * FROM `blogs` where year = 2020 GROUP BY month DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:162)[0m 
[33m[2020-07-20 17:20:46][0m  [36;1m[0.63ms][0m   SELECT * FROM `blogs` where year = 2020 and month = 7 ORDER BY `id` DESC  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 17:20:46][0m  [36;1m[0.40ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=4  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 17:20:46][0m  [36;1m[0.34ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=3  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 17:20:46][0m  [36;1m[0.38ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=2  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 17:20:46][0m  [36;1m[0.34ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 17:21:04][0m  [36;1m[0.52ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 17:21:04][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:137)[0m 
[33m[2020-07-20 17:21:04][0m  [36;1m[0.60ms][0m   SELECT * FROM `blogs` GROUP BY YEAR DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:150)[0m 
[33m[2020-07-20 17:21:04][0m  [36;1m[0.67ms][0m   SELECT * FROM `blogs` where year = 2020 GROUP BY month DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:162)[0m 
[33m[2020-07-20 17:21:04][0m  [36;1m[0.60ms][0m   SELECT * FROM `blogs` where year = 2020 and month = 7 ORDER BY `id` DESC  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 17:21:04][0m  [36;1m[0.41ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=4  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 17:21:04][0m  [36;1m[0.33ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=3  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 17:21:04][0m  [36;1m[0.32ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=2  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 17:21:04][0m  [36;1m[0.31ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-20 17:35:57][0m  [36;1m[0.56ms][0m  SELECT * FROM `tags`    
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 17:35:57][0m  [36;1m[0.26ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 17:35:57][0m  [36;1m[0.70ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:31)[0m 
[33m[2020-07-20 17:35:57][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `tags`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-20 17:36:11][0m  [36;1m[0.59ms][0m  SELECT * FROM `tags`    
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 17:36:11][0m  [36;1m[0.23ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 17:36:11][0m  [36;1m[0.90ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:31)[0m 
[33m[2020-07-20 17:36:11][0m  [36;1m[0.26ms][0m  SELECT count(*) FROM `tags`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 17:43:54][0m  [36;1m[0.53ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 17:43:54][0m  [36;1m[0.67ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 17:43:54][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 17:43:54][0m  [36;1m[0.29ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 17:43:54][0m  [36;1m[0.27ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 17:43:54][0m  [36;1m[0.32ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 17:43:56][0m  [36;1m[0.55ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 17:43:56][0m  [36;1m[0.30ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 17:43:56][0m  [36;1m[0.73ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-20 17:43:56][0m  [36;1m[0.22ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-20 17:43:57][0m  [36;1m[0.57ms][0m  SELECT * FROM `tags`    
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 17:43:57][0m  [36;1m[0.30ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 17:43:57][0m  [36;1m[0.83ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:31)[0m 
[33m[2020-07-20 17:43:57][0m  [36;1m[0.22ms][0m  SELECT count(*) FROM `tags`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 17:43:58][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 17:43:58][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:137)[0m 
[33m[2020-07-20 17:43:58][0m  [36;1m[2.59ms][0m   SELECT * FROM `blogs` GROUP BY YEAR DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:150)[0m 
[33m[2020-07-20 17:43:58][0m  [36;1m[0.67ms][0m   SELECT * FROM `blogs` where year = 2020 GROUP BY month DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:162)[0m 
[33m[2020-07-20 17:43:58][0m  [36;1m[0.66ms][0m   SELECT * FROM `blogs` where year = 2020 and month = 7 ORDER BY `id` DESC  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 17:43:58][0m  [36;1m[0.40ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=4  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 17:43:58][0m  [36;1m[0.33ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=3  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 17:43:58][0m  [36;1m[0.33ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=2  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 17:43:58][0m  [36;1m[0.34ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 17:43:58][0m  [36;1m[0.53ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 17:43:59][0m  [36;1m[0.61ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 17:43:59][0m  [36;1m[0.27ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:137)[0m 
[33m[2020-07-20 17:43:59][0m  [36;1m[0.65ms][0m   SELECT * FROM `blogs` GROUP BY YEAR DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:150)[0m 
[33m[2020-07-20 17:43:59][0m  [36;1m[0.65ms][0m   SELECT * FROM `blogs` where year = 2020 GROUP BY month DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:162)[0m 
[33m[2020-07-20 17:43:59][0m  [36;1m[0.59ms][0m   SELECT * FROM `blogs` where year = 2020 and month = 7 ORDER BY `id` DESC  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 17:43:59][0m  [36;1m[0.40ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=4  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 17:43:59][0m  [36;1m[0.35ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=3  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 17:43:59][0m  [36;1m[0.35ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=2  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 17:43:59][0m  [36;1m[0.36ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-20 17:44:00][0m  [36;1m[0.57ms][0m  SELECT * FROM `tags`    
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 17:44:00][0m  [36;1m[0.25ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 17:44:00][0m  [36;1m[0.66ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:31)[0m 
[33m[2020-07-20 17:44:00][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `tags`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 17:44:00][0m  [36;1m[0.54ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 17:44:00][0m  [36;1m[0.26ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 17:44:00][0m  [36;1m[0.69ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-20 17:44:00][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 17:44:01][0m  [36;1m[0.56ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 17:44:01][0m  [36;1m[0.70ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 17:44:01][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 17:44:01][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 17:44:01][0m  [36;1m[0.25ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 17:44:01][0m  [36;1m[0.31ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 17:53:27][0m  [36;1m[0.59ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 17:53:27][0m  [36;1m[0.23ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 17:53:27][0m  [36;1m[0.73ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-20 17:53:27][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 17:54:54][0m  [36;1m[0.58ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 17:54:54][0m  [36;1m[0.82ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 17:54:54][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 17:54:54][0m  [36;1m[0.38ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 17:54:54][0m  [36;1m[0.31ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 17:54:54][0m  [36;1m[0.38ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-20 17:54:56][0m  [36;1m[0.63ms][0m  SELECT * FROM `tags`    
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 17:54:56][0m  [36;1m[0.29ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 17:54:56][0m  [36;1m[0.73ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:31)[0m 
[33m[2020-07-20 17:54:56][0m  [36;1m[0.23ms][0m  SELECT count(*) FROM `tags`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 17:54:57][0m  [36;1m[0.57ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 17:54:57][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:137)[0m 
[33m[2020-07-20 17:54:57][0m  [36;1m[0.62ms][0m   SELECT * FROM `blogs` GROUP BY YEAR DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:150)[0m 
[33m[2020-07-20 17:54:57][0m  [36;1m[0.84ms][0m   SELECT * FROM `blogs` where year = 2020 GROUP BY month DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:162)[0m 
[33m[2020-07-20 17:54:57][0m  [36;1m[0.60ms][0m   SELECT * FROM `blogs` where year = 2020 and month = 7 ORDER BY `id` DESC  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 17:54:57][0m  [36;1m[0.37ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=4  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 17:54:57][0m  [36;1m[0.33ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=3  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 17:54:57][0m  [36;1m[0.35ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=2  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 17:54:57][0m  [36;1m[0.32ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 17:54:58][0m  [36;1m[0.57ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 17:55:09][0m  [36;1m[0.53ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 17:55:09][0m  [36;1m[0.69ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 17:55:09][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 17:55:09][0m  [36;1m[0.36ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 17:55:09][0m  [36;1m[0.27ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 17:55:09][0m  [36;1m[0.32ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 17:55:30][0m  [36;1m[0.57ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 17:55:30][0m  [36;1m[0.22ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:137)[0m 
[33m[2020-07-20 17:55:30][0m  [36;1m[0.65ms][0m   SELECT * FROM `blogs` GROUP BY YEAR DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:150)[0m 
[33m[2020-07-20 17:55:30][0m  [36;1m[0.68ms][0m   SELECT * FROM `blogs` where year = 2020 GROUP BY month DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:162)[0m 
[33m[2020-07-20 17:55:30][0m  [36;1m[0.60ms][0m   SELECT * FROM `blogs` where year = 2020 and month = 7 ORDER BY `id` DESC  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 17:55:30][0m  [36;1m[0.37ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=4  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 17:55:30][0m  [36;1m[0.33ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=3  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 17:55:30][0m  [36;1m[0.36ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=2  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 17:55:30][0m  [36;1m[0.40ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 17:55:31][0m  [36;1m[0.62ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 17:55:51][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 17:55:51][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:137)[0m 
[33m[2020-07-20 17:55:51][0m  [36;1m[0.66ms][0m   SELECT * FROM `blogs` GROUP BY YEAR DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:150)[0m 
[33m[2020-07-20 17:55:51][0m  [36;1m[2.45ms][0m   SELECT * FROM `blogs` where year = 2020 GROUP BY month DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:162)[0m 
[33m[2020-07-20 17:55:51][0m  [36;1m[0.96ms][0m   SELECT * FROM `blogs` where year = 2020 and month = 7 ORDER BY `id` DESC  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 17:55:51][0m  [36;1m[0.57ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=4  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 17:55:51][0m  [36;1m[0.49ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=3  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 17:55:51][0m  [36;1m[0.47ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=2  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 17:55:51][0m  [36;1m[0.49ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-20 17:55:53][0m  [36;1m[0.57ms][0m  SELECT * FROM `tags`    
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 17:55:53][0m  [36;1m[0.26ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 17:55:53][0m  [36;1m[0.73ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:31)[0m 
[33m[2020-07-20 17:55:53][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `tags`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 17:55:54][0m  [36;1m[0.56ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 17:55:54][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:137)[0m 
[33m[2020-07-20 17:55:54][0m  [36;1m[0.60ms][0m   SELECT * FROM `blogs` GROUP BY YEAR DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:150)[0m 
[33m[2020-07-20 17:55:54][0m  [36;1m[0.64ms][0m   SELECT * FROM `blogs` where year = 2020 GROUP BY month DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:162)[0m 
[33m[2020-07-20 17:55:54][0m  [36;1m[0.60ms][0m   SELECT * FROM `blogs` where year = 2020 and month = 7 ORDER BY `id` DESC  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 17:55:54][0m  [36;1m[0.37ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=4  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 17:55:54][0m  [36;1m[0.33ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=3  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 17:55:54][0m  [36;1m[0.31ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=2  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 17:55:54][0m  [36;1m[0.33ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 17:56:04][0m  [36;1m[0.61ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 17:56:04][0m  [36;1m[0.74ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 17:56:04][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 17:56:04][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 17:56:04][0m  [36;1m[0.25ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 17:56:04][0m  [36;1m[0.32ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 17:58:21][0m  [36;1m[0.94ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 17:58:21][0m  [36;1m[2.56ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 17:58:21][0m  [36;1m[0.22ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 17:58:21][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 17:58:21][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 17:58:21][0m  [36;1m[0.34ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 17:58:47][0m  [36;1m[0.56ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 17:58:47][0m  [36;1m[0.77ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 17:58:47][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 17:58:47][0m  [36;1m[0.31ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 17:58:47][0m  [36;1m[0.27ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 17:58:47][0m  [36;1m[0.33ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 17:59:53][0m  [36;1m[0.75ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 17:59:53][0m  [36;1m[0.82ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 17:59:53][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 17:59:53][0m  [36;1m[0.33ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 17:59:53][0m  [36;1m[0.35ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 17:59:53][0m  [36;1m[0.46ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 18:00:02][0m  [36;1m[0.56ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 18:00:02][0m  [36;1m[0.70ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 18:00:02][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 18:00:02][0m  [36;1m[1.90ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 18:00:02][0m  [36;1m[0.25ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 18:00:02][0m  [36;1m[0.33ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 18:11:31][0m  [36;1m[0.53ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 18:11:31][0m  [36;1m[0.29ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 18:11:31][0m  [36;1m[0.66ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-20 18:11:31][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-20 18:11:32][0m  [36;1m[0.57ms][0m  SELECT * FROM `tags`    
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 18:11:32][0m  [36;1m[0.24ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 18:11:32][0m  [36;1m[0.69ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:31)[0m 
[33m[2020-07-20 18:11:32][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `tags`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 18:11:33][0m  [36;1m[0.52ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 18:11:33][0m  [36;1m[0.25ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 18:11:33][0m  [36;1m[0.65ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-20 18:11:33][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 18:11:34][0m  [36;1m[0.56ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 18:11:34][0m  [36;1m[0.68ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 18:11:34][0m  [36;1m[0.18ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 18:11:34][0m  [36;1m[0.28ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 18:11:34][0m  [36;1m[0.25ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 18:11:34][0m  [36;1m[0.30ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-20 18:11:36][0m  [36;1m[0.37ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 4)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-20 18:11:36][0m  [36;1m[0.45ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=4  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-20 18:11:36][0m  [36;1m[0.45ms][0m  UPDATE `blogs` SET `title` = '本博客开源公告', `content` = '今天本博客评论功能发布
# 自今天起，本博客基本功能已经完成
## 发布V1.0版本并开源
## 博客语言说明
#### 本博客后端是用golang 的gin框架+gorm编写
前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的
#### 博客效果参考本站
#一、博客简介
## 1.博客目录

    blog
    ├────controller
	├────└───admin
	|	|	├──adminblog.go
	|	|	├───adminController.go
	|	|	├──adminTag.go
	|	|	├──adminType.go
	|	|	└──adminUser.go
	|	└──page
	|		├──404.go
	|		├───about.go
	|		├──archives.go
	|		├──blog.go
	|		├──comment.go
	|		├──pagesController.go
	|		├──researchController.go
	|		└──tagsController.go
    ├── dao
	│	├──blogs.go
	│	├──comment.go
	│	├──sql.go
	│	├──tags.go
	│	├──types.go
	│	└──user.go
    ├── logic
    │   └── user.go
    ├── middlerware
	│	├──function.go
	│	├──getImg.go
	│	├──getTime.go
	│	├──markdown.go
	│	├──select.go
	│	└──session.go
    ├── model
	│	├──blog.go
	│	├──commnent.go
	│	├──tag.go
	│	├──type.go
	│	└──user/go
    ├── static
	│	└──静态文件（头像、图片、logo、css、js等）
    ├── templates
	│	└──html模板文件
    ├── go.mod（依赖）
    └── main.go
    

## 2.相关功能实现简介
### 1、评论及回复功能
comment的结构体属性如下
```go
package model

type Comment struct {
	Id     int //评论id
	BlogId int //博文id
	ReCommentId    int    //父评论id
	CommentName string //评论人姓名
	ReCommentName  string //父评论人姓名
	CommentEmail   string
	Img            string
	CommentContent string `gorm:"type:text" form:"CommentContent" json:"CommentContent"` //评论内容
	CommentTime    string ` json:"comment_time,omitempty"`
	Parent         *Comment
	Comments       []Comment
}
```
#### 实现方法
##### 1先通过查找父评论为-1的顶级评论
父评论Id为-1说明他不是任何评论的子评论
##### 2在html上遍历所有的顶级评论
在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论
###### （1）递归存储每个顶级评论的子评论
这里我用一个切片来储存一个顶级评论的所有子评论
```go
var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
	var comments []model.Comment
	DB.Debug().Where("re_comment_id = -1 AND blog_id = ?", id).Find(&comments)
	return &comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
	if count != 0 {
		fmt.Println("if判断1")
		var comments []model.Comment
		DB.Debug().Where("re_comment_id = ?", id).Find(&comments)
		count = len(comments)
		if count != 0 {
			fmt.Println("if判断2")
			for _, comment := range comments {
				fmt.Println("for判断1")
				Comments = append(Comments, comment)
				SelectCommentByComment(comment.Id, count)
			}
		}
	}
	fmt.Println(Comments)
	return &Comments

}
```
ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来
###### （2）出现问题的原因
因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量
###### （3）解决问题
```go
func ClearComments() bool {
	var comments []model.Comment
	Comments = comments
	return true
}

```
这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现
#### 这里我还加了一个小小的随机头像功能
```go
if  CommentName == user.Name && CommentEmail == user.UserEmail {
		fmt.Println("进入了1")
		comment.Img =user.UserImg
		//找相同评论人
	}else if CommentName == one.CommentName && CommentEmail == one.CommentEmail {
		fmt.Println("进入了2")
		comment.Img =one.Img
		//随机选头像
	}else{
		fmt.Println("进入了3")
		comment.Img =middleware.GetImg()
	}
```
##### 123分别代表三种不同的用户群体
1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
![](/static/images/%e5%a4%b4%e5%83%8f1.png)![](/static/images/%e5%a4%b4%e5%83%8f2.png)![](/static/images/%e5%a4%b4%e5%83%8f3.png)![](/static/images/%e5%a4%b4%e5%83%8f4.png)![](/static/images/%e5%a4%b4%e5%83%8f5.png)![](/static/images/%e5%a4%b4%e5%83%8f6.png)
### 2、归档功能
#### blog的结构体属性如下
```go
package model

type Blog struct {
	Id           int
	Title        string    `form:"title" json:"title"`                          //标题
	Content      string    `gorm:"type:longtext" form:"content" json:"content"` //内容
	Image        string    `gorm:"type:text" form:"image" json:"image"`         //首图
	Numb         int       `form:"numb" json:"numb"`                            //次数
	Flag         string    `form:"flag" json:"flag"`                            //原创或者转载
	Appreciation string    `form:"appreciation" json:"appreciation"`            //打赏开关
	ShareInfo    string    `form:"shareInfo" json:"shareInfo"`                  //版权开关
	Comment      string    `form:"comment" json:"comment"`                      //评论开关
	Recommend    string    `form:"recommend" json:"recommend"`                  //推荐开关
	Description  string    `gorm:"type:text" form:"description" json:"description"`
	CreatTime    string    `form:"creatTime"  json:"creat_time,omitempty"`   //创建时间
	UpdateTime   string    `form:"updateTime"  json:"update_time,omitempty"` //更新时间
	Comments     []Comment `form:"comments" json:"comments"`
	TypeId       int       `form:"typeId" json:"typeId"`
	Type         Type      `form:"type" gorm:"ForeignKey:TypeId"`
	Year         int       `form:"year" json:"year"`
	Month        int       `form:"month" json:"month"`
	Day          int       `form:"day" json:"day"`
}

```
#### 实现方法
我的思路是创建三个时间节点
year month day 
利用sql分组查询
##### Group By分组查询步骤
###### （1）先按照年份查询
###### （2）再按照年份遍历每个月份
并将所有保存在一个切片中
###### （3）按照月份遍历每个月的所有文章
保存在一个Map中，key是对应的月份，value是每个月份的所有文章
#### 自此归档功能实现


## 3.已知BUG
### 后台退出功能
后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧

开源地址
[github](https://github.com/likewl/blog "github")
[gitee](https://gitee.com/nculike/blog "gitee")', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1535821573,4166447487&fm=26&gp=0.jpg', `numb` = 2, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '本博客后端是用golang 的gin框架+gorm编写', `creat_time` = '2020-07-20 15:24:23', `update_time` = '2020-07-20 15:24:23', `type_id` = 4, `year` = 2020, `month` = 7, `day` = 20  WHERE `blogs`.`id` = 4  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 18:11:36][0m  [36;1m[0.34ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 19:12:15][0m  [36;1m[0.53ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 19:12:15][0m  [36;1m[0.70ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 19:12:15][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 19:12:15][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 19:12:15][0m  [36;1m[0.25ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 19:12:15][0m  [36;1m[0.31ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-20 19:12:17][0m  [36;1m[0.36ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 4)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-20 19:12:17][0m  [36;1m[0.42ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=4  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-20 19:12:17][0m  [36;1m[0.43ms][0m  UPDATE `blogs` SET `title` = '本博客开源公告', `content` = '今天本博客评论功能发布
# 自今天起，本博客基本功能已经完成
## 发布V1.0版本并开源
## 博客语言说明
#### 本博客后端是用golang 的gin框架+gorm编写
前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的
#### 博客效果参考本站
#一、博客简介
## 1.博客目录

    blog
    ├────controller
	├────└───admin
	|	|	├──adminblog.go
	|	|	├───adminController.go
	|	|	├──adminTag.go
	|	|	├──adminType.go
	|	|	└──adminUser.go
	|	└──page
	|		├──404.go
	|		├───about.go
	|		├──archives.go
	|		├──blog.go
	|		├──comment.go
	|		├──pagesController.go
	|		├──researchController.go
	|		└──tagsController.go
    ├── dao
	│	├──blogs.go
	│	├──comment.go
	│	├──sql.go
	│	├──tags.go
	│	├──types.go
	│	└──user.go
    ├── logic
    │   └── user.go
    ├── middlerware
	│	├──function.go
	│	├──getImg.go
	│	├──getTime.go
	│	├──markdown.go
	│	├──select.go
	│	└──session.go
    ├── model
	│	├──blog.go
	│	├──commnent.go
	│	├──tag.go
	│	├──type.go
	│	└──user/go
    ├── static
	│	└──静态文件（头像、图片、logo、css、js等）
    ├── templates
	│	└──html模板文件
    ├── go.mod（依赖）
    └── main.go
    

## 2.相关功能实现简介
### 1、评论及回复功能
comment的结构体属性如下
```go
package model

type Comment struct {
	Id     int //评论id
	BlogId int //博文id
	ReCommentId    int    //父评论id
	CommentName string //评论人姓名
	ReCommentName  string //父评论人姓名
	CommentEmail   string
	Img            string
	CommentContent string `gorm:"type:text" form:"CommentContent" json:"CommentContent"` //评论内容
	CommentTime    string ` json:"comment_time,omitempty"`
	Parent         *Comment
	Comments       []Comment
}
```
#### 实现方法
##### 1先通过查找父评论为-1的顶级评论
父评论Id为-1说明他不是任何评论的子评论
##### 2在html上遍历所有的顶级评论
在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论
###### （1）递归存储每个顶级评论的子评论
这里我用一个切片来储存一个顶级评论的所有子评论
```go
var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
	var comments []model.Comment
	DB.Debug().Where("re_comment_id = -1 AND blog_id = ?", id).Find(&comments)
	return &comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
	if count != 0 {
		fmt.Println("if判断1")
		var comments []model.Comment
		DB.Debug().Where("re_comment_id = ?", id).Find(&comments)
		count = len(comments)
		if count != 0 {
			fmt.Println("if判断2")
			for _, comment := range comments {
				fmt.Println("for判断1")
				Comments = append(Comments, comment)
				SelectCommentByComment(comment.Id, count)
			}
		}
	}
	fmt.Println(Comments)
	return &Comments

}
```
ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来
###### （2）出现问题的原因
因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量
###### （3）解决问题
```go
func ClearComments() bool {
	var comments []model.Comment
	Comments = comments
	return true
}

```
这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现
#### 这里我还加了一个小小的随机头像功能
```go
if  CommentName == user.Name && CommentEmail == user.UserEmail {
		fmt.Println("进入了1")
		comment.Img =user.UserImg
		//找相同评论人
	}else if CommentName == one.CommentName && CommentEmail == one.CommentEmail {
		fmt.Println("进入了2")
		comment.Img =one.Img
		//随机选头像
	}else{
		fmt.Println("进入了3")
		comment.Img =middleware.GetImg()
	}
```
##### 123分别代表三种不同的用户群体
1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
![](/static/images/%e5%a4%b4%e5%83%8f1.png)![](/static/images/%e5%a4%b4%e5%83%8f2.png)![](/static/images/%e5%a4%b4%e5%83%8f3.png)![](/static/images/%e5%a4%b4%e5%83%8f4.png)![](/static/images/%e5%a4%b4%e5%83%8f5.png)![](/static/images/%e5%a4%b4%e5%83%8f6.png)
### 2、归档功能
#### blog的结构体属性如下
```go
package model

type Blog struct {
	Id           int
	Title        string    `form:"title" json:"title"`                          //标题
	Content      string    `gorm:"type:longtext" form:"content" json:"content"` //内容
	Image        string    `gorm:"type:text" form:"image" json:"image"`         //首图
	Numb         int       `form:"numb" json:"numb"`                            //次数
	Flag         string    `form:"flag" json:"flag"`                            //原创或者转载
	Appreciation string    `form:"appreciation" json:"appreciation"`            //打赏开关
	ShareInfo    string    `form:"shareInfo" json:"shareInfo"`                  //版权开关
	Comment      string    `form:"comment" json:"comment"`                      //评论开关
	Recommend    string    `form:"recommend" json:"recommend"`                  //推荐开关
	Description  string    `gorm:"type:text" form:"description" json:"description"`
	CreatTime    string    `form:"creatTime"  json:"creat_time,omitempty"`   //创建时间
	UpdateTime   string    `form:"updateTime"  json:"update_time,omitempty"` //更新时间
	Comments     []Comment `form:"comments" json:"comments"`
	TypeId       int       `form:"typeId" json:"typeId"`
	Type         Type      `form:"type" gorm:"ForeignKey:TypeId"`
	Year         int       `form:"year" json:"year"`
	Month        int       `form:"month" json:"month"`
	Day          int       `form:"day" json:"day"`
}

```
#### 实现方法
我的思路是创建三个时间节点
year month day 
利用sql分组查询
##### Group By分组查询步骤
###### （1）先按照年份查询
###### （2）再按照年份遍历每个月份
并将所有保存在一个切片中
###### （3）按照月份遍历每个月的所有文章
保存在一个Map中，key是对应的月份，value是每个月份的所有文章
#### 自此归档功能实现


## 3.已知BUG
### 后台退出功能
后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧

开源地址
[github](https://github.com/likewl/blog "github")
[gitee](https://gitee.com/nculike/blog "gitee")', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1535821573,4166447487&fm=26&gp=0.jpg', `numb` = 3, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '本博客后端是用golang 的gin框架+gorm编写', `creat_time` = '2020-07-20 15:24:23', `update_time` = '2020-07-20 15:24:23', `type_id` = 4, `year` = 2020, `month` = 7, `day` = 20  WHERE `blogs`.`id` = 4  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 19:12:17][0m  [36;1m[0.26ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-20 19:13:50][0m  [36;1m[0.41ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 4)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-20 19:13:50][0m  [36;1m[0.46ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=4  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-20 19:13:50][0m  [36;1m[0.48ms][0m  UPDATE `blogs` SET `title` = '本博客开源公告', `content` = '今天本博客评论功能发布
# 自今天起，本博客基本功能已经完成
## 发布V1.0版本并开源
## 博客语言说明
#### 本博客后端是用golang 的gin框架+gorm编写
前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的
#### 博客效果参考本站
#一、博客简介
## 1.博客目录

    blog
    ├────controller
	├────└───admin
	|	|	├──adminblog.go
	|	|	├───adminController.go
	|	|	├──adminTag.go
	|	|	├──adminType.go
	|	|	└──adminUser.go
	|	└──page
	|		├──404.go
	|		├───about.go
	|		├──archives.go
	|		├──blog.go
	|		├──comment.go
	|		├──pagesController.go
	|		├──researchController.go
	|		└──tagsController.go
    ├── dao
	│	├──blogs.go
	│	├──comment.go
	│	├──sql.go
	│	├──tags.go
	│	├──types.go
	│	└──user.go
    ├── logic
    │   └── user.go
    ├── middlerware
	│	├──function.go
	│	├──getImg.go
	│	├──getTime.go
	│	├──markdown.go
	│	├──select.go
	│	└──session.go
    ├── model
	│	├──blog.go
	│	├──commnent.go
	│	├──tag.go
	│	├──type.go
	│	└──user/go
    ├── static
	│	└──静态文件（头像、图片、logo、css、js等）
    ├── templates
	│	└──html模板文件
    ├── go.mod（依赖）
    └── main.go
    

## 2.相关功能实现简介
### 1、评论及回复功能
comment的结构体属性如下
```go
package model

type Comment struct {
	Id     int //评论id
	BlogId int //博文id
	ReCommentId    int    //父评论id
	CommentName string //评论人姓名
	ReCommentName  string //父评论人姓名
	CommentEmail   string
	Img            string
	CommentContent string `gorm:"type:text" form:"CommentContent" json:"CommentContent"` //评论内容
	CommentTime    string ` json:"comment_time,omitempty"`
	Parent         *Comment
	Comments       []Comment
}
```
#### 实现方法
##### 1先通过查找父评论为-1的顶级评论
父评论Id为-1说明他不是任何评论的子评论
##### 2在html上遍历所有的顶级评论
在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论
###### （1）递归存储每个顶级评论的子评论
这里我用一个切片来储存一个顶级评论的所有子评论
```go
var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
	var comments []model.Comment
	DB.Debug().Where("re_comment_id = -1 AND blog_id = ?", id).Find(&comments)
	return &comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
	if count != 0 {
		fmt.Println("if判断1")
		var comments []model.Comment
		DB.Debug().Where("re_comment_id = ?", id).Find(&comments)
		count = len(comments)
		if count != 0 {
			fmt.Println("if判断2")
			for _, comment := range comments {
				fmt.Println("for判断1")
				Comments = append(Comments, comment)
				SelectCommentByComment(comment.Id, count)
			}
		}
	}
	fmt.Println(Comments)
	return &Comments

}
```
ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来
###### （2）出现问题的原因
因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量
###### （3）解决问题
```go
func ClearComments() bool {
	var comments []model.Comment
	Comments = comments
	return true
}

```
这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现
#### 这里我还加了一个小小的随机头像功能
```go
if  CommentName == user.Name && CommentEmail == user.UserEmail {
		fmt.Println("进入了1")
		comment.Img =user.UserImg
		//找相同评论人
	}else if CommentName == one.CommentName && CommentEmail == one.CommentEmail {
		fmt.Println("进入了2")
		comment.Img =one.Img
		//随机选头像
	}else{
		fmt.Println("进入了3")
		comment.Img =middleware.GetImg()
	}
```
##### 123分别代表三种不同的用户群体
1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
![](/static/images/%e5%a4%b4%e5%83%8f1.png)![](/static/images/%e5%a4%b4%e5%83%8f2.png)![](/static/images/%e5%a4%b4%e5%83%8f3.png)![](/static/images/%e5%a4%b4%e5%83%8f4.png)![](/static/images/%e5%a4%b4%e5%83%8f5.png)![](/static/images/%e5%a4%b4%e5%83%8f6.png)
### 2、归档功能
#### blog的结构体属性如下
```go
package model

type Blog struct {
	Id           int
	Title        string    `form:"title" json:"title"`                          //标题
	Content      string    `gorm:"type:longtext" form:"content" json:"content"` //内容
	Image        string    `gorm:"type:text" form:"image" json:"image"`         //首图
	Numb         int       `form:"numb" json:"numb"`                            //次数
	Flag         string    `form:"flag" json:"flag"`                            //原创或者转载
	Appreciation string    `form:"appreciation" json:"appreciation"`            //打赏开关
	ShareInfo    string    `form:"shareInfo" json:"shareInfo"`                  //版权开关
	Comment      string    `form:"comment" json:"comment"`                      //评论开关
	Recommend    string    `form:"recommend" json:"recommend"`                  //推荐开关
	Description  string    `gorm:"type:text" form:"description" json:"description"`
	CreatTime    string    `form:"creatTime"  json:"creat_time,omitempty"`   //创建时间
	UpdateTime   string    `form:"updateTime"  json:"update_time,omitempty"` //更新时间
	Comments     []Comment `form:"comments" json:"comments"`
	TypeId       int       `form:"typeId" json:"typeId"`
	Type         Type      `form:"type" gorm:"ForeignKey:TypeId"`
	Year         int       `form:"year" json:"year"`
	Month        int       `form:"month" json:"month"`
	Day          int       `form:"day" json:"day"`
}

```
#### 实现方法
我的思路是创建三个时间节点
year month day 
利用sql分组查询
##### Group By分组查询步骤
###### （1）先按照年份查询
###### （2）再按照年份遍历每个月份
并将所有保存在一个切片中
###### （3）按照月份遍历每个月的所有文章
保存在一个Map中，key是对应的月份，value是每个月份的所有文章
#### 自此归档功能实现


## 3.已知BUG
### 后台退出功能
后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧

开源地址
[github](https://github.com/likewl/blog "github")
[gitee](https://gitee.com/nculike/blog "gitee")', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1535821573,4166447487&fm=26&gp=0.jpg', `numb` = 4, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '本博客后端是用golang 的gin框架+gorm编写', `creat_time` = '2020-07-20 15:24:23', `update_time` = '2020-07-20 15:24:23', `type_id` = 4, `year` = 2020, `month` = 7, `day` = 20  WHERE `blogs`.`id` = 4  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 19:13:50][0m  [36;1m[0.36ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 19:17:35][0m  [36;1m[0.64ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 19:17:35][0m  [36;1m[0.52ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 19:17:38][0m  [36;1m[0.56ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 19:17:38][0m  [36;1m[0.58ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 19:17:38][0m  [36;1m[0.70ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 19:17:38][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 19:17:38][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 19:17:38][0m  [36;1m[0.34ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 19:17:38][0m  [36;1m[0.33ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 19:17:38][0m  [36;1m[0.50ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 20:01:18][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 20:01:18][0m  [36;1m[0.72ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 20:01:18][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 20:01:18][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 20:01:18][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 20:01:18][0m  [36;1m[0.32ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 20:01:57][0m  [36;1m[0.93ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 20:04:33][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 20:04:33][0m  [36;1m[0.68ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 20:04:33][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 20:04:33][0m  [36;1m[0.32ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 20:04:33][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 20:04:33][0m  [36;1m[0.34ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 
[GIN-debug] [WARNING] Running in "debug" mode. Switch to "release" mode in production.
 - using env:	export GIN_MODE=release
 - using code:	gin.SetMode(gin.ReleaseMode)

[GIN-debug] GET    /static/*filepath         --> github.com/gin-gonic/gin.(*RouterGroup).createStaticHandler.func1 (2 handlers)
[GIN-debug] HEAD   /static/*filepath         --> github.com/gin-gonic/gin.(*RouterGroup).createStaticHandler.func1 (2 handlers)
[GIN-debug] Loaded HTML Templates (30): 
	- 
	- tags-edit.html
	- types-input.html
	- archives.html
	- header1.html
	- admin/index.html
	- user-edit.html
	- footer1.html
	- pages/index.html
	- tag.html
	- research.html
	- 404.html
	- footer1
	- tags.html
	- types.html
	- admin/types.html
	- blogs-edit.html
	- blogs-input.html
	- blogs.html
	- header
	- tags-input.html
	- type.html
	- header.html
	- admin/tags.html
	- blog.html
	- index.html
	- login.html
	- types-edit.html
	- about.html
	- header1

[GIN-debug] GET    /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] POST   /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] PUT    /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] PATCH  /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] HEAD   /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] OPTIONS /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] DELETE /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] CONNECT /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] TRACE  /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] GET    /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] POST   /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] PUT    /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] PATCH  /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] HEAD   /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] OPTIONS /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] DELETE /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] CONNECT /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] TRACE  /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] GET    /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] POST   /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] PUT    /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] PATCH  /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] HEAD   /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] OPTIONS /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] DELETE /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] CONNECT /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] TRACE  /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] GET    /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] POST   /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] PUT    /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] PATCH  /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] HEAD   /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] OPTIONS /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] DELETE /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] CONNECT /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] TRACE  /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] GET    /types                    --> blog/controller/page.TypesHandler (2 handlers)
[GIN-debug] GET    /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] POST   /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] PUT    /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] PATCH  /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] HEAD   /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] OPTIONS /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] DELETE /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] CONNECT /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] TRACE  /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] GET    /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] POST   /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] PUT    /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] PATCH  /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] HEAD   /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] OPTIONS /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] DELETE /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] CONNECT /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] TRACE  /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] GET    /tags                     --> blog/controller/page.TagsHandler (2 handlers)
[GIN-debug] GET    /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] POST   /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] PUT    /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] PATCH  /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] HEAD   /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] OPTIONS /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] DELETE /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] CONNECT /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] TRACE  /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] GET    /archives                 --> blog/controller/page.ArchivesHandler (2 handlers)
[GIN-debug] GET    /about                    --> blog/controller/page.AboutHandler (2 handlers)
[GIN-debug] GET    /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] POST   /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] PUT    /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] PATCH  /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] HEAD   /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] OPTIONS /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] DELETE /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] CONNECT /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] TRACE  /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] GET    /admin/logout             --> blog/controller/admin.LogoutHandler (2 handlers)
[GIN-debug] GET    /admin/                   --> blog/controller/admin.AdminHandler (3 handlers)
[GIN-debug] GET    /admin/index              --> blog/controller/admin.AdminIndexHandler (3 handlers)
[GIN-debug] GET    /admin/type/              --> blog/controller/admin.TypeHandler (3 handlers)
[GIN-debug] GET    /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] POST   /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] PUT    /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] PATCH  /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] HEAD   /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] OPTIONS /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] DELETE /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] CONNECT /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] TRACE  /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] GET    /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] POST   /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] PUT    /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] PATCH  /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] HEAD   /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] OPTIONS /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] DELETE /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] CONNECT /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] TRACE  /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] GET    /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] POST   /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] PUT    /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] PATCH  /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] HEAD   /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] OPTIONS /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] DELETE /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] CONNECT /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] TRACE  /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] GET    /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] POST   /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] PUT    /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] PATCH  /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] HEAD   /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] OPTIONS /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] DELETE /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] CONNECT /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] TRACE  /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] GET    /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] POST   /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] PUT    /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] PATCH  /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] HEAD   /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] OPTIONS /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] DELETE /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] CONNECT /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] TRACE  /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] GET    /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] POST   /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] PUT    /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] PATCH  /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] HEAD   /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] OPTIONS /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] DELETE /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] CONNECT /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] TRACE  /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] GET    /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] POST   /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] PUT    /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] PATCH  /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] HEAD   /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] OPTIONS /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] DELETE /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] CONNECT /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] TRACE  /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] GET    /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] POST   /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] PUT    /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] PATCH  /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] HEAD   /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] OPTIONS /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] DELETE /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] CONNECT /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] TRACE  /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] GET    /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] POST   /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] PUT    /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] PATCH  /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] HEAD   /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] OPTIONS /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] DELETE /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] CONNECT /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] TRACE  /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] Listening and serving HTTP on :8080

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 20:09:44][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 20:09:44][0m  [36;1m[0.74ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 20:09:44][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 20:09:44][0m  [36;1m[0.36ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 20:09:44][0m  [36;1m[0.25ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 20:09:44][0m  [36;1m[0.35ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-20 20:09:46][0m  [36;1m[0.40ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 4)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-20 20:09:46][0m  [36;1m[0.44ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=4  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-20 20:09:46][0m  [36;1m[0.51ms][0m  UPDATE `blogs` SET `title` = '本博客开源公告', `content` = '今天本博客评论功能发布
# 自今天起，本博客基本功能已经完成
## 发布V1.0版本并开源
## 博客语言说明
#### 本博客后端是用golang 的gin框架+gorm编写
前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的
#### 博客效果参考本站
#一、博客简介
## 1.博客目录

    blog
    ├────controller
	├────└───admin
	|	|	├──adminblog.go
	|	|	├───adminController.go
	|	|	├──adminTag.go
	|	|	├──adminType.go
	|	|	└──adminUser.go
	|	└──page
	|		├──404.go
	|		├───about.go
	|		├──archives.go
	|		├──blog.go
	|		├──comment.go
	|		├──pagesController.go
	|		├──researchController.go
	|		└──tagsController.go
    ├── dao
	│	├──blogs.go
	│	├──comment.go
	│	├──sql.go
	│	├──tags.go
	│	├──types.go
	│	└──user.go
    ├── logic
    │   └── user.go
    ├── middlerware
	│	├──function.go
	│	├──getImg.go
	│	├──getTime.go
	│	├──markdown.go
	│	├──select.go
	│	└──session.go
    ├── model
	│	├──blog.go
	│	├──commnent.go
	│	├──tag.go
	│	├──type.go
	│	└──user/go
    ├── static
	│	└──静态文件（头像、图片、logo、css、js等）
    ├── templates
	│	└──html模板文件
    ├── go.mod（依赖）
    └── main.go
    

## 2.相关功能实现简介
### 1、评论及回复功能
comment的结构体属性如下
```go
package model

type Comment struct {
	Id     int //评论id
	BlogId int //博文id
	ReCommentId    int    //父评论id
	CommentName string //评论人姓名
	ReCommentName  string //父评论人姓名
	CommentEmail   string
	Img            string
	CommentContent string `gorm:"type:text" form:"CommentContent" json:"CommentContent"` //评论内容
	CommentTime    string ` json:"comment_time,omitempty"`
	Parent         *Comment
	Comments       []Comment
}
```
#### 实现方法
##### 1先通过查找父评论为-1的顶级评论
父评论Id为-1说明他不是任何评论的子评论
##### 2在html上遍历所有的顶级评论
在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论
###### （1）递归存储每个顶级评论的子评论
这里我用一个切片来储存一个顶级评论的所有子评论
```go
var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
	var comments []model.Comment
	DB.Debug().Where("re_comment_id = -1 AND blog_id = ?", id).Find(&comments)
	return &comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
	if count != 0 {
		fmt.Println("if判断1")
		var comments []model.Comment
		DB.Debug().Where("re_comment_id = ?", id).Find(&comments)
		count = len(comments)
		if count != 0 {
			fmt.Println("if判断2")
			for _, comment := range comments {
				fmt.Println("for判断1")
				Comments = append(Comments, comment)
				SelectCommentByComment(comment.Id, count)
			}
		}
	}
	fmt.Println(Comments)
	return &Comments

}
```
ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来
###### （2）出现问题的原因
因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量
###### （3）解决问题
```go
func ClearComments() bool {
	var comments []model.Comment
	Comments = comments
	return true
}

```
这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现
#### 这里我还加了一个小小的随机头像功能
```go
if  CommentName == user.Name && CommentEmail == user.UserEmail {
		fmt.Println("进入了1")
		comment.Img =user.UserImg
		//找相同评论人
	}else if CommentName == one.CommentName && CommentEmail == one.CommentEmail {
		fmt.Println("进入了2")
		comment.Img =one.Img
		//随机选头像
	}else{
		fmt.Println("进入了3")
		comment.Img =middleware.GetImg()
	}
```
##### 123分别代表三种不同的用户群体
1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
![](/static/images/%e5%a4%b4%e5%83%8f1.png)![](/static/images/%e5%a4%b4%e5%83%8f2.png)![](/static/images/%e5%a4%b4%e5%83%8f3.png)![](/static/images/%e5%a4%b4%e5%83%8f4.png)![](/static/images/%e5%a4%b4%e5%83%8f5.png)![](/static/images/%e5%a4%b4%e5%83%8f6.png)
### 2、归档功能
#### blog的结构体属性如下
```go
package model

type Blog struct {
	Id           int
	Title        string    `form:"title" json:"title"`                          //标题
	Content      string    `gorm:"type:longtext" form:"content" json:"content"` //内容
	Image        string    `gorm:"type:text" form:"image" json:"image"`         //首图
	Numb         int       `form:"numb" json:"numb"`                            //次数
	Flag         string    `form:"flag" json:"flag"`                            //原创或者转载
	Appreciation string    `form:"appreciation" json:"appreciation"`            //打赏开关
	ShareInfo    string    `form:"shareInfo" json:"shareInfo"`                  //版权开关
	Comment      string    `form:"comment" json:"comment"`                      //评论开关
	Recommend    string    `form:"recommend" json:"recommend"`                  //推荐开关
	Description  string    `gorm:"type:text" form:"description" json:"description"`
	CreatTime    string    `form:"creatTime"  json:"creat_time,omitempty"`   //创建时间
	UpdateTime   string    `form:"updateTime"  json:"update_time,omitempty"` //更新时间
	Comments     []Comment `form:"comments" json:"comments"`
	TypeId       int       `form:"typeId" json:"typeId"`
	Type         Type      `form:"type" gorm:"ForeignKey:TypeId"`
	Year         int       `form:"year" json:"year"`
	Month        int       `form:"month" json:"month"`
	Day          int       `form:"day" json:"day"`
}

```
#### 实现方法
我的思路是创建三个时间节点
year month day 
利用sql分组查询
##### Group By分组查询步骤
###### （1）先按照年份查询
###### （2）再按照年份遍历每个月份
并将所有保存在一个切片中
###### （3）按照月份遍历每个月的所有文章
保存在一个Map中，key是对应的月份，value是每个月份的所有文章
#### 自此归档功能实现


## 3.已知BUG
### 后台退出功能
后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧

开源地址
[github](https://github.com/likewl/blog "github")
[gitee](https://gitee.com/nculike/blog "gitee")', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1535821573,4166447487&fm=26&gp=0.jpg', `numb` = 5, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '本博客后端是用golang 的gin框架+gorm编写', `creat_time` = '2020-07-20 15:24:23', `update_time` = '2020-07-20 15:24:23', `type_id` = 4, `year` = 2020, `month` = 7, `day` = 20  WHERE `blogs`.`id` = 4  
[36;31m[1 rows affected or returned ][0m 
<p>今天本博客评论功能发布</p>

<h1>自今天起，本博客基本功能已经完成</h1>

<h2>发布V1.0版本并开源</h2>

<h2>博客语言说明</h2>

<h4>本博客后端是用golang 的gin框架+gorm编写</h4>

<p>前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的</p>

<h4>博客效果参考本站</h4>

<p>#一、博客简介</p>

<h2>1.博客目录</h2>

<pre><code>blog
├────controller
├────└───admin
|   |   ├──adminblog.go
|   |   ├───adminController.go
|   |   ├──adminTag.go
|   |   ├──adminType.go
|   |   └──adminUser.go
|   └──page
|       ├──404.go
|       ├───about.go
|       ├──archives.go
|       ├──blog.go
|       ├──comment.go
|       ├──pagesController.go
|       ├──researchController.go
|       └──tagsController.go
├── dao
│   ├──blogs.go
│   ├──comment.go
│   ├──sql.go
│   ├──tags.go
│   ├──types.go
│   └──user.go
├── logic
│   └── user.go
├── middlerware
│   ├──function.go
│   ├──getImg.go
│   ├──getTime.go
│   ├──markdown.go
│   ├──select.go
│   └──session.go
├── model
│   ├──blog.go
│   ├──commnent.go
│   ├──tag.go
│   ├──type.go
│   └──user/go
├── static
│   └──静态文件（头像、图片、logo、css、js等）
├── templates
│   └──html模板文件
├── go.mod（依赖）
└── main.go
</code></pre>

<h2>2.相关功能实现简介</h2>

<h3>1、评论及回复功能</h3>

<p>comment的结构体属性如下</p>

<pre><code class="language-go">package model

type Comment struct {
    Id     int //评论id
    BlogId int //博文id
    ReCommentId    int    //父评论id
    CommentName string //评论人姓名
    ReCommentName  string //父评论人姓名
    CommentEmail   string
    Img            string
    CommentContent string `gorm:&#34;type:text&#34; form:&#34;CommentContent&#34; json:&#34;CommentContent&#34;` //评论内容
    CommentTime    string ` json:&#34;comment_time,omitempty&#34;`
    Parent         *Comment
    Comments       []Comment
}
</code></pre>

<h4>实现方法</h4>

<h5>1先通过查找父评论为-1的顶级评论</h5>

<p>父评论Id为-1说明他不是任何评论的子评论</p>

<h5>2在html上遍历所有的顶级评论</h5>

<p>在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论</p>

<h6>（1）递归存储每个顶级评论的子评论</h6>

<p>这里我用一个切片来储存一个顶级评论的所有子评论</p>

<pre><code class="language-go">var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
    var comments []model.Comment
    DB.Debug().Where(&#34;re_comment_id = -1 AND blog_id = ?&#34;, id).Find(&amp;comments)
    return &amp;comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
    if count != 0 {
        fmt.Println(&#34;if判断1&#34;)
        var comments []model.Comment
        DB.Debug().Where(&#34;re_comment_id = ?&#34;, id).Find(&amp;comments)
        count = len(comments)
        if count != 0 {
            fmt.Println(&#34;if判断2&#34;)
            for _, comment := range comments {
                fmt.Println(&#34;for判断1&#34;)
                Comments = append(Comments, comment)
                SelectCommentByComment(comment.Id, count)
            }
        }
    }
    fmt.Println(Comments)
    return &amp;Comments

}
</code></pre>

<p>ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来</p>

<h6>（2）出现问题的原因</h6>

<p>因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量</p>

<h6>（3）解决问题</h6>

<pre><code class="language-go">func ClearComments() bool {
    var comments []model.Comment
    Comments = comments
    return true
}

</code></pre>

<p>这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现</p>

<h4>这里我还加了一个小小的随机头像功能</h4>

<pre><code class="language-go">if  CommentName == user.Name &amp;&amp; CommentEmail == user.UserEmail {
        fmt.Println(&#34;进入了1&#34;)
        comment.Img =user.UserImg
        //找相同评论人
    }else if CommentName == one.CommentName &amp;&amp; CommentEmail == one.CommentEmail {
        fmt.Println(&#34;进入了2&#34;)
        comment.Img =one.Img
        //随机选头像
    }else{
        fmt.Println(&#34;进入了3&#34;)
        comment.Img =middleware.GetImg()
    }
</code></pre>

<h5>123分别代表三种不同的用户群体</h5>

<p>1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
<img src="/static/images/%e5%a4%b4%e5%83%8f1.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f2.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f3.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f4.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f5.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f6.png" alt=""/></p>

<h3>2、归档功能</h3>

<h4>blog的结构体属性如下</h4>

<pre><code class="language-go">package model

type Blog struct {
    Id           int
    Title        string    `form:&#34;title&#34; json:&#34;title&#34;`                          //标题
    Content      string    `gorm:&#34;type:longtext&#34; form:&#34;content&#34; json:&#34;content&#34;` //内容
    Image        string    `gorm:&#34;type:text&#34; form:&#34;image&#34; json:&#34;image&#34;`         //首图
    Numb         int       `form:&#34;numb&#34; json:&#34;numb&#34;`                            //次数
    Flag         string    `form:&#34;flag&#34; json:&#34;flag&#34;`                            //原创或者转载
    Appreciation string    `form:&#34;appreciation&#34; json:&#34;appreciation&#34;`            //打赏开关
    ShareInfo    string    `form:&#34;shareInfo&#34; json:&#34;shareInfo&#34;`                  //版权开关
    Comment      string    `form:&#34;comment&#34; json:&#34;comment&#34;`                      //评论开关
    Recommend    string    `form:&#34;recommend&#34; json:&#34;recommend&#34;`                  //推荐开关
    Description  string    `gorm:&#34;type:text&#34; form:&#34;description&#34; json:&#34;description&#34;`
    CreatTime    string    `form:&#34;creatTime&#34;  json:&#34;creat_time,omitempty&#34;`   //创建时间
    UpdateTime   string    `form:&#34;updateTime&#34;  json:&#34;update_time,omitempty&#34;` //更新时间
    Comments     []Comment `form:&#34;comments&#34; json:&#34;comments&#34;`
    TypeId       int       `form:&#34;typeId&#34; json:&#34;typeId&#34;`
    Type         Type      `form:&#34;type&#34; gorm:&#34;ForeignKey:TypeId&#34;`
    Year         int       `form:&#34;year&#34; json:&#34;year&#34;`
    Month        int       `form:&#34;month&#34; json:&#34;month&#34;`
    Day          int       `form:&#34;day&#34; json:&#34;day&#34;`
}

</code></pre>

<h4>实现方法</h4>

<p>我的思路是创建三个时间节点
year month day
利用sql分组查询</p>

<h5>Group By分组查询步骤</h5>

<h6>（1）先按照年份查询</h6>

<h6>（2）再按照年份遍历每个月份</h6>

<p>并将所有保存在一个切片中</p>

<h6>（3）按照月份遍历每个月的所有文章</h6>

<p>保存在一个Map中，key是对应的月份，value是每个月份的所有文章</p>

<h4>自此归档功能实现</h4>

<h2>3.已知BUG</h2>

<h3>后台退出功能</h3>

<p>后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧</p>

<p>开源地址
<a href="https://github.com/likewl/blog" title="github" rel="nofollow">github</a>
<a href="https://gitee.com/nculike/blog" title="gitee" rel="nofollow">gitee</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 20:09:46][0m  [36;1m[0.25ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-20 20:18:27][0m  [36;1m[0.54ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 4)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-20 20:18:27][0m  [36;1m[0.49ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=4  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-20 20:18:27][0m  [36;1m[0.55ms][0m  UPDATE `blogs` SET `title` = '本博客开源公告', `content` = '今天本博客评论功能发布
# 自今天起，本博客基本功能已经完成
## 发布V1.0版本并开源
## 博客语言说明
#### 本博客后端是用golang 的gin框架+gorm编写
前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的
#### 博客效果参考本站
#一、博客简介
## 1.博客目录

    blog
    ├────controller
	├────└───admin
	|	|	├──adminblog.go
	|	|	├───adminController.go
	|	|	├──adminTag.go
	|	|	├──adminType.go
	|	|	└──adminUser.go
	|	└──page
	|		├──404.go
	|		├───about.go
	|		├──archives.go
	|		├──blog.go
	|		├──comment.go
	|		├──pagesController.go
	|		├──researchController.go
	|		└──tagsController.go
    ├── dao
	│	├──blogs.go
	│	├──comment.go
	│	├──sql.go
	│	├──tags.go
	│	├──types.go
	│	└──user.go
    ├── logic
    │   └── user.go
    ├── middlerware
	│	├──function.go
	│	├──getImg.go
	│	├──getTime.go
	│	├──markdown.go
	│	├──select.go
	│	└──session.go
    ├── model
	│	├──blog.go
	│	├──commnent.go
	│	├──tag.go
	│	├──type.go
	│	└──user/go
    ├── static
	│	└──静态文件（头像、图片、logo、css、js等）
    ├── templates
	│	└──html模板文件
    ├── go.mod（依赖）
    └── main.go
    

## 2.相关功能实现简介
### 1、评论及回复功能
comment的结构体属性如下
```go
package model

type Comment struct {
	Id     int //评论id
	BlogId int //博文id
	ReCommentId    int    //父评论id
	CommentName string //评论人姓名
	ReCommentName  string //父评论人姓名
	CommentEmail   string
	Img            string
	CommentContent string `gorm:"type:text" form:"CommentContent" json:"CommentContent"` //评论内容
	CommentTime    string ` json:"comment_time,omitempty"`
	Parent         *Comment
	Comments       []Comment
}
```
#### 实现方法
##### 1先通过查找父评论为-1的顶级评论
父评论Id为-1说明他不是任何评论的子评论
##### 2在html上遍历所有的顶级评论
在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论
###### （1）递归存储每个顶级评论的子评论
这里我用一个切片来储存一个顶级评论的所有子评论
```go
var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
	var comments []model.Comment
	DB.Debug().Where("re_comment_id = -1 AND blog_id = ?", id).Find(&comments)
	return &comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
	if count != 0 {
		fmt.Println("if判断1")
		var comments []model.Comment
		DB.Debug().Where("re_comment_id = ?", id).Find(&comments)
		count = len(comments)
		if count != 0 {
			fmt.Println("if判断2")
			for _, comment := range comments {
				fmt.Println("for判断1")
				Comments = append(Comments, comment)
				SelectCommentByComment(comment.Id, count)
			}
		}
	}
	fmt.Println(Comments)
	return &Comments

}
```
ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来
###### （2）出现问题的原因
因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量
###### （3）解决问题
```go
func ClearComments() bool {
	var comments []model.Comment
	Comments = comments
	return true
}

```
这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现
#### 这里我还加了一个小小的随机头像功能
```go
if  CommentName == user.Name && CommentEmail == user.UserEmail {
		fmt.Println("进入了1")
		comment.Img =user.UserImg
		//找相同评论人
	}else if CommentName == one.CommentName && CommentEmail == one.CommentEmail {
		fmt.Println("进入了2")
		comment.Img =one.Img
		//随机选头像
	}else{
		fmt.Println("进入了3")
		comment.Img =middleware.GetImg()
	}
```
##### 123分别代表三种不同的用户群体
1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
![](/static/images/%e5%a4%b4%e5%83%8f1.png)![](/static/images/%e5%a4%b4%e5%83%8f2.png)![](/static/images/%e5%a4%b4%e5%83%8f3.png)![](/static/images/%e5%a4%b4%e5%83%8f4.png)![](/static/images/%e5%a4%b4%e5%83%8f5.png)![](/static/images/%e5%a4%b4%e5%83%8f6.png)
### 2、归档功能
#### blog的结构体属性如下
```go
package model

type Blog struct {
	Id           int
	Title        string    `form:"title" json:"title"`                          //标题
	Content      string    `gorm:"type:longtext" form:"content" json:"content"` //内容
	Image        string    `gorm:"type:text" form:"image" json:"image"`         //首图
	Numb         int       `form:"numb" json:"numb"`                            //次数
	Flag         string    `form:"flag" json:"flag"`                            //原创或者转载
	Appreciation string    `form:"appreciation" json:"appreciation"`            //打赏开关
	ShareInfo    string    `form:"shareInfo" json:"shareInfo"`                  //版权开关
	Comment      string    `form:"comment" json:"comment"`                      //评论开关
	Recommend    string    `form:"recommend" json:"recommend"`                  //推荐开关
	Description  string    `gorm:"type:text" form:"description" json:"description"`
	CreatTime    string    `form:"creatTime"  json:"creat_time,omitempty"`   //创建时间
	UpdateTime   string    `form:"updateTime"  json:"update_time,omitempty"` //更新时间
	Comments     []Comment `form:"comments" json:"comments"`
	TypeId       int       `form:"typeId" json:"typeId"`
	Type         Type      `form:"type" gorm:"ForeignKey:TypeId"`
	Year         int       `form:"year" json:"year"`
	Month        int       `form:"month" json:"month"`
	Day          int       `form:"day" json:"day"`
}

```
#### 实现方法
我的思路是创建三个时间节点
year month day 
利用sql分组查询
##### Group By分组查询步骤
###### （1）先按照年份查询
###### （2）再按照年份遍历每个月份
并将所有保存在一个切片中
###### （3）按照月份遍历每个月的所有文章
保存在一个Map中，key是对应的月份，value是每个月份的所有文章
#### 自此归档功能实现


## 3.已知BUG
### 后台退出功能
后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧

开源地址
[github](https://github.com/likewl/blog "github")
[gitee](https://gitee.com/nculike/blog "gitee")', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1535821573,4166447487&fm=26&gp=0.jpg', `numb` = 6, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '本博客后端是用golang 的gin框架+gorm编写', `creat_time` = '2020-07-20 15:24:23', `update_time` = '2020-07-20 15:24:23', `type_id` = 4, `year` = 2020, `month` = 7, `day` = 20  WHERE `blogs`.`id` = 4  
[36;31m[1 rows affected or returned ][0m 
<p>今天本博客评论功能发布</p>

<h1>自今天起，本博客基本功能已经完成</h1>

<h2>发布V1.0版本并开源</h2>

<h2>博客语言说明</h2>

<h4>本博客后端是用golang 的gin框架+gorm编写</h4>

<p>前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的</p>

<h4>博客效果参考本站</h4>

<p>#一、博客简介</p>

<h2>1.博客目录</h2>

<pre><code>blog
├────controller
├────└───admin
|   |   ├──adminblog.go
|   |   ├───adminController.go
|   |   ├──adminTag.go
|   |   ├──adminType.go
|   |   └──adminUser.go
|   └──page
|       ├──404.go
|       ├───about.go
|       ├──archives.go
|       ├──blog.go
|       ├──comment.go
|       ├──pagesController.go
|       ├──researchController.go
|       └──tagsController.go
├── dao
│   ├──blogs.go
│   ├──comment.go
│   ├──sql.go
│   ├──tags.go
│   ├──types.go
│   └──user.go
├── logic
│   └── user.go
├── middlerware
│   ├──function.go
│   ├──getImg.go
│   ├──getTime.go
│   ├──markdown.go
│   ├──select.go
│   └──session.go
├── model
│   ├──blog.go
│   ├──commnent.go
│   ├──tag.go
│   ├──type.go
│   └──user/go
├── static
│   └──静态文件（头像、图片、logo、css、js等）
├── templates
│   └──html模板文件
├── go.mod（依赖）
└── main.go
</code></pre>

<h2>2.相关功能实现简介</h2>

<h3>1、评论及回复功能</h3>

<p>comment的结构体属性如下</p>

<pre><code class="language-go">package model

type Comment struct {
    Id     int //评论id
    BlogId int //博文id
    ReCommentId    int    //父评论id
    CommentName string //评论人姓名
    ReCommentName  string //父评论人姓名
    CommentEmail   string
    Img            string
    CommentContent string `gorm:&#34;type:text&#34; form:&#34;CommentContent&#34; json:&#34;CommentContent&#34;` //评论内容
    CommentTime    string ` json:&#34;comment_time,omitempty&#34;`
    Parent         *Comment
    Comments       []Comment
}
</code></pre>

<h4>实现方法</h4>

<h5>1先通过查找父评论为-1的顶级评论</h5>

<p>父评论Id为-1说明他不是任何评论的子评论</p>

<h5>2在html上遍历所有的顶级评论</h5>

<p>在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论</p>

<h6>（1）递归存储每个顶级评论的子评论</h6>

<p>这里我用一个切片来储存一个顶级评论的所有子评论</p>

<pre><code class="language-go">var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
    var comments []model.Comment
    DB.Debug().Where(&#34;re_comment_id = -1 AND blog_id = ?&#34;, id).Find(&amp;comments)
    return &amp;comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
    if count != 0 {
        fmt.Println(&#34;if判断1&#34;)
        var comments []model.Comment
        DB.Debug().Where(&#34;re_comment_id = ?&#34;, id).Find(&amp;comments)
        count = len(comments)
        if count != 0 {
            fmt.Println(&#34;if判断2&#34;)
            for _, comment := range comments {
                fmt.Println(&#34;for判断1&#34;)
                Comments = append(Comments, comment)
                SelectCommentByComment(comment.Id, count)
            }
        }
    }
    fmt.Println(Comments)
    return &amp;Comments

}
</code></pre>

<p>ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来</p>

<h6>（2）出现问题的原因</h6>

<p>因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量</p>

<h6>（3）解决问题</h6>

<pre><code class="language-go">func ClearComments() bool {
    var comments []model.Comment
    Comments = comments
    return true
}

</code></pre>

<p>这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现</p>

<h4>这里我还加了一个小小的随机头像功能</h4>

<pre><code class="language-go">if  CommentName == user.Name &amp;&amp; CommentEmail == user.UserEmail {
        fmt.Println(&#34;进入了1&#34;)
        comment.Img =user.UserImg
        //找相同评论人
    }else if CommentName == one.CommentName &amp;&amp; CommentEmail == one.CommentEmail {
        fmt.Println(&#34;进入了2&#34;)
        comment.Img =one.Img
        //随机选头像
    }else{
        fmt.Println(&#34;进入了3&#34;)
        comment.Img =middleware.GetImg()
    }
</code></pre>

<h5>123分别代表三种不同的用户群体</h5>

<p>1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
<img src="/static/images/%e5%a4%b4%e5%83%8f1.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f2.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f3.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f4.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f5.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f6.png" alt=""/></p>

<h3>2、归档功能</h3>

<h4>blog的结构体属性如下</h4>

<pre><code class="language-go">package model

type Blog struct {
    Id           int
    Title        string    `form:&#34;title&#34; json:&#34;title&#34;`                          //标题
    Content      string    `gorm:&#34;type:longtext&#34; form:&#34;content&#34; json:&#34;content&#34;` //内容
    Image        string    `gorm:&#34;type:text&#34; form:&#34;image&#34; json:&#34;image&#34;`         //首图
    Numb         int       `form:&#34;numb&#34; json:&#34;numb&#34;`                            //次数
    Flag         string    `form:&#34;flag&#34; json:&#34;flag&#34;`                            //原创或者转载
    Appreciation string    `form:&#34;appreciation&#34; json:&#34;appreciation&#34;`            //打赏开关
    ShareInfo    string    `form:&#34;shareInfo&#34; json:&#34;shareInfo&#34;`                  //版权开关
    Comment      string    `form:&#34;comment&#34; json:&#34;comment&#34;`                      //评论开关
    Recommend    string    `form:&#34;recommend&#34; json:&#34;recommend&#34;`                  //推荐开关
    Description  string    `gorm:&#34;type:text&#34; form:&#34;description&#34; json:&#34;description&#34;`
    CreatTime    string    `form:&#34;creatTime&#34;  json:&#34;creat_time,omitempty&#34;`   //创建时间
    UpdateTime   string    `form:&#34;updateTime&#34;  json:&#34;update_time,omitempty&#34;` //更新时间
    Comments     []Comment `form:&#34;comments&#34; json:&#34;comments&#34;`
    TypeId       int       `form:&#34;typeId&#34; json:&#34;typeId&#34;`
    Type         Type      `form:&#34;type&#34; gorm:&#34;ForeignKey:TypeId&#34;`
    Year         int       `form:&#34;year&#34; json:&#34;year&#34;`
    Month        int       `form:&#34;month&#34; json:&#34;month&#34;`
    Day          int       `form:&#34;day&#34; json:&#34;day&#34;`
}

</code></pre>

<h4>实现方法</h4>

<p>我的思路是创建三个时间节点
year month day
利用sql分组查询</p>

<h5>Group By分组查询步骤</h5>

<h6>（1）先按照年份查询</h6>

<h6>（2）再按照年份遍历每个月份</h6>

<p>并将所有保存在一个切片中</p>

<h6>（3）按照月份遍历每个月的所有文章</h6>

<p>保存在一个Map中，key是对应的月份，value是每个月份的所有文章</p>

<h4>自此归档功能实现</h4>

<h2>3.已知BUG</h2>

<h3>后台退出功能</h3>

<p>后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧</p>

<p>开源地址
<a href="https://github.com/likewl/blog" title="github" rel="nofollow">github</a>
<a href="https://gitee.com/nculike/blog" title="gitee" rel="nofollow">gitee</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 20:18:27][0m  [36;1m[0.28ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 20:18:41][0m  [36;1m[0.57ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 20:18:41][0m  [36;1m[0.79ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 20:18:41][0m  [36;1m[0.25ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 20:18:41][0m  [36;1m[0.32ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 20:18:41][0m  [36;1m[0.29ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 20:18:41][0m  [36;1m[0.38ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-20 20:18:43][0m  [36;1m[0.41ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 2)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-20 20:18:43][0m  [36;1m[2.54ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=2  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-20 20:18:43][0m  [36;1m[0.46ms][0m  UPDATE `blogs` SET `title` = '解决Linux关闭终端后运行的程序自动停止', `content` = '# 问题发现
  昨天博客发布，操作完关闭终端就睡了
  然而今天醒来突然发现终端不能访问了
  查看发现原来博客项目进程被杀死了
# 解决办法
    go build main.go
执行完后

    nohup ./main &
让程序在后台运行就可了


[========]
# ps:这个方法并不完美，因为我也是刚刚接触还不知道怎么切回来', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3696516981,3671280793&fm=26&gp=0.jpg', `numb` = 12, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '昨天博客发布，操作完关闭终端就睡了，然而今天醒来突然发现终端不能访问了，查看发现原来博客项目进程被杀死了', `creat_time` = '2020-07-19 19:05:36', `update_time` = '2020-07-19 19:05:36', `type_id` = 2, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 3  
[36;31m[1 rows affected or returned ][0m 
<h1>问题发现</h1>

<p>昨天博客发布，操作完关闭终端就睡了
  然而今天醒来突然发现终端不能访问了
  查看发现原来博客项目进程被杀死了</p>

<h1>解决办法</h1>

<pre><code>go build main.go
</code></pre>

<p>执行完后</p>

<pre><code>nohup ./main &amp;
</code></pre>

<p>让程序在后台运行就可了</p>

<p>[========]</p>

<h1>ps:这个方法并不完美，因为我也是刚刚接触还不知道怎么切回来</h1>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 20:18:43][0m  [36;1m[0.31ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 20:18:48][0m  [36;1m[0.58ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 20:18:48][0m  [36;1m[0.68ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 20:18:48][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 20:18:48][0m  [36;1m[0.31ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 20:18:48][0m  [36;1m[0.58ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 20:18:48][0m  [36;1m[0.46ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-20 20:18:50][0m  [36;1m[0.41ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 3)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-20 20:18:50][0m  [36;1m[0.46ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=3  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-20 20:18:50][0m  [36;1m[0.42ms][0m  UPDATE `blogs` SET `title` = 'mysql5.7 查询数据，group by 报错：Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 't.id' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by？', `content` = '在做归档功能时用到了分组查询
结果出现了这样的错误
```
Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 't.id' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by

```
查询才知道
mysql 5.7 加入的新特性，only_full_group_by，它只允许你的查询字段是包括在 group by 里面的字段，这种模式导致无法我们无法得到想要的字段值，我们可以禁用掉 only_full_group_by：
### 第一步：
```
select @@GLOBAL.sql_mode;
```
得到现有的 sql_mode, 如下：
```
ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION

```
### 第二步：
```
set global sql_mode ='STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION';

set session sql_mode= 'STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION';
```
去除 ONLY_FULL_GROUP_BY，重新设置，就 ok 了。', `image` = 'https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2507389442,2201469096&fm=26&gp=0.jpg', `numb` = 19, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '在做归档功能时用到了分组查询，结果出现了这样的错误，原来是mysql57的新功能
', `creat_time` = '2020-07-19 18:58:22', `update_time` = '2020-07-19 18:59:30', `type_id` = 3, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 2  
[36;31m[1 rows affected or returned ][0m 
<p>在做归档功能时用到了分组查询
结果出现了这样的错误</p>

<pre><code>Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column &#39;t.id&#39; which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by

</code></pre>

<p>查询才知道
mysql 5.7 加入的新特性，only_full_group_by，它只允许你的查询字段是包括在 group by 里面的字段，这种模式导致无法我们无法得到想要的字段值，我们可以禁用掉 only_full_group_by：</p>

<h3>第一步：</h3>

<pre><code>select @@GLOBAL.sql_mode;
</code></pre>

<p>得到现有的 sql_mode, 如下：</p>

<pre><code>ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION

</code></pre>

<h3>第二步：</h3>

<pre><code>set global sql_mode =&#39;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&#39;;

set session sql_mode= &#39;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&#39;;
</code></pre>

<p>去除 ONLY_FULL_GROUP_BY，重新设置，就 ok 了。</p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 20:18:50][0m  [36;1m[0.31ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 20:18:53][0m  [36;1m[0.52ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 20:18:53][0m  [36;1m[0.72ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 20:18:53][0m  [36;1m[0.23ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 20:18:53][0m  [36;1m[0.32ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 20:18:53][0m  [36;1m[0.27ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 20:18:53][0m  [36;1m[0.35ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-20 20:18:55][0m  [36;1m[0.42ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 1)  
[36;31m[2 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-20 20:18:55][0m  [36;1m[0.41ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=1  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-20 20:18:55][0m  [36;1m[0.40ms][0m  UPDATE `blogs` SET `title` = 'golang项目简单服务器部署到阿里云(linux)', `content` = '# 我个人比较推荐使用Xftp和Xshell 
# 重要是个人免费用
# 舒服又好用

# 1.下载安装go安装包：
	## （1）go语言下载地址：
	[Go语言中文网](https://studygolang.com/dl "Go语言中文网")
下载linux版本的安装包。

## （2）使用Xftp将安装包上传至指定的路径：

![](https://img-blog.csdnimg.cn/20190719142701389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
	这里上传到root目录下就行
	方便解压
## （3）解压并移到/usr/local/下：

进入指定目录，查看已有文件并且解压文件：

![](https://img-blog.csdnimg.cn/20190719143211340.png)
```
#在root目录输入ls查看目录文件
ls
#在root解压go包
tar -zxvf go的包名
```

解压完成后发现目录下多了一个go文件夹：
![](https://img-blog.csdnimg.cn/20190719143042938.png)
将文件夹移动到/usr/local/
![](https://img-blog.csdnimg.cn/20190719143137645.png)
# 2.配置环境变量：
## （1）进入目的目录查看go文件夹是否移动成功：
![](https://img-blog.csdnimg.cn/20190719143506382.png)
## （2）在usr下创建文件夹，用来存放自己的项目：
workspace
## （3）进入新建的目录workspace新建三个文件夹：
src
pkg
bin
### 说明：

	src 目录存放的是我们的go源代码，不同工程项目的代码以包名区分
	pkg 编译后生成的文件
	bin文件夹存放go install命名生成的可执行文件（这个文件夹会配置到环境变量中）
## （4）配置环境变量：

进入 /etc 修改profile文件：
![](https://img-blog.csdnimg.cn/20190719144319621.png)
```
#进入etc目录
cd /etc/
#配置 profile
vim profile
```
![](https://img-blog.csdnimg.cn/20190719145650864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
在此文件夹下加入上图的代码，代码如下：
```
// 设置go安装路径
export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin
 
// 设置工程目录
export GOPATH=/usr/workspace
export PATH=$PATH:$GOPATH/bin
```

## （5）刷新环境变量：
```
source /etc/profile
```
##  （6）查看go环境是否配置成功：
```
go version
```
## （7）查看详细配置：
```
go env
```
结果如下：  
![](https://img-blog.csdnimg.cn/20190719145255720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70) 
# 3.上传项目代码：
在刚刚创建的workspace下新创建的三个文件夹中，src 目录存放的是我们的go源代码
# 4运行
```go
go build main.go
//或者
go run main.go
```
最后执行 ./main 就行了。
如果想让项目在后台执行：执行 nohup ./main & ，这样就可以程序在后台运行了。

参考教程https://blog.csdn.net/qq_42410605/article/details/96479892', `image` = 'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3111860246,1925938903&fm=26&gp=0.jpg', `numb` = 39, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '简单又详细的教程', `creat_time` = '2020-07-19 18:32:31', `update_time` = '2020-07-20 13:11:56', `type_id` = 1, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 1  
[36;31m[1 rows affected or returned ][0m 
<h1>我个人比较推荐使用Xftp和Xshell</h1>

<h1>重要是个人免费用</h1>

<h1>舒服又好用</h1>

<h1>1.下载安装go安装包：</h1>

<pre><code>## （1）go语言下载地址：
[Go语言中文网](https://studygolang.com/dl &#34;Go语言中文网&#34;)
</code></pre>

<p>下载linux版本的安装包。</p>

<h2>（2）使用Xftp将安装包上传至指定的路径：</h2>

<p><img src="https://img-blog.csdnimg.cn/20190719142701389.png?x-oss-process=image%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1%2Csize_16%2Ccolor_FFFFFF%2Ct_70" alt=""/>
    这里上传到root目录下就行
    方便解压</p>

<h2>（3）解压并移到/usr/local/下：</h2>

<p>进入指定目录，查看已有文件并且解压文件：</p>

<p><img src="https://img-blog.csdnimg.cn/20190719143211340.png" alt=""/></p>

<pre><code>#在root目录输入ls查看目录文件
ls
#在root解压go包
tar -zxvf go的包名
</code></pre>

<p>解压完成后发现目录下多了一个go文件夹：
<img src="https://img-blog.csdnimg.cn/20190719143042938.png" alt=""/>
将文件夹移动到/usr/local/
<img src="https://img-blog.csdnimg.cn/20190719143137645.png" alt=""/></p>

<h1>2.配置环境变量：</h1>

<h2>（1）进入目的目录查看go文件夹是否移动成功：</h2>

<p><img src="https://img-blog.csdnimg.cn/20190719143506382.png" alt=""/></p>

<h2>（2）在usr下创建文件夹，用来存放自己的项目：</h2>

<p>workspace</p>

<h2>（3）进入新建的目录workspace新建三个文件夹：</h2>

<p>src
pkg
bin</p>

<h3>说明：</h3>

<pre><code>src 目录存放的是我们的go源代码，不同工程项目的代码以包名区分
pkg 编译后生成的文件
bin文件夹存放go install命名生成的可执行文件（这个文件夹会配置到环境变量中）
</code></pre>

<h2>（4）配置环境变量：</h2>

<p>进入 /etc 修改profile文件：
<img src="https://img-blog.csdnimg.cn/20190719144319621.png" alt=""/></p>

<pre><code>#进入etc目录
cd /etc/
#配置 profile
vim profile
</code></pre>

<p><img src="https://img-blog.csdnimg.cn/20190719145650864.png?x-oss-process=image%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1%2Csize_16%2Ccolor_FFFFFF%2Ct_70" alt=""/>
在此文件夹下加入上图的代码，代码如下：</p>

<pre><code>// 设置go安装路径
export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin
 
// 设置工程目录
export GOPATH=/usr/workspace
export PATH=$PATH:$GOPATH/bin
</code></pre>

<h2>（5）刷新环境变量：</h2>

<pre><code>source /etc/profile
</code></pre>

<h2> （6）查看go环境是否配置成功：</h2>

<pre><code>go version
</code></pre>

<h2>（7）查看详细配置：</h2>

<pre><code>go env
</code></pre>

<p>结果如下：  
<img src="https://img-blog.csdnimg.cn/20190719145255720.png?x-oss-process=image%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1%2Csize_16%2Ccolor_FFFFFF%2Ct_70" alt=""/> </p>

<h1>3.上传项目代码：</h1>

<p>在刚刚创建的workspace下新创建的三个文件夹中，src 目录存放的是我们的go源代码</p>

<h1>4运行</h1>

<pre><code class="language-go">go build main.go
//或者
go run main.go
</code></pre>

<p>最后执行 ./main 就行了。
如果想让项目在后台执行：执行 nohup ./main &amp; ，这样就可以程序在后台运行了。</p>

<p>参考教程<a href="https://blog.csdn.net/qq_42410605/article/details/96479892" rel="nofollow">https://blog.csdn.net/qq_42410605/article/details/96479892</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 20:18:55][0m  [36;1m[0.24ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 20:18:55][0m  [36;1m[0.40ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 1)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 20:18:55][0m  [36;1m[0.34ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 2)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 20:18:55][0m  [36;1m[0.34ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 4)  
[36;31m[0 rows affected or returned ][0m 
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 20:18:55][0m  [36;1m[0.34ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 3)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-20 20:18:55][0m  [36;1m[0.29ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 5)  
[36;31m[0 rows affected or returned ][0m 
[{5 1 3 like 狗科 535889315@qq.com /static/images/header.jpg ？？？ 2020-07-20 13:30:17 <nil> []}]
[{5 1 3 like 狗科 535889315@qq.com /static/images/header.jpg ？？？ 2020-07-20 13:30:17 <nil> []}]

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 20:47:01][0m  [36;1m[0.57ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 20:47:01][0m  [36;1m[0.71ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 20:47:01][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 20:47:01][0m  [36;1m[0.29ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 20:47:01][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 20:47:01][0m  [36;1m[0.34ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 20:47:04][0m  [36;1m[0.49ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 20:47:04][0m  [36;1m[0.24ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 20:47:04][0m  [36;1m[0.69ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-20 20:47:04][0m  [36;1m[0.18ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-20 20:47:05][0m  [36;1m[0.59ms][0m  SELECT * FROM `tags`    
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 20:47:05][0m  [36;1m[0.26ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 20:47:05][0m  [36;1m[0.69ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:31)[0m 
[33m[2020-07-20 20:47:05][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `tags`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 20:47:05][0m  [36;1m[0.56ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 20:47:05][0m  [36;1m[0.75ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 20:47:05][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 20:47:05][0m  [36;1m[0.73ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 20:47:05][0m  [36;1m[1.83ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 20:47:05][0m  [36;1m[0.33ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 
[GIN-debug] redirecting request 301: /admin/ --> /admin/
中间件开始校验
admin 获取user
admin 校验正确
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 20:51:17][0m  [36;1m[0.51ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
[GIN-debug] redirecting request 301: /admin/blog/ --> /admin/blog/
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 20:51:19][0m  [36;1m[0.51ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:38)[0m 
[33m[2020-07-20 20:51:19][0m  [36;1m[0.46ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.recommend,blogs.update_time FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY `blogs`.`id` LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 
&[{1 golang项目简单服务器部署到阿里云(linux) 0 go 是 2020-07-20 13:11:56} {2 mysql5.7 查询数据，group by 报错：Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 't.id' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by？ 0 mysql 是 2020-07-19 18:59:30} {3 解决Linux关闭终端后运行的程序自动停止 0 linux 是 2020-07-19 19:05:36} {4 本博客开源公告 0 博客公告 是 2020-07-20 15:24:23}]
4 ceshi

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 20:51:19][0m  [36;1m[0.23ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 
0

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 20:51:19][0m  [36;1m[0.53ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 20:51:39][0m  [36;1m[0.51ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:38)[0m 
[33m[2020-07-20 20:51:39][0m  [36;1m[0.53ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.recommend,blogs.update_time FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY `blogs`.`id` LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 
&[{1 golang项目简单服务器部署到阿里云(linux) 0 go 是 2020-07-20 13:11:56} {2 mysql5.7 查询数据，group by 报错：Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 't.id' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by？ 0 mysql 是 2020-07-19 18:59:30} {3 解决Linux关闭终端后运行的程序自动停止 0 linux 是 2020-07-19 19:05:36} {4 本博客开源公告 0 博客公告 是 2020-07-20 15:24:23}]
4 ceshi

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 20:51:39][0m  [36;1m[0.25ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 
0
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 20:51:43][0m  [36;1m[0.51ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:38)[0m 
[33m[2020-07-20 20:51:43][0m  [36;1m[0.48ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.recommend,blogs.update_time FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY `blogs`.`id` LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 
&[{1 golang项目简单服务器部署到阿里云(linux) 0 go 是 2020-07-20 13:11:56} {2 mysql5.7 查询数据，group by 报错：Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 't.id' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by？ 0 mysql 是 2020-07-19 18:59:30} {3 解决Linux关闭终端后运行的程序自动停止 0 linux 是 2020-07-19 19:05:36} {4 本博客开源公告 0 博客公告 是 2020-07-20 15:24:23}]
4 ceshi

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 20:51:43][0m  [36;1m[0.28ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 
0
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 20:51:46][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:38)[0m 
[33m[2020-07-20 20:51:46][0m  [36;1m[0.50ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.recommend,blogs.update_time FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY `blogs`.`id` LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 
&[{1 golang项目简单服务器部署到阿里云(linux) 0 go 是 2020-07-20 13:11:56} {2 mysql5.7 查询数据，group by 报错：Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 't.id' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by？ 0 mysql 是 2020-07-19 18:59:30} {3 解决Linux关闭终端后运行的程序自动停止 0 linux 是 2020-07-19 19:05:36} {4 本博客开源公告 0 博客公告 是 2020-07-20 15:24:23}]
4 ceshi

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 20:51:46][0m  [36;1m[0.21ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 
0
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 20:52:26][0m  [36;1m[0.52ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:38)[0m 
[33m[2020-07-20 20:52:26][0m  [36;1m[0.49ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.recommend,blogs.update_time FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY `blogs`.`id` LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 
&[{1 golang项目简单服务器部署到阿里云(linux) 0 go 是 2020-07-20 13:11:56} {2 mysql5.7 查询数据，group by 报错：Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 't.id' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by？ 0 mysql 是 2020-07-19 18:59:30} {3 解决Linux关闭终端后运行的程序自动停止 0 linux 是 2020-07-19 19:05:36} {4 本博客开源公告 0 博客公告 是 2020-07-20 15:24:23}]
4 ceshi

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 20:52:26][0m  [36;1m[0.21ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 
0
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 20:52:31][0m  [36;1m[0.66ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 20:52:31][0m  [36;1m[0.24ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-20 20:52:31][0m  [36;1m[0.23ms][0m  SELECT * FROM `tags`    
[36;31m[5 rows affected or returned ][0m 
[GIN-debug] [WARNING] Running in "debug" mode. Switch to "release" mode in production.
 - using env:	export GIN_MODE=release
 - using code:	gin.SetMode(gin.ReleaseMode)

[GIN-debug] GET    /static/*filepath         --> github.com/gin-gonic/gin.(*RouterGroup).createStaticHandler.func1 (2 handlers)
[GIN-debug] HEAD   /static/*filepath         --> github.com/gin-gonic/gin.(*RouterGroup).createStaticHandler.func1 (2 handlers)
[GIN-debug] Loaded HTML Templates (30): 
	- 
	- tags-input.html
	- admin/tags.html
	- tag.html
	- blogs-edit.html
	- types.html
	- research.html
	- types-edit.html
	- footer1
	- type.html
	- archives.html
	- blog.html
	- header1
	- pages/index.html
	- blogs-input.html
	- blogs.html
	- login.html
	- 404.html
	- index.html
	- tags-edit.html
	- admin/types.html
	- footer1.html
	- admin/index.html
	- tags.html
	- about.html
	- header.html
	- header
	- types-input.html
	- user-edit.html
	- header1.html

[GIN-debug] GET    /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] POST   /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] PUT    /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] PATCH  /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] HEAD   /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] OPTIONS /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] DELETE /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] CONNECT /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] TRACE  /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] GET    /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] POST   /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] PUT    /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] PATCH  /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] HEAD   /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] OPTIONS /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] DELETE /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] CONNECT /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] TRACE  /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] GET    /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] POST   /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] PUT    /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] PATCH  /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] HEAD   /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] OPTIONS /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] DELETE /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] CONNECT /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] TRACE  /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] GET    /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] POST   /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] PUT    /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] PATCH  /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] HEAD   /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] OPTIONS /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] DELETE /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] CONNECT /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] TRACE  /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] GET    /types                    --> blog/controller/page.TypesHandler (2 handlers)
[GIN-debug] GET    /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] POST   /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] PUT    /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] PATCH  /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] HEAD   /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] OPTIONS /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] DELETE /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] CONNECT /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] TRACE  /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] GET    /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] POST   /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] PUT    /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] PATCH  /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] HEAD   /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] OPTIONS /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] DELETE /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] CONNECT /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] TRACE  /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] GET    /tags                     --> blog/controller/page.TagsHandler (2 handlers)
[GIN-debug] GET    /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] POST   /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] PUT    /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] PATCH  /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] HEAD   /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] OPTIONS /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] DELETE /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] CONNECT /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] TRACE  /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] GET    /archives                 --> blog/controller/page.ArchivesHandler (2 handlers)
[GIN-debug] GET    /about                    --> blog/controller/page.AboutHandler (2 handlers)
[GIN-debug] GET    /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] POST   /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] PUT    /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] PATCH  /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] HEAD   /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] OPTIONS /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] DELETE /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] CONNECT /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] TRACE  /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] GET    /admin/logout             --> blog/controller/admin.LogoutHandler (2 handlers)
[GIN-debug] GET    /admin/                   --> blog/controller/admin.AdminHandler (3 handlers)
[GIN-debug] GET    /admin/index              --> blog/controller/admin.AdminIndexHandler (3 handlers)
[GIN-debug] GET    /admin/type/              --> blog/controller/admin.TypeHandler (3 handlers)
[GIN-debug] GET    /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] POST   /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] PUT    /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] PATCH  /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] HEAD   /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] OPTIONS /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] DELETE /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] CONNECT /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] TRACE  /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] GET    /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] POST   /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] PUT    /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] PATCH  /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] HEAD   /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] OPTIONS /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] DELETE /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] CONNECT /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] TRACE  /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] GET    /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] POST   /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] PUT    /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] PATCH  /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] HEAD   /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] OPTIONS /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] DELETE /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] CONNECT /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] TRACE  /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] GET    /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] POST   /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] PUT    /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] PATCH  /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] HEAD   /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] OPTIONS /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] DELETE /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] CONNECT /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] TRACE  /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] GET    /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] POST   /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] PUT    /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] PATCH  /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] HEAD   /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] OPTIONS /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] DELETE /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] CONNECT /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] TRACE  /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] GET    /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] POST   /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] PUT    /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] PATCH  /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] HEAD   /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] OPTIONS /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] DELETE /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] CONNECT /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] TRACE  /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] GET    /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] POST   /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] PUT    /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] PATCH  /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] HEAD   /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] OPTIONS /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] DELETE /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] CONNECT /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] TRACE  /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] GET    /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] POST   /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] PUT    /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] PATCH  /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] HEAD   /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] OPTIONS /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] DELETE /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] CONNECT /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] TRACE  /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] GET    /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] POST   /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] PUT    /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] PATCH  /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] HEAD   /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] OPTIONS /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] DELETE /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] CONNECT /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] TRACE  /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] Listening and serving HTTP on :8080

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 20:55:06][0m  [36;1m[0.52ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 20:55:06][0m  [36;1m[0.76ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 20:55:06][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 20:55:06][0m  [36;1m[0.28ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 20:55:06][0m  [36;1m[0.24ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 20:55:06][0m  [36;1m[0.37ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 20:55:09][0m  [36;1m[0.57ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 20:55:11][0m  [36;1m[0.75ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:38)[0m 
[33m[2020-07-20 20:55:11][0m  [36;1m[0.68ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.recommend,blogs.update_time FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 
&[{4 本博客开源公告 0 博客公告 是 2020-07-20 15:24:23} {3 解决Linux关闭终端后运行的程序自动停止 0 linux 是 2020-07-19 19:05:36} {2 mysql5.7 查询数据，group by 报错：Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 't.id' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by？ 0 mysql 是 2020-07-19 18:59:30} {1 golang项目简单服务器部署到阿里云(linux) 0 go 是 2020-07-20 13:11:56}]
4 ceshi

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 20:55:11][0m  [36;1m[0.31ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 
0
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 20:55:17][0m  [36;1m[0.51ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:38)[0m 
[33m[2020-07-20 20:55:17][0m  [36;1m[0.49ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.recommend,blogs.update_time FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 
&[{4 本博客开源公告 0 博客公告 是 2020-07-20 15:24:23} {3 解决Linux关闭终端后运行的程序自动停止 0 linux 是 2020-07-19 19:05:36} {2 mysql5.7 查询数据，group by 报错：Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 't.id' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by？ 0 mysql 是 2020-07-19 18:59:30} {1 golang项目简单服务器部署到阿里云(linux) 0 go 是 2020-07-20 13:11:56}]
4 ceshi

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 20:55:17][0m  [36;1m[0.21ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 
0
[GIN-debug] redirecting request 301: /admin/user/ --> /admin/user/
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 20:55:18][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 21:00:49][0m  [36;1m[0.49ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:38)[0m 
[33m[2020-07-20 21:00:49][0m  [36;1m[0.44ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.recommend,blogs.update_time FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 
&[{4 本博客开源公告 0 博客公告 是 2020-07-20 15:24:23} {3 解决Linux关闭终端后运行的程序自动停止 0 linux 是 2020-07-19 19:05:36} {2 mysql5.7 查询数据，group by 报错：Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 't.id' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by？ 0 mysql 是 2020-07-19 18:59:30} {1 golang项目简单服务器部署到阿里云(linux) 0 go 是 2020-07-20 13:11:56}]
4 ceshi

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 21:00:49][0m  [36;1m[0.21ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 
0
[GIN-debug] redirecting request 301: /admin/type/ --> /admin/type/
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 21:00:50][0m  [36;1m[0.52ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 21:00:50][0m  [36;1m[0.26ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 21:00:51][0m  [36;1m[0.59ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:38)[0m 
[33m[2020-07-20 21:00:51][0m  [36;1m[0.50ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.recommend,blogs.update_time FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 
&[{4 本博客开源公告 0 博客公告 是 2020-07-20 15:24:23} {3 解决Linux关闭终端后运行的程序自动停止 0 linux 是 2020-07-19 19:05:36} {2 mysql5.7 查询数据，group by 报错：Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 't.id' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by？ 0 mysql 是 2020-07-19 18:59:30} {1 golang项目简单服务器部署到阿里云(linux) 0 go 是 2020-07-20 13:11:56}]
4 ceshi

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 21:00:51][0m  [36;1m[0.20ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 
0
[GIN-debug] redirecting request 301: /admin/tag/ --> /admin/tag/
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 21:00:52][0m  [36;1m[0.51ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 21:00:53][0m  [36;1m[0.52ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 21:00:53][0m  [36;1m[0.25ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 21:00:54][0m  [36;1m[0.52ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 21:00:55][0m  [36;1m[0.62ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 21:00:55][0m  [36;1m[0.26ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 21:00:56][0m  [36;1m[0.69ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:38)[0m 
[33m[2020-07-20 21:00:56][0m  [36;1m[0.62ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.recommend,blogs.update_time FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 
&[{4 本博客开源公告 0 博客公告 是 2020-07-20 15:24:23} {3 解决Linux关闭终端后运行的程序自动停止 0 linux 是 2020-07-19 19:05:36} {2 mysql5.7 查询数据，group by 报错：Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 't.id' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by？ 0 mysql 是 2020-07-19 18:59:30} {1 golang项目简单服务器部署到阿里云(linux) 0 go 是 2020-07-20 13:11:56}]
4 ceshi

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 21:00:56][0m  [36;1m[0.26ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 
0

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 21:01:01][0m  [36;1m[0.48ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 21:01:01][0m  [36;1m[0.76ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 21:01:01][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 21:01:01][0m  [36;1m[0.75ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 21:01:01][0m  [36;1m[2.21ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 21:01:01][0m  [36;1m[0.40ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 21:01:02][0m  [36;1m[0.51ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 21:01:02][0m  [36;1m[0.25ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 21:01:02][0m  [36;1m[0.68ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-20 21:01:02][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 21:01:03][0m  [36;1m[0.49ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 21:01:03][0m  [36;1m[0.66ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 21:01:03][0m  [36;1m[0.18ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 21:01:03][0m  [36;1m[0.29ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 21:01:03][0m  [36;1m[0.24ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 21:01:03][0m  [36;1m[0.31ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 21:01:07][0m  [36;1m[0.55ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 21:01:07][0m  [36;1m[0.31ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 21:01:07][0m  [36;1m[0.71ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-20 21:01:07][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-20 21:01:08][0m  [36;1m[0.59ms][0m  SELECT * FROM `tags`    
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 21:01:08][0m  [36;1m[0.27ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 21:01:08][0m  [36;1m[0.72ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:31)[0m 
[33m[2020-07-20 21:01:08][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `tags`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 21:01:08][0m  [36;1m[0.52ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 21:01:08][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:137)[0m 
[33m[2020-07-20 21:01:08][0m  [36;1m[0.67ms][0m   SELECT * FROM `blogs` GROUP BY YEAR DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:150)[0m 
[33m[2020-07-20 21:01:08][0m  [36;1m[0.64ms][0m   SELECT * FROM `blogs` where year = 2020 GROUP BY month DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:162)[0m 
[33m[2020-07-20 21:01:08][0m  [36;1m[0.58ms][0m   SELECT * FROM `blogs` where year = 2020 and month = 7 ORDER BY `id` DESC  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 21:01:08][0m  [36;1m[0.40ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=4  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 21:01:08][0m  [36;1m[0.35ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=3  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 21:01:08][0m  [36;1m[0.33ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=2  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 21:01:08][0m  [36;1m[0.32ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 21:01:09][0m  [36;1m[0.85ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 21:01:10][0m  [36;1m[0.51ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 21:01:10][0m  [36;1m[0.68ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 21:01:10][0m  [36;1m[0.22ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 21:01:10][0m  [36;1m[0.32ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 21:01:10][0m  [36;1m[0.27ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 21:01:10][0m  [36;1m[0.36ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 22:23:57][0m  [36;1m[0.57ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 22:23:57][0m  [36;1m[0.68ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 22:23:57][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 22:23:57][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 22:23:57][0m  [36;1m[0.27ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 22:23:57][0m  [36;1m[0.32ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-20 22:24:06][0m  [36;1m[0.39ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 4)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-20 22:24:06][0m  [36;1m[0.44ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=4  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-20 22:24:06][0m  [36;1m[0.48ms][0m  UPDATE `blogs` SET `title` = '本博客开源公告', `content` = '今天本博客评论功能发布
# 自今天起，本博客基本功能已经完成
## 发布V1.0版本并开源
## 博客语言说明
#### 本博客后端是用golang 的gin框架+gorm编写
前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的
#### 博客效果参考本站
#一、博客简介
## 1.博客目录

    blog
    ├────controller
	├────└───admin
	|	|	├──adminblog.go
	|	|	├───adminController.go
	|	|	├──adminTag.go
	|	|	├──adminType.go
	|	|	└──adminUser.go
	|	└──page
	|		├──404.go
	|		├───about.go
	|		├──archives.go
	|		├──blog.go
	|		├──comment.go
	|		├──pagesController.go
	|		├──researchController.go
	|		└──tagsController.go
    ├── dao
	│	├──blogs.go
	│	├──comment.go
	│	├──sql.go
	│	├──tags.go
	│	├──types.go
	│	└──user.go
    ├── logic
    │   └── user.go
    ├── middlerware
	│	├──function.go
	│	├──getImg.go
	│	├──getTime.go
	│	├──markdown.go
	│	├──select.go
	│	└──session.go
    ├── model
	│	├──blog.go
	│	├──commnent.go
	│	├──tag.go
	│	├──type.go
	│	└──user/go
    ├── static
	│	└──静态文件（头像、图片、logo、css、js等）
    ├── templates
	│	└──html模板文件
    ├── go.mod（依赖）
    └── main.go
    

## 2.相关功能实现简介
### 1、评论及回复功能
comment的结构体属性如下
```go
package model

type Comment struct {
	Id     int //评论id
	BlogId int //博文id
	ReCommentId    int    //父评论id
	CommentName string //评论人姓名
	ReCommentName  string //父评论人姓名
	CommentEmail   string
	Img            string
	CommentContent string `gorm:"type:text" form:"CommentContent" json:"CommentContent"` //评论内容
	CommentTime    string ` json:"comment_time,omitempty"`
	Parent         *Comment
	Comments       []Comment
}
```
#### 实现方法
##### 1先通过查找父评论为-1的顶级评论
父评论Id为-1说明他不是任何评论的子评论
##### 2在html上遍历所有的顶级评论
在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论
###### （1）递归存储每个顶级评论的子评论
这里我用一个切片来储存一个顶级评论的所有子评论
```go
var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
	var comments []model.Comment
	DB.Debug().Where("re_comment_id = -1 AND blog_id = ?", id).Find(&comments)
	return &comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
	if count != 0 {
		fmt.Println("if判断1")
		var comments []model.Comment
		DB.Debug().Where("re_comment_id = ?", id).Find(&comments)
		count = len(comments)
		if count != 0 {
			fmt.Println("if判断2")
			for _, comment := range comments {
				fmt.Println("for判断1")
				Comments = append(Comments, comment)
				SelectCommentByComment(comment.Id, count)
			}
		}
	}
	fmt.Println(Comments)
	return &Comments

}
```
ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来
###### （2）出现问题的原因
因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量
###### （3）解决问题
```go
func ClearComments() bool {
	var comments []model.Comment
	Comments = comments
	return true
}

```
这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现
#### 这里我还加了一个小小的随机头像功能
```go
if  CommentName == user.Name && CommentEmail == user.UserEmail {
		fmt.Println("进入了1")
		comment.Img =user.UserImg
		//找相同评论人
	}else if CommentName == one.CommentName && CommentEmail == one.CommentEmail {
		fmt.Println("进入了2")
		comment.Img =one.Img
		//随机选头像
	}else{
		fmt.Println("进入了3")
		comment.Img =middleware.GetImg()
	}
```
##### 123分别代表三种不同的用户群体
1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
![](/static/images/%e5%a4%b4%e5%83%8f1.png)![](/static/images/%e5%a4%b4%e5%83%8f2.png)![](/static/images/%e5%a4%b4%e5%83%8f3.png)![](/static/images/%e5%a4%b4%e5%83%8f4.png)![](/static/images/%e5%a4%b4%e5%83%8f5.png)![](/static/images/%e5%a4%b4%e5%83%8f6.png)
### 2、归档功能
#### blog的结构体属性如下
```go
package model

type Blog struct {
	Id           int
	Title        string    `form:"title" json:"title"`                          //标题
	Content      string    `gorm:"type:longtext" form:"content" json:"content"` //内容
	Image        string    `gorm:"type:text" form:"image" json:"image"`         //首图
	Numb         int       `form:"numb" json:"numb"`                            //次数
	Flag         string    `form:"flag" json:"flag"`                            //原创或者转载
	Appreciation string    `form:"appreciation" json:"appreciation"`            //打赏开关
	ShareInfo    string    `form:"shareInfo" json:"shareInfo"`                  //版权开关
	Comment      string    `form:"comment" json:"comment"`                      //评论开关
	Recommend    string    `form:"recommend" json:"recommend"`                  //推荐开关
	Description  string    `gorm:"type:text" form:"description" json:"description"`
	CreatTime    string    `form:"creatTime"  json:"creat_time,omitempty"`   //创建时间
	UpdateTime   string    `form:"updateTime"  json:"update_time,omitempty"` //更新时间
	Comments     []Comment `form:"comments" json:"comments"`
	TypeId       int       `form:"typeId" json:"typeId"`
	Type         Type      `form:"type" gorm:"ForeignKey:TypeId"`
	Year         int       `form:"year" json:"year"`
	Month        int       `form:"month" json:"month"`
	Day          int       `form:"day" json:"day"`
}

```
#### 实现方法
我的思路是创建三个时间节点
year month day 
利用sql分组查询
##### Group By分组查询步骤
###### （1）先按照年份查询
###### （2）再按照年份遍历每个月份
并将所有保存在一个切片中
###### （3）按照月份遍历每个月的所有文章
保存在一个Map中，key是对应的月份，value是每个月份的所有文章
#### 自此归档功能实现


## 3.已知BUG
### 后台退出功能
后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧

开源地址
[github](https://github.com/likewl/blog "github")
[gitee](https://gitee.com/nculike/blog "gitee")', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1535821573,4166447487&fm=26&gp=0.jpg', `numb` = 7, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '本博客后端是用golang 的gin框架+gorm编写', `creat_time` = '2020-07-20 15:24:23', `update_time` = '2020-07-20 15:24:23', `type_id` = 4, `year` = 2020, `month` = 7, `day` = 20  WHERE `blogs`.`id` = 4  
[36;31m[1 rows affected or returned ][0m 
<p>今天本博客评论功能发布</p>

<h1>自今天起，本博客基本功能已经完成</h1>

<h2>发布V1.0版本并开源</h2>

<h2>博客语言说明</h2>

<h4>本博客后端是用golang 的gin框架+gorm编写</h4>

<p>前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的</p>

<h4>博客效果参考本站</h4>

<p>#一、博客简介</p>

<h2>1.博客目录</h2>

<pre><code>blog
├────controller
├────└───admin
|   |   ├──adminblog.go
|   |   ├───adminController.go
|   |   ├──adminTag.go
|   |   ├──adminType.go
|   |   └──adminUser.go
|   └──page
|       ├──404.go
|       ├───about.go
|       ├──archives.go
|       ├──blog.go
|       ├──comment.go
|       ├──pagesController.go
|       ├──researchController.go
|       └──tagsController.go
├── dao
│   ├──blogs.go
│   ├──comment.go
│   ├──sql.go
│   ├──tags.go
│   ├──types.go
│   └──user.go
├── logic
│   └── user.go
├── middlerware
│   ├──function.go
│   ├──getImg.go
│   ├──getTime.go
│   ├──markdown.go
│   ├──select.go
│   └──session.go
├── model
│   ├──blog.go
│   ├──commnent.go
│   ├──tag.go
│   ├──type.go
│   └──user/go
├── static
│   └──静态文件（头像、图片、logo、css、js等）
├── templates
│   └──html模板文件
├── go.mod（依赖）
└── main.go
</code></pre>

<h2>2.相关功能实现简介</h2>

<h3>1、评论及回复功能</h3>

<p>comment的结构体属性如下</p>

<pre><code class="language-go">package model

type Comment struct {
    Id     int //评论id
    BlogId int //博文id
    ReCommentId    int    //父评论id
    CommentName string //评论人姓名
    ReCommentName  string //父评论人姓名
    CommentEmail   string
    Img            string
    CommentContent string `gorm:&#34;type:text&#34; form:&#34;CommentContent&#34; json:&#34;CommentContent&#34;` //评论内容
    CommentTime    string ` json:&#34;comment_time,omitempty&#34;`
    Parent         *Comment
    Comments       []Comment
}
</code></pre>

<h4>实现方法</h4>

<h5>1先通过查找父评论为-1的顶级评论</h5>

<p>父评论Id为-1说明他不是任何评论的子评论</p>

<h5>2在html上遍历所有的顶级评论</h5>

<p>在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论</p>

<h6>（1）递归存储每个顶级评论的子评论</h6>

<p>这里我用一个切片来储存一个顶级评论的所有子评论</p>

<pre><code class="language-go">var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
    var comments []model.Comment
    DB.Debug().Where(&#34;re_comment_id = -1 AND blog_id = ?&#34;, id).Find(&amp;comments)
    return &amp;comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
    if count != 0 {
        fmt.Println(&#34;if判断1&#34;)
        var comments []model.Comment
        DB.Debug().Where(&#34;re_comment_id = ?&#34;, id).Find(&amp;comments)
        count = len(comments)
        if count != 0 {
            fmt.Println(&#34;if判断2&#34;)
            for _, comment := range comments {
                fmt.Println(&#34;for判断1&#34;)
                Comments = append(Comments, comment)
                SelectCommentByComment(comment.Id, count)
            }
        }
    }
    fmt.Println(Comments)
    return &amp;Comments

}
</code></pre>

<p>ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来</p>

<h6>（2）出现问题的原因</h6>

<p>因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量</p>

<h6>（3）解决问题</h6>

<pre><code class="language-go">func ClearComments() bool {
    var comments []model.Comment
    Comments = comments
    return true
}

</code></pre>

<p>这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现</p>

<h4>这里我还加了一个小小的随机头像功能</h4>

<pre><code class="language-go">if  CommentName == user.Name &amp;&amp; CommentEmail == user.UserEmail {
        fmt.Println(&#34;进入了1&#34;)
        comment.Img =user.UserImg
        //找相同评论人
    }else if CommentName == one.CommentName &amp;&amp; CommentEmail == one.CommentEmail {
        fmt.Println(&#34;进入了2&#34;)
        comment.Img =one.Img
        //随机选头像
    }else{
        fmt.Println(&#34;进入了3&#34;)
        comment.Img =middleware.GetImg()
    }
</code></pre>

<h5>123分别代表三种不同的用户群体</h5>

<p>1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
<img src="/static/images/%e5%a4%b4%e5%83%8f1.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f2.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f3.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f4.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f5.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f6.png" alt=""/></p>

<h3>2、归档功能</h3>

<h4>blog的结构体属性如下</h4>

<pre><code class="language-go">package model

type Blog struct {
    Id           int
    Title        string    `form:&#34;title&#34; json:&#34;title&#34;`                          //标题
    Content      string    `gorm:&#34;type:longtext&#34; form:&#34;content&#34; json:&#34;content&#34;` //内容
    Image        string    `gorm:&#34;type:text&#34; form:&#34;image&#34; json:&#34;image&#34;`         //首图
    Numb         int       `form:&#34;numb&#34; json:&#34;numb&#34;`                            //次数
    Flag         string    `form:&#34;flag&#34; json:&#34;flag&#34;`                            //原创或者转载
    Appreciation string    `form:&#34;appreciation&#34; json:&#34;appreciation&#34;`            //打赏开关
    ShareInfo    string    `form:&#34;shareInfo&#34; json:&#34;shareInfo&#34;`                  //版权开关
    Comment      string    `form:&#34;comment&#34; json:&#34;comment&#34;`                      //评论开关
    Recommend    string    `form:&#34;recommend&#34; json:&#34;recommend&#34;`                  //推荐开关
    Description  string    `gorm:&#34;type:text&#34; form:&#34;description&#34; json:&#34;description&#34;`
    CreatTime    string    `form:&#34;creatTime&#34;  json:&#34;creat_time,omitempty&#34;`   //创建时间
    UpdateTime   string    `form:&#34;updateTime&#34;  json:&#34;update_time,omitempty&#34;` //更新时间
    Comments     []Comment `form:&#34;comments&#34; json:&#34;comments&#34;`
    TypeId       int       `form:&#34;typeId&#34; json:&#34;typeId&#34;`
    Type         Type      `form:&#34;type&#34; gorm:&#34;ForeignKey:TypeId&#34;`
    Year         int       `form:&#34;year&#34; json:&#34;year&#34;`
    Month        int       `form:&#34;month&#34; json:&#34;month&#34;`
    Day          int       `form:&#34;day&#34; json:&#34;day&#34;`
}

</code></pre>

<h4>实现方法</h4>

<p>我的思路是创建三个时间节点
year month day
利用sql分组查询</p>

<h5>Group By分组查询步骤</h5>

<h6>（1）先按照年份查询</h6>

<h6>（2）再按照年份遍历每个月份</h6>

<p>并将所有保存在一个切片中</p>

<h6>（3）按照月份遍历每个月的所有文章</h6>

<p>保存在一个Map中，key是对应的月份，value是每个月份的所有文章</p>

<h4>自此归档功能实现</h4>

<h2>3.已知BUG</h2>

<h3>后台退出功能</h3>

<p>后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧</p>

<p>开源地址
<a href="https://github.com/likewl/blog" title="github" rel="nofollow">github</a>
<a href="https://gitee.com/nculike/blog" title="gitee" rel="nofollow">gitee</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 22:24:06][0m  [36;1m[0.35ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 23:29:13][0m  [36;1m[0.57ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 23:29:13][0m  [36;1m[0.78ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 23:29:13][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 23:29:13][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 23:29:13][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 23:29:13][0m  [36;1m[0.34ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 23:29:15][0m  [36;1m[0.51ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 23:29:15][0m  [36;1m[0.26ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 23:29:15][0m  [36;1m[0.66ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-20 23:29:15][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 23:29:16][0m  [36;1m[0.61ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 23:29:16][0m  [36;1m[0.70ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 23:29:16][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 23:29:16][0m  [36;1m[0.29ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 23:29:16][0m  [36;1m[0.25ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 23:29:16][0m  [36;1m[0.31ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 23:30:17][0m  [36;1m[0.56ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 23:30:17][0m  [36;1m[0.71ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 23:30:17][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 23:30:17][0m  [36;1m[0.32ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 23:30:17][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 23:30:17][0m  [36;1m[0.31ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 23:35:08][0m  [36;1m[0.51ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 23:35:08][0m  [36;1m[0.68ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 23:35:08][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 23:35:08][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 23:35:08][0m  [36;1m[0.25ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 23:35:08][0m  [36;1m[0.32ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 23:35:10][0m  [36;1m[0.61ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 23:35:10][0m  [36;1m[0.72ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 23:35:10][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 23:35:10][0m  [36;1m[0.34ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 23:35:10][0m  [36;1m[0.27ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 23:35:10][0m  [36;1m[0.34ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 
[GIN-debug] [WARNING] Running in "debug" mode. Switch to "release" mode in production.
 - using env:	export GIN_MODE=release
 - using code:	gin.SetMode(gin.ReleaseMode)

[GIN-debug] GET    /static/*filepath         --> github.com/gin-gonic/gin.(*RouterGroup).createStaticHandler.func1 (2 handlers)
[GIN-debug] HEAD   /static/*filepath         --> github.com/gin-gonic/gin.(*RouterGroup).createStaticHandler.func1 (2 handlers)
[GIN-debug] Loaded HTML Templates (30): 
	- admin/index.html
	- types-input.html
	- admin/types.html
	- archives.html
	- tag.html
	- blogs-edit.html
	- tags-edit.html
	- admin/tags.html
	- blogs.html
	- types-edit.html
	- about.html
	- pages/index.html
	- header
	- index.html
	- types.html
	- footer1
	- 
	- footer1.html
	- research.html
	- type.html
	- blogs-input.html
	- header.html
	- header1.html
	- header1
	- tags-input.html
	- user-edit.html
	- blog.html
	- login.html
	- tags.html
	- 404.html

[GIN-debug] GET    /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] POST   /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] PUT    /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] PATCH  /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] HEAD   /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] OPTIONS /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] DELETE /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] CONNECT /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] TRACE  /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] GET    /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] POST   /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] PUT    /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] PATCH  /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] HEAD   /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] OPTIONS /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] DELETE /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] CONNECT /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] TRACE  /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] GET    /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] POST   /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] PUT    /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] PATCH  /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] HEAD   /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] OPTIONS /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] DELETE /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] CONNECT /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] TRACE  /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] GET    /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] POST   /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] PUT    /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] PATCH  /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] HEAD   /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] OPTIONS /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] DELETE /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] CONNECT /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] TRACE  /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] GET    /types                    --> blog/controller/page.TypesHandler (2 handlers)
[GIN-debug] GET    /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] POST   /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] PUT    /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] PATCH  /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] HEAD   /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] OPTIONS /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] DELETE /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] CONNECT /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] TRACE  /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] GET    /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] POST   /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] PUT    /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] PATCH  /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] HEAD   /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] OPTIONS /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] DELETE /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] CONNECT /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] TRACE  /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] GET    /tags                     --> blog/controller/page.TagsHandler (2 handlers)
[GIN-debug] GET    /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] POST   /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] PUT    /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] PATCH  /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] HEAD   /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] OPTIONS /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] DELETE /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] CONNECT /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] TRACE  /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] GET    /archives                 --> blog/controller/page.ArchivesHandler (2 handlers)
[GIN-debug] GET    /about                    --> blog/controller/page.AboutHandler (2 handlers)
[GIN-debug] GET    /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] POST   /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] PUT    /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] PATCH  /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] HEAD   /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] OPTIONS /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] DELETE /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] CONNECT /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] TRACE  /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] GET    /admin/logout             --> blog/controller/admin.LogoutHandler (2 handlers)
[GIN-debug] GET    /admin/                   --> blog/controller/admin.AdminHandler (3 handlers)
[GIN-debug] GET    /admin/index              --> blog/controller/admin.AdminIndexHandler (3 handlers)
[GIN-debug] GET    /admin/type/              --> blog/controller/admin.TypeHandler (3 handlers)
[GIN-debug] GET    /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] POST   /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] PUT    /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] PATCH  /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] HEAD   /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] OPTIONS /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] DELETE /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] CONNECT /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] TRACE  /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] GET    /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] POST   /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] PUT    /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] PATCH  /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] HEAD   /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] OPTIONS /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] DELETE /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] CONNECT /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] TRACE  /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] GET    /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] POST   /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] PUT    /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] PATCH  /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] HEAD   /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] OPTIONS /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] DELETE /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] CONNECT /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] TRACE  /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] GET    /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] POST   /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] PUT    /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] PATCH  /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] HEAD   /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] OPTIONS /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] DELETE /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] CONNECT /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] TRACE  /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] GET    /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] POST   /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] PUT    /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] PATCH  /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] HEAD   /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] OPTIONS /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] DELETE /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] CONNECT /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] TRACE  /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] GET    /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] POST   /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] PUT    /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] PATCH  /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] HEAD   /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] OPTIONS /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] DELETE /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] CONNECT /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] TRACE  /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] GET    /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] POST   /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] PUT    /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] PATCH  /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] HEAD   /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] OPTIONS /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] DELETE /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] CONNECT /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] TRACE  /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] GET    /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] POST   /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] PUT    /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] PATCH  /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] HEAD   /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] OPTIONS /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] DELETE /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] CONNECT /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] TRACE  /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] GET    /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] POST   /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] PUT    /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] PATCH  /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] HEAD   /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] OPTIONS /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] DELETE /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] CONNECT /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] TRACE  /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] Listening and serving HTTP on :80
[GIN-debug] [WARNING] Running in "debug" mode. Switch to "release" mode in production.
 - using env:	export GIN_MODE=release
 - using code:	gin.SetMode(gin.ReleaseMode)

[GIN-debug] GET    /static/*filepath         --> github.com/gin-gonic/gin.(*RouterGroup).createStaticHandler.func1 (2 handlers)
[GIN-debug] HEAD   /static/*filepath         --> github.com/gin-gonic/gin.(*RouterGroup).createStaticHandler.func1 (2 handlers)
[GIN-debug] Loaded HTML Templates (30): 
	- blogs-input.html
	- blogs.html
	- header.html
	- header
	- type.html
	- tags-input.html
	- 404.html
	- about.html
	- header1
	- blogs-edit.html
	- tags-edit.html
	- blog.html
	- pages/index.html
	- index.html
	- tags.html
	- admin/types.html
	- user-edit.html
	- header1.html
	- types-input.html
	- 
	- types.html
	- archives.html
	- footer1.html
	- footer1
	- admin/index.html
	- login.html
	- types-edit.html
	- research.html
	- tag.html
	- admin/tags.html

[GIN-debug] GET    /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] POST   /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] PUT    /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] PATCH  /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] HEAD   /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] OPTIONS /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] DELETE /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] CONNECT /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] TRACE  /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] GET    /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] POST   /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] PUT    /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] PATCH  /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] HEAD   /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] OPTIONS /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] DELETE /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] CONNECT /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] TRACE  /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] GET    /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] POST   /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] PUT    /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] PATCH  /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] HEAD   /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] OPTIONS /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] DELETE /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] CONNECT /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] TRACE  /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] GET    /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] POST   /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] PUT    /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] PATCH  /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] HEAD   /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] OPTIONS /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] DELETE /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] CONNECT /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] TRACE  /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] GET    /types                    --> blog/controller/page.TypesHandler (2 handlers)
[GIN-debug] GET    /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] POST   /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] PUT    /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] PATCH  /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] HEAD   /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] OPTIONS /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] DELETE /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] CONNECT /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] TRACE  /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] GET    /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] POST   /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] PUT    /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] PATCH  /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] HEAD   /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] OPTIONS /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] DELETE /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] CONNECT /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] TRACE  /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] GET    /tags                     --> blog/controller/page.TagsHandler (2 handlers)
[GIN-debug] GET    /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] POST   /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] PUT    /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] PATCH  /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] HEAD   /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] OPTIONS /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] DELETE /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] CONNECT /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] TRACE  /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] GET    /archives                 --> blog/controller/page.ArchivesHandler (2 handlers)
[GIN-debug] GET    /about                    --> blog/controller/page.AboutHandler (2 handlers)
[GIN-debug] GET    /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] POST   /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] PUT    /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] PATCH  /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] HEAD   /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] OPTIONS /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] DELETE /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] CONNECT /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] TRACE  /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] GET    /admin/logout             --> blog/controller/admin.LogoutHandler (2 handlers)
[GIN-debug] GET    /admin/                   --> blog/controller/admin.AdminHandler (3 handlers)
[GIN-debug] GET    /admin/index              --> blog/controller/admin.AdminIndexHandler (3 handlers)
[GIN-debug] GET    /admin/type/              --> blog/controller/admin.TypeHandler (3 handlers)
[GIN-debug] GET    /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] POST   /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] PUT    /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] PATCH  /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] HEAD   /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] OPTIONS /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] DELETE /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] CONNECT /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] TRACE  /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] GET    /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] POST   /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] PUT    /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] PATCH  /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] HEAD   /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] OPTIONS /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] DELETE /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] CONNECT /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] TRACE  /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] GET    /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] POST   /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] PUT    /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] PATCH  /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] HEAD   /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] OPTIONS /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] DELETE /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] CONNECT /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] TRACE  /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] GET    /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] POST   /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] PUT    /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] PATCH  /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] HEAD   /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] OPTIONS /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] DELETE /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] CONNECT /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] TRACE  /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] GET    /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] POST   /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] PUT    /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] PATCH  /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] HEAD   /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] OPTIONS /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] DELETE /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] CONNECT /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] TRACE  /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] GET    /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] POST   /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] PUT    /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] PATCH  /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] HEAD   /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] OPTIONS /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] DELETE /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] CONNECT /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] TRACE  /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] GET    /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] POST   /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] PUT    /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] PATCH  /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] HEAD   /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] OPTIONS /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] DELETE /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] CONNECT /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] TRACE  /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] GET    /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] POST   /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] PUT    /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] PATCH  /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] HEAD   /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] OPTIONS /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] DELETE /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] CONNECT /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] TRACE  /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] GET    /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] POST   /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] PUT    /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] PATCH  /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] HEAD   /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] OPTIONS /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] DELETE /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] CONNECT /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] TRACE  /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] Listening and serving HTTP on :8080

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 23:50:28][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 23:50:28][0m  [36;1m[0.76ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 23:50:28][0m  [36;1m[0.22ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 23:50:28][0m  [36;1m[0.29ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 23:50:28][0m  [36;1m[0.28ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 23:50:28][0m  [36;1m[0.33ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 23:50:31][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 23:50:31][0m  [36;1m[0.77ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 23:50:31][0m  [36;1m[0.48ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 23:50:31][0m  [36;1m[0.39ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 23:50:31][0m  [36;1m[0.27ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 23:50:31][0m  [36;1m[0.36ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 23:50:38][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 23:50:38][0m  [36;1m[0.71ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 23:50:38][0m  [36;1m[0.26ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 23:50:38][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 23:50:38][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 23:50:38][0m  [36;1m[0.35ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 
2020/07/20 23:50:38 http: panic serving 116.238.210.229:50391: write tcp 172.16.13.169:8080->116.238.210.229:50391: write: broken pipe
goroutine 108 [running]:
net/http.(*conn).serve.func1(0xc0000a4320)
	/usr/local/go/src/net/http/server.go:1772 +0x139
panic(0xb50ee0, 0xc000177720)
	/usr/local/go/src/runtime/panic.go:975 +0x3e3
github.com/gin-gonic/gin.(*Context).Render(0xc0003fb2c0, 0xc8, 0xd0e1a0, 0xc000735650)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:842 +0x173
github.com/gin-gonic/gin.(*Context).HTML(0xc0003fb2c0, 0xc8, 0xbf9264, 0x10, 0xb43d60, 0xc0005ab230)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:851 +0x99
blog/controller/page.IndexHandler(0xc0003fb2c0)
	/usr/workspace/src/blog/controller/page/pagesController.go:22 +0x570
github.com/gin-gonic/gin.(*Context).Next(0xc0003fb2c0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:161 +0x3b
github.com/gin-contrib/sessions.Sessions.func1(0xc0003fb2c0)
	/usr/workspace/pkg/mod/github.com/gin-contrib/sessions@v0.0.3/sessions.go:52 +0x16d
github.com/gin-gonic/gin.(*Context).Next(0xc0003fb2c0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:161 +0x3b
github.com/gin-gonic/gin.(*Engine).handleHTTPRequest(0xc0003b8500, 0xc0003fb2c0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/gin.go:409 +0x666
github.com/gin-gonic/gin.(*Engine).ServeHTTP(0xc0003b8500, 0xd12980, 0xc0000bd260, 0xc000203f00)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/gin.go:367 +0x14d
net/http.serverHandler.ServeHTTP(0xc0000bc380, 0xd12980, 0xc0000bd260, 0xc000203f00)
	/usr/local/go/src/net/http/server.go:2807 +0xa3
net/http.(*conn).serve(0xc0000a4320, 0xd15140, 0xc0002da700)
	/usr/local/go/src/net/http/server.go:1895 +0x86c
created by net/http.(*Server).Serve
	/usr/local/go/src/net/http/server.go:2933 +0x35c

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 23:51:04][0m  [36;1m[0.60ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
2020/07/20 23:51:04 http: panic serving 116.238.210.229:50436: write tcp 172.16.13.169:8080->116.238.210.229:50436: write: broken pipe
goroutine 137 [running]:
net/http.(*conn).serve.func1(0xc0000a5220)
	/usr/local/go/src/net/http/server.go:1772 +0x139
panic(0xb50ee0, 0xc000176050)
	/usr/local/go/src/runtime/panic.go:975 +0x3e3
github.com/gin-gonic/gin.(*Context).Render(0xc0003dca50, 0x194, 0xd0e1a0, 0xc0005ec9c0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:842 +0x173
github.com/gin-gonic/gin.(*Context).HTML(0xc0003dca50, 0x194, 0xbf1934, 0x8, 0xb43d60, 0xc00075a5a0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:851 +0x99
blog/controller/page.NotFoundHandler(0xc0003dca50)
	/usr/workspace/src/blog/controller/page/404.go:12 +0x120
github.com/gin-gonic/gin.(*Context).Next(0xc0003dca50)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:161 +0x3b
github.com/gin-contrib/sessions.Sessions.func1(0xc0003dca50)
	/usr/workspace/pkg/mod/github.com/gin-contrib/sessions@v0.0.3/sessions.go:52 +0x16d
github.com/gin-gonic/gin.(*Context).Next(0xc0003dca50)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:161 +0x3b
github.com/gin-gonic/gin.serveError(0xc0003dca50, 0x194, 0x1248dc0, 0x12, 0x12)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/gin.go:445 +0x38
github.com/gin-gonic/gin.(*Engine).handleHTTPRequest(0xc0003b8500, 0xc0003dca50)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/gin.go:438 +0x3d3
github.com/gin-gonic/gin.(*Engine).ServeHTTP(0xc0003b8500, 0xd12980, 0xc0000bd5e0, 0xc000758100)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/gin.go:367 +0x14d
net/http.serverHandler.ServeHTTP(0xc0000bc380, 0xd12980, 0xc0000bd5e0, 0xc000758100)
	/usr/local/go/src/net/http/server.go:2807 +0xa3
net/http.(*conn).serve(0xc0000a5220, 0xd15140, 0xc000732b40)
	/usr/local/go/src/net/http/server.go:1895 +0x86c
created by net/http.(*Server).Serve
	/usr/local/go/src/net/http/server.go:2933 +0x35c

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 23:51:08][0m  [36;1m[0.52ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 23:51:08][0m  [36;1m[0.69ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 23:51:08][0m  [36;1m[0.18ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 23:51:08][0m  [36;1m[0.29ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 23:51:08][0m  [36;1m[0.27ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 23:51:08][0m  [36;1m[0.31ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 23:51:30][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
2020/07/20 23:51:30 http: panic serving 116.238.210.229:50451: write tcp 172.16.13.169:8080->116.238.210.229:50451: write: broken pipe
goroutine 191 [running]:
net/http.(*conn).serve.func1(0xc0000a4fa0)
	/usr/local/go/src/net/http/server.go:1772 +0x139
panic(0xb50ee0, 0xc000176c30)
	/usr/local/go/src/runtime/panic.go:975 +0x3e3
github.com/gin-gonic/gin.(*Context).Render(0xc0003dc4b0, 0x194, 0xd0e1a0, 0xc0005b2ab0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:842 +0x173
github.com/gin-gonic/gin.(*Context).HTML(0xc0003dc4b0, 0x194, 0xbf1934, 0x8, 0xb43d60, 0xc0001da690)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:851 +0x99
blog/controller/page.NotFoundHandler(0xc0003dc4b0)
	/usr/workspace/src/blog/controller/page/404.go:12 +0x120
github.com/gin-gonic/gin.(*Context).Next(0xc0003dc4b0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:161 +0x3b
github.com/gin-contrib/sessions.Sessions.func1(0xc0003dc4b0)
	/usr/workspace/pkg/mod/github.com/gin-contrib/sessions@v0.0.3/sessions.go:52 +0x16d
github.com/gin-gonic/gin.(*Context).Next(0xc0003dc4b0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:161 +0x3b
github.com/gin-gonic/gin.serveError(0xc0003dc4b0, 0x194, 0x1248dc0, 0x12, 0x12)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/gin.go:445 +0x38
github.com/gin-gonic/gin.(*Engine).handleHTTPRequest(0xc0003b8500, 0xc0003dc4b0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/gin.go:438 +0x3d3
github.com/gin-gonic/gin.(*Engine).ServeHTTP(0xc0003b8500, 0xd12980, 0xc0000bc8c0, 0xc0000e4c00)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/gin.go:367 +0x14d
net/http.serverHandler.ServeHTTP(0xc0000bc380, 0xd12980, 0xc0000bc8c0, 0xc0000e4c00)
	/usr/local/go/src/net/http/server.go:2807 +0xa3
net/http.(*conn).serve(0xc0000a4fa0, 0xd15140, 0xc00031ad80)
	/usr/local/go/src/net/http/server.go:1895 +0x86c
created by net/http.(*Server).Serve
	/usr/local/go/src/net/http/server.go:2933 +0x35c

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 23:51:32][0m  [36;1m[0.53ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 23:51:32][0m  [36;1m[0.77ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 23:51:32][0m  [36;1m[0.18ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 23:51:32][0m  [36;1m[0.32ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 23:51:32][0m  [36;1m[0.24ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 23:51:32][0m  [36;1m[0.30ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 
2020/07/20 23:51:32 http: panic serving 116.238.210.229:50456: write tcp 172.16.13.169:8080->116.238.210.229:50456: write: broken pipe
goroutine 218 [running]:
net/http.(*conn).serve.func1(0xc0000a5d60)
	/usr/local/go/src/net/http/server.go:1772 +0x139
panic(0xb50ee0, 0xc000177310)
	/usr/local/go/src/runtime/panic.go:975 +0x3e3
github.com/gin-gonic/gin.(*Context).Render(0xc0003dcb40, 0xc8, 0xd0e1a0, 0xc0006c3c50)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:842 +0x173
github.com/gin-gonic/gin.(*Context).HTML(0xc0003dcb40, 0xc8, 0xbf9264, 0x10, 0xb43d60, 0xc0005db830)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:851 +0x99
blog/controller/page.IndexHandler(0xc0003dcb40)
	/usr/workspace/src/blog/controller/page/pagesController.go:22 +0x570
github.com/gin-gonic/gin.(*Context).Next(0xc0003dcb40)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:161 +0x3b
github.com/gin-contrib/sessions.Sessions.func1(0xc0003dcb40)
	/usr/workspace/pkg/mod/github.com/gin-contrib/sessions@v0.0.3/sessions.go:52 +0x16d
github.com/gin-gonic/gin.(*Context).Next(0xc0003dcb40)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:161 +0x3b
github.com/gin-gonic/gin.(*Engine).handleHTTPRequest(0xc0003b8500, 0xc0003dcb40)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/gin.go:409 +0x666
github.com/gin-gonic/gin.(*Engine).ServeHTTP(0xc0003b8500, 0xd12980, 0xc0000bcc40, 0xc0003eca00)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/gin.go:367 +0x14d
net/http.serverHandler.ServeHTTP(0xc0000bc380, 0xd12980, 0xc0000bcc40, 0xc0003eca00)
	/usr/local/go/src/net/http/server.go:2807 +0xa3
net/http.(*conn).serve(0xc0000a5d60, 0xd15140, 0xc0005a7340)
	/usr/local/go/src/net/http/server.go:1895 +0x86c
created by net/http.(*Server).Serve
	/usr/local/go/src/net/http/server.go:2933 +0x35c

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 23:51:36][0m  [36;1m[0.61ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 23:51:36][0m  [36;1m[0.82ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 23:51:36][0m  [36;1m[0.18ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 23:51:36][0m  [36;1m[0.31ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 23:51:36][0m  [36;1m[0.29ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 23:51:36][0m  [36;1m[0.32ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 
2020/07/20 23:51:36 http: panic serving 116.238.210.229:50461: write tcp 172.16.13.169:8080->116.238.210.229:50461: write: broken pipe
goroutine 246 [running]:
net/http.(*conn).serve.func1(0xc0003b7cc0)
	/usr/local/go/src/net/http/server.go:1772 +0x139
panic(0xb50ee0, 0xc000177bd0)
	/usr/local/go/src/runtime/panic.go:975 +0x3e3
github.com/gin-gonic/gin.(*Context).Render(0xc0003dcf00, 0xc8, 0xd0e1a0, 0xc000896a20)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:842 +0x173
github.com/gin-gonic/gin.(*Context).HTML(0xc0003dcf00, 0xc8, 0xbf9264, 0x10, 0xb43d60, 0xc000714600)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:851 +0x99
blog/controller/page.IndexHandler(0xc0003dcf00)
	/usr/workspace/src/blog/controller/page/pagesController.go:22 +0x570
github.com/gin-gonic/gin.(*Context).Next(0xc0003dcf00)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:161 +0x3b
github.com/gin-contrib/sessions.Sessions.func1(0xc0003dcf00)
	/usr/workspace/pkg/mod/github.com/gin-contrib/sessions@v0.0.3/sessions.go:52 +0x16d
github.com/gin-gonic/gin.(*Context).Next(0xc0003dcf00)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:161 +0x3b
github.com/gin-gonic/gin.(*Engine).handleHTTPRequest(0xc0003b8500, 0xc0003dcf00)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/gin.go:409 +0x666
github.com/gin-gonic/gin.(*Engine).ServeHTTP(0xc0003b8500, 0xd12980, 0xc0000bcfc0, 0xc00069cb00)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/gin.go:367 +0x14d
net/http.serverHandler.ServeHTTP(0xc0000bc380, 0xd12980, 0xc0000bcfc0, 0xc00069cb00)
	/usr/local/go/src/net/http/server.go:2807 +0xa3
net/http.(*conn).serve(0xc0003b7cc0, 0xd15140, 0xc0006ad6c0)
	/usr/local/go/src/net/http/server.go:1895 +0x86c
created by net/http.(*Server).Serve
	/usr/local/go/src/net/http/server.go:2933 +0x35c

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 23:51:36][0m  [36;1m[0.52ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
2020/07/20 23:51:36 http: panic serving 116.238.210.229:50462: write tcp 172.16.13.169:8080->116.238.210.229:50462: write: broken pipe
goroutine 273 [running]:
net/http.(*conn).serve.func1(0xc00016e780)
	/usr/local/go/src/net/http/server.go:1772 +0x139
panic(0xb50ee0, 0xc0001763c0)
	/usr/local/go/src/runtime/panic.go:975 +0x3e3
github.com/gin-gonic/gin.(*Context).Render(0xc0003dc2d0, 0x194, 0xd0e1a0, 0xc0008d5200)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:842 +0x173
github.com/gin-gonic/gin.(*Context).HTML(0xc0003dc2d0, 0x194, 0xbf1934, 0x8, 0xb43d60, 0xc000654630)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:851 +0x99
blog/controller/page.NotFoundHandler(0xc0003dc2d0)
	/usr/workspace/src/blog/controller/page/404.go:12 +0x120
github.com/gin-gonic/gin.(*Context).Next(0xc0003dc2d0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:161 +0x3b
github.com/gin-contrib/sessions.Sessions.func1(0xc0003dc2d0)
	/usr/workspace/pkg/mod/github.com/gin-contrib/sessions@v0.0.3/sessions.go:52 +0x16d
github.com/gin-gonic/gin.(*Context).Next(0xc0003dc2d0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:161 +0x3b
github.com/gin-gonic/gin.serveError(0xc0003dc2d0, 0x194, 0x1248dc0, 0x12, 0x12)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/gin.go:445 +0x38
github.com/gin-gonic/gin.(*Engine).handleHTTPRequest(0xc0003b8500, 0xc0003dc2d0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/gin.go:438 +0x3d3
github.com/gin-gonic/gin.(*Engine).ServeHTTP(0xc0003b8500, 0xd12980, 0xc0000bc0e0, 0xc00087eb00)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/gin.go:367 +0x14d
net/http.serverHandler.ServeHTTP(0xc0000bc380, 0xd12980, 0xc0000bc0e0, 0xc00087eb00)
	/usr/local/go/src/net/http/server.go:2807 +0xa3
net/http.(*conn).serve(0xc00016e780, 0xd15140, 0xc0008859c0)
	/usr/local/go/src/net/http/server.go:1895 +0x86c
created by net/http.(*Server).Serve
	/usr/local/go/src/net/http/server.go:2933 +0x35c

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 23:51:48][0m  [36;1m[0.58ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 23:51:48][0m  [36;1m[0.25ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 23:51:48][0m  [36;1m[0.74ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-20 23:51:48][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 23:51:49][0m  [36;1m[0.60ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 23:51:49][0m  [36;1m[0.73ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 23:51:49][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 23:51:49][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 23:51:49][0m  [36;1m[0.27ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 23:51:49][0m  [36;1m[0.35ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-20 23:51:50][0m  [36;1m[0.40ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 4)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-20 23:51:50][0m  [36;1m[0.49ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=4  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-20 23:51:50][0m  [36;1m[0.48ms][0m  UPDATE `blogs` SET `title` = '本博客开源公告', `content` = '今天本博客评论功能发布
# 自今天起，本博客基本功能已经完成
## 发布V1.0版本并开源
## 博客语言说明
#### 本博客后端是用golang 的gin框架+gorm编写
前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的
#### 博客效果参考本站
#一、博客简介
## 1.博客目录

    blog
    ├────controller
	├────└───admin
	|	|	├──adminblog.go
	|	|	├───adminController.go
	|	|	├──adminTag.go
	|	|	├──adminType.go
	|	|	└──adminUser.go
	|	└──page
	|		├──404.go
	|		├───about.go
	|		├──archives.go
	|		├──blog.go
	|		├──comment.go
	|		├──pagesController.go
	|		├──researchController.go
	|		└──tagsController.go
    ├── dao
	│	├──blogs.go
	│	├──comment.go
	│	├──sql.go
	│	├──tags.go
	│	├──types.go
	│	└──user.go
    ├── logic
    │   └── user.go
    ├── middlerware
	│	├──function.go
	│	├──getImg.go
	│	├──getTime.go
	│	├──markdown.go
	│	├──select.go
	│	└──session.go
    ├── model
	│	├──blog.go
	│	├──commnent.go
	│	├──tag.go
	│	├──type.go
	│	└──user/go
    ├── static
	│	└──静态文件（头像、图片、logo、css、js等）
    ├── templates
	│	└──html模板文件
    ├── go.mod（依赖）
    └── main.go
    

## 2.相关功能实现简介
### 1、评论及回复功能
comment的结构体属性如下
```go
package model

type Comment struct {
	Id     int //评论id
	BlogId int //博文id
	ReCommentId    int    //父评论id
	CommentName string //评论人姓名
	ReCommentName  string //父评论人姓名
	CommentEmail   string
	Img            string
	CommentContent string `gorm:"type:text" form:"CommentContent" json:"CommentContent"` //评论内容
	CommentTime    string ` json:"comment_time,omitempty"`
	Parent         *Comment
	Comments       []Comment
}
```
#### 实现方法
##### 1先通过查找父评论为-1的顶级评论
父评论Id为-1说明他不是任何评论的子评论
##### 2在html上遍历所有的顶级评论
在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论
###### （1）递归存储每个顶级评论的子评论
这里我用一个切片来储存一个顶级评论的所有子评论
```go
var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
	var comments []model.Comment
	DB.Debug().Where("re_comment_id = -1 AND blog_id = ?", id).Find(&comments)
	return &comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
	if count != 0 {
		fmt.Println("if判断1")
		var comments []model.Comment
		DB.Debug().Where("re_comment_id = ?", id).Find(&comments)
		count = len(comments)
		if count != 0 {
			fmt.Println("if判断2")
			for _, comment := range comments {
				fmt.Println("for判断1")
				Comments = append(Comments, comment)
				SelectCommentByComment(comment.Id, count)
			}
		}
	}
	fmt.Println(Comments)
	return &Comments

}
```
ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来
###### （2）出现问题的原因
因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量
###### （3）解决问题
```go
func ClearComments() bool {
	var comments []model.Comment
	Comments = comments
	return true
}

```
这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现
#### 这里我还加了一个小小的随机头像功能
```go
if  CommentName == user.Name && CommentEmail == user.UserEmail {
		fmt.Println("进入了1")
		comment.Img =user.UserImg
		//找相同评论人
	}else if CommentName == one.CommentName && CommentEmail == one.CommentEmail {
		fmt.Println("进入了2")
		comment.Img =one.Img
		//随机选头像
	}else{
		fmt.Println("进入了3")
		comment.Img =middleware.GetImg()
	}
```
##### 123分别代表三种不同的用户群体
1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
![](/static/images/%e5%a4%b4%e5%83%8f1.png)![](/static/images/%e5%a4%b4%e5%83%8f2.png)![](/static/images/%e5%a4%b4%e5%83%8f3.png)![](/static/images/%e5%a4%b4%e5%83%8f4.png)![](/static/images/%e5%a4%b4%e5%83%8f5.png)![](/static/images/%e5%a4%b4%e5%83%8f6.png)
### 2、归档功能
#### blog的结构体属性如下
```go
package model

type Blog struct {
	Id           int
	Title        string    `form:"title" json:"title"`                          //标题
	Content      string    `gorm:"type:longtext" form:"content" json:"content"` //内容
	Image        string    `gorm:"type:text" form:"image" json:"image"`         //首图
	Numb         int       `form:"numb" json:"numb"`                            //次数
	Flag         string    `form:"flag" json:"flag"`                            //原创或者转载
	Appreciation string    `form:"appreciation" json:"appreciation"`            //打赏开关
	ShareInfo    string    `form:"shareInfo" json:"shareInfo"`                  //版权开关
	Comment      string    `form:"comment" json:"comment"`                      //评论开关
	Recommend    string    `form:"recommend" json:"recommend"`                  //推荐开关
	Description  string    `gorm:"type:text" form:"description" json:"description"`
	CreatTime    string    `form:"creatTime"  json:"creat_time,omitempty"`   //创建时间
	UpdateTime   string    `form:"updateTime"  json:"update_time,omitempty"` //更新时间
	Comments     []Comment `form:"comments" json:"comments"`
	TypeId       int       `form:"typeId" json:"typeId"`
	Type         Type      `form:"type" gorm:"ForeignKey:TypeId"`
	Year         int       `form:"year" json:"year"`
	Month        int       `form:"month" json:"month"`
	Day          int       `form:"day" json:"day"`
}

```
#### 实现方法
我的思路是创建三个时间节点
year month day 
利用sql分组查询
##### Group By分组查询步骤
###### （1）先按照年份查询
###### （2）再按照年份遍历每个月份
并将所有保存在一个切片中
###### （3）按照月份遍历每个月的所有文章
保存在一个Map中，key是对应的月份，value是每个月份的所有文章
#### 自此归档功能实现


## 3.已知BUG
### 后台退出功能
后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧

开源地址
[github](https://github.com/likewl/blog "github")
[gitee](https://gitee.com/nculike/blog "gitee")', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1535821573,4166447487&fm=26&gp=0.jpg', `numb` = 8, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '本博客后端是用golang 的gin框架+gorm编写', `creat_time` = '2020-07-20 15:24:23', `update_time` = '2020-07-20 15:24:23', `type_id` = 4, `year` = 2020, `month` = 7, `day` = 20  WHERE `blogs`.`id` = 4  
[36;31m[1 rows affected or returned ][0m 
<p>今天本博客评论功能发布</p>

<h1>自今天起，本博客基本功能已经完成</h1>

<h2>发布V1.0版本并开源</h2>

<h2>博客语言说明</h2>

<h4>本博客后端是用golang 的gin框架+gorm编写</h4>

<p>前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的</p>

<h4>博客效果参考本站</h4>

<p>#一、博客简介</p>

<h2>1.博客目录</h2>

<pre><code>blog
├────controller
├────└───admin
|   |   ├──adminblog.go
|   |   ├───adminController.go
|   |   ├──adminTag.go
|   |   ├──adminType.go
|   |   └──adminUser.go
|   └──page
|       ├──404.go
|       ├───about.go
|       ├──archives.go
|       ├──blog.go
|       ├──comment.go
|       ├──pagesController.go
|       ├──researchController.go
|       └──tagsController.go
├── dao
│   ├──blogs.go
│   ├──comment.go
│   ├──sql.go
│   ├──tags.go
│   ├──types.go
│   └──user.go
├── logic
│   └── user.go
├── middlerware
│   ├──function.go
│   ├──getImg.go
│   ├──getTime.go
│   ├──markdown.go
│   ├──select.go
│   └──session.go
├── model
│   ├──blog.go
│   ├──commnent.go
│   ├──tag.go
│   ├──type.go
│   └──user/go
├── static
│   └──静态文件（头像、图片、logo、css、js等）
├── templates
│   └──html模板文件
├── go.mod（依赖）
└── main.go
</code></pre>

<h2>2.相关功能实现简介</h2>

<h3>1、评论及回复功能</h3>

<p>comment的结构体属性如下</p>

<pre><code class="language-go">package model

type Comment struct {
    Id     int //评论id
    BlogId int //博文id
    ReCommentId    int    //父评论id
    CommentName string //评论人姓名
    ReCommentName  string //父评论人姓名
    CommentEmail   string
    Img            string
    CommentContent string `gorm:&#34;type:text&#34; form:&#34;CommentContent&#34; json:&#34;CommentContent&#34;` //评论内容
    CommentTime    string ` json:&#34;comment_time,omitempty&#34;`
    Parent         *Comment
    Comments       []Comment
}
</code></pre>

<h4>实现方法</h4>

<h5>1先通过查找父评论为-1的顶级评论</h5>

<p>父评论Id为-1说明他不是任何评论的子评论</p>

<h5>2在html上遍历所有的顶级评论</h5>

<p>在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论</p>

<h6>（1）递归存储每个顶级评论的子评论</h6>

<p>这里我用一个切片来储存一个顶级评论的所有子评论</p>

<pre><code class="language-go">var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
    var comments []model.Comment
    DB.Debug().Where(&#34;re_comment_id = -1 AND blog_id = ?&#34;, id).Find(&amp;comments)
    return &amp;comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
    if count != 0 {
        fmt.Println(&#34;if判断1&#34;)
        var comments []model.Comment
        DB.Debug().Where(&#34;re_comment_id = ?&#34;, id).Find(&amp;comments)
        count = len(comments)
        if count != 0 {
            fmt.Println(&#34;if判断2&#34;)
            for _, comment := range comments {
                fmt.Println(&#34;for判断1&#34;)
                Comments = append(Comments, comment)
                SelectCommentByComment(comment.Id, count)
            }
        }
    }
    fmt.Println(Comments)
    return &amp;Comments

}
</code></pre>

<p>ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来</p>

<h6>（2）出现问题的原因</h6>

<p>因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量</p>

<h6>（3）解决问题</h6>

<pre><code class="language-go">func ClearComments() bool {
    var comments []model.Comment
    Comments = comments
    return true
}

</code></pre>

<p>这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现</p>

<h4>这里我还加了一个小小的随机头像功能</h4>

<pre><code class="language-go">if  CommentName == user.Name &amp;&amp; CommentEmail == user.UserEmail {
        fmt.Println(&#34;进入了1&#34;)
        comment.Img =user.UserImg
        //找相同评论人
    }else if CommentName == one.CommentName &amp;&amp; CommentEmail == one.CommentEmail {
        fmt.Println(&#34;进入了2&#34;)
        comment.Img =one.Img
        //随机选头像
    }else{
        fmt.Println(&#34;进入了3&#34;)
        comment.Img =middleware.GetImg()
    }
</code></pre>

<h5>123分别代表三种不同的用户群体</h5>

<p>1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
<img src="/static/images/%e5%a4%b4%e5%83%8f1.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f2.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f3.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f4.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f5.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f6.png" alt=""/></p>

<h3>2、归档功能</h3>

<h4>blog的结构体属性如下</h4>

<pre><code class="language-go">package model

type Blog struct {
    Id           int
    Title        string    `form:&#34;title&#34; json:&#34;title&#34;`                          //标题
    Content      string    `gorm:&#34;type:longtext&#34; form:&#34;content&#34; json:&#34;content&#34;` //内容
    Image        string    `gorm:&#34;type:text&#34; form:&#34;image&#34; json:&#34;image&#34;`         //首图
    Numb         int       `form:&#34;numb&#34; json:&#34;numb&#34;`                            //次数
    Flag         string    `form:&#34;flag&#34; json:&#34;flag&#34;`                            //原创或者转载
    Appreciation string    `form:&#34;appreciation&#34; json:&#34;appreciation&#34;`            //打赏开关
    ShareInfo    string    `form:&#34;shareInfo&#34; json:&#34;shareInfo&#34;`                  //版权开关
    Comment      string    `form:&#34;comment&#34; json:&#34;comment&#34;`                      //评论开关
    Recommend    string    `form:&#34;recommend&#34; json:&#34;recommend&#34;`                  //推荐开关
    Description  string    `gorm:&#34;type:text&#34; form:&#34;description&#34; json:&#34;description&#34;`
    CreatTime    string    `form:&#34;creatTime&#34;  json:&#34;creat_time,omitempty&#34;`   //创建时间
    UpdateTime   string    `form:&#34;updateTime&#34;  json:&#34;update_time,omitempty&#34;` //更新时间
    Comments     []Comment `form:&#34;comments&#34; json:&#34;comments&#34;`
    TypeId       int       `form:&#34;typeId&#34; json:&#34;typeId&#34;`
    Type         Type      `form:&#34;type&#34; gorm:&#34;ForeignKey:TypeId&#34;`
    Year         int       `form:&#34;year&#34; json:&#34;year&#34;`
    Month        int       `form:&#34;month&#34; json:&#34;month&#34;`
    Day          int       `form:&#34;day&#34; json:&#34;day&#34;`
}

</code></pre>

<h4>实现方法</h4>

<p>我的思路是创建三个时间节点
year month day
利用sql分组查询</p>

<h5>Group By分组查询步骤</h5>

<h6>（1）先按照年份查询</h6>

<h6>（2）再按照年份遍历每个月份</h6>

<p>并将所有保存在一个切片中</p>

<h6>（3）按照月份遍历每个月的所有文章</h6>

<p>保存在一个Map中，key是对应的月份，value是每个月份的所有文章</p>

<h4>自此归档功能实现</h4>

<h2>3.已知BUG</h2>

<h3>后台退出功能</h3>

<p>后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧</p>

<p>开源地址
<a href="https://github.com/likewl/blog" title="github" rel="nofollow">github</a>
<a href="https://gitee.com/nculike/blog" title="gitee" rel="nofollow">gitee</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 23:51:50][0m  [36;1m[0.63ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 23:51:58][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 23:51:58][0m  [36;1m[0.71ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 23:51:58][0m  [36;1m[0.18ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 23:51:58][0m  [36;1m[0.33ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 23:51:58][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 23:51:58][0m  [36;1m[0.31ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 23:52:36][0m  [36;1m[0.56ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 23:52:36][0m  [36;1m[0.27ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 23:52:36][0m  [36;1m[0.72ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-20 23:52:36][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 23:52:37][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 23:52:37][0m  [36;1m[0.75ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 23:52:37][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 23:52:37][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 23:52:37][0m  [36;1m[0.25ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 23:52:37][0m  [36;1m[0.31ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-20 23:52:40][0m  [36;1m[0.56ms][0m  SELECT * FROM `tags`    
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 23:52:40][0m  [36;1m[0.27ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 23:52:40][0m  [36;1m[0.70ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:31)[0m 
[33m[2020-07-20 23:52:40][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `tags`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 23:52:41][0m  [36;1m[0.53ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 23:52:41][0m  [36;1m[0.68ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 23:52:41][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 23:52:41][0m  [36;1m[0.31ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 23:52:41][0m  [36;1m[0.28ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 23:52:41][0m  [36;1m[0.30ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 23:53:05][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 23:53:05][0m  [36;1m[0.70ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 23:53:05][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 23:53:05][0m  [36;1m[0.29ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 23:53:05][0m  [36;1m[0.25ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 23:53:05][0m  [36;1m[0.33ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 23:53:07][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 23:53:07][0m  [36;1m[0.68ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 23:53:07][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 23:53:07][0m  [36;1m[0.29ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 23:53:07][0m  [36;1m[0.24ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 23:53:07][0m  [36;1m[0.31ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 23:53:08][0m  [36;1m[0.56ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 23:53:08][0m  [36;1m[0.81ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 23:53:08][0m  [36;1m[0.26ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 23:53:08][0m  [36;1m[0.32ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 23:53:08][0m  [36;1m[0.32ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 23:53:08][0m  [36;1m[0.43ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 23:53:19][0m  [36;1m[0.52ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 23:53:19][0m  [36;1m[0.72ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 23:53:19][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 23:53:19][0m  [36;1m[0.35ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 23:53:19][0m  [36;1m[0.25ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 23:53:19][0m  [36;1m[0.32ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 23:55:59][0m  [36;1m[0.62ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
[GIN-debug] [WARNING] Running in "debug" mode. Switch to "release" mode in production.
 - using env:	export GIN_MODE=release
 - using code:	gin.SetMode(gin.ReleaseMode)

[GIN-debug] GET    /static/*filepath         --> github.com/gin-gonic/gin.(*RouterGroup).createStaticHandler.func1 (2 handlers)
[GIN-debug] HEAD   /static/*filepath         --> github.com/gin-gonic/gin.(*RouterGroup).createStaticHandler.func1 (2 handlers)
[GIN-debug] Loaded HTML Templates (30): 
	- index.html
	- login.html
	- tags.html
	- pages/index.html
	- blogs-input.html
	- blogs.html
	- user-edit.html
	- header1
	- research.html
	- admin/types.html
	- footer1
	- tag.html
	- tags-input.html
	- admin/tags.html
	- types-edit.html
	- blogs-edit.html
	- about.html
	- 
	- admin/index.html
	- 404.html
	- type.html
	- header
	- tags-edit.html
	- blog.html
	- footer1.html
	- header1.html
	- header.html
	- types-input.html
	- types.html
	- archives.html

[GIN-debug] GET    /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] POST   /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] PUT    /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] PATCH  /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] HEAD   /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] OPTIONS /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] DELETE /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] CONNECT /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] TRACE  /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] GET    /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] POST   /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] PUT    /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] PATCH  /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] HEAD   /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] OPTIONS /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] DELETE /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] CONNECT /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] TRACE  /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] GET    /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] POST   /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] PUT    /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] PATCH  /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] HEAD   /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] OPTIONS /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] DELETE /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] CONNECT /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] TRACE  /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] GET    /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] POST   /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] PUT    /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] PATCH  /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] HEAD   /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] OPTIONS /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] DELETE /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] CONNECT /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] TRACE  /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] GET    /types                    --> blog/controller/page.TypesHandler (2 handlers)
[GIN-debug] GET    /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] POST   /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] PUT    /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] PATCH  /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] HEAD   /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] OPTIONS /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] DELETE /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] CONNECT /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] TRACE  /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] GET    /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] POST   /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] PUT    /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] PATCH  /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] HEAD   /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] OPTIONS /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] DELETE /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] CONNECT /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] TRACE  /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] GET    /tags                     --> blog/controller/page.TagsHandler (2 handlers)
[GIN-debug] GET    /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] POST   /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] PUT    /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] PATCH  /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] HEAD   /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] OPTIONS /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] DELETE /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] CONNECT /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] TRACE  /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] GET    /archives                 --> blog/controller/page.ArchivesHandler (2 handlers)
[GIN-debug] GET    /about                    --> blog/controller/page.AboutHandler (2 handlers)
[GIN-debug] GET    /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] POST   /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] PUT    /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] PATCH  /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] HEAD   /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] OPTIONS /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] DELETE /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] CONNECT /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] TRACE  /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] GET    /admin/logout             --> blog/controller/admin.LogoutHandler (2 handlers)
[GIN-debug] GET    /admin/                   --> blog/controller/admin.AdminHandler (3 handlers)
[GIN-debug] GET    /admin/index              --> blog/controller/admin.AdminIndexHandler (3 handlers)
[GIN-debug] GET    /admin/type/              --> blog/controller/admin.TypeHandler (3 handlers)
[GIN-debug] GET    /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] POST   /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] PUT    /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] PATCH  /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] HEAD   /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] OPTIONS /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] DELETE /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] CONNECT /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] TRACE  /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] GET    /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] POST   /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] PUT    /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] PATCH  /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] HEAD   /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] OPTIONS /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] DELETE /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] CONNECT /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] TRACE  /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] GET    /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] POST   /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] PUT    /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] PATCH  /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] HEAD   /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] OPTIONS /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] DELETE /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] CONNECT /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] TRACE  /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] GET    /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] POST   /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] PUT    /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] PATCH  /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] HEAD   /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] OPTIONS /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] DELETE /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] CONNECT /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] TRACE  /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] GET    /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] POST   /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] PUT    /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] PATCH  /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] HEAD   /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] OPTIONS /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] DELETE /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] CONNECT /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] TRACE  /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] GET    /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] POST   /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] PUT    /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] PATCH  /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] HEAD   /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] OPTIONS /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] DELETE /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] CONNECT /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] TRACE  /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] GET    /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] POST   /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] PUT    /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] PATCH  /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] HEAD   /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] OPTIONS /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] DELETE /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] CONNECT /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] TRACE  /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] GET    /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] POST   /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] PUT    /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] PATCH  /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] HEAD   /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] OPTIONS /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] DELETE /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] CONNECT /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] TRACE  /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] GET    /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] POST   /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] PUT    /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] PATCH  /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] HEAD   /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] OPTIONS /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] DELETE /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] CONNECT /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] TRACE  /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] Listening and serving HTTP on :80

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 23:57:49][0m  [36;1m[0.59ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 23:57:49][0m  [36;1m[0.75ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 23:57:49][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 23:57:49][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 23:57:49][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 23:57:49][0m  [36;1m[0.43ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 23:57:51][0m  [36;1m[0.59ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 23:57:51][0m  [36;1m[0.71ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 23:57:51][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 23:57:51][0m  [36;1m[0.31ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 23:57:51][0m  [36;1m[0.27ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 23:57:51][0m  [36;1m[0.33ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 23:57:53][0m  [36;1m[0.64ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 23:57:53][0m  [36;1m[0.72ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 23:57:53][0m  [36;1m[0.28ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 23:57:53][0m  [36;1m[0.33ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 23:57:53][0m  [36;1m[0.28ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 23:57:53][0m  [36;1m[0.41ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 23:57:54][0m  [36;1m[0.63ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 23:57:54][0m  [36;1m[0.28ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 23:57:54][0m  [36;1m[0.77ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-20 23:57:54][0m  [36;1m[0.24ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 23:57:55][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 23:57:55][0m  [36;1m[0.69ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 23:57:55][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 23:57:55][0m  [36;1m[0.29ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 23:57:55][0m  [36;1m[0.36ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 23:57:55][0m  [36;1m[0.32ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 23:58:06][0m  [36;1m[0.59ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 23:58:06][0m  [36;1m[0.78ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 23:58:06][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 23:58:06][0m  [36;1m[0.35ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 23:58:06][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 23:58:06][0m  [36;1m[0.32ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 23:58:17][0m  [36;1m[0.56ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 23:58:17][0m  [36;1m[0.69ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 23:58:17][0m  [36;1m[0.23ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 23:58:17][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 23:58:17][0m  [36;1m[0.27ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 23:58:17][0m  [36;1m[0.35ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 23:58:19][0m  [36;1m[0.52ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 23:58:19][0m  [36;1m[0.28ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 23:58:19][0m  [36;1m[0.67ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-20 23:58:19][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-20 23:58:20][0m  [36;1m[0.56ms][0m  SELECT * FROM `tags`    
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 23:58:20][0m  [36;1m[0.27ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 23:58:20][0m  [36;1m[0.72ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:31)[0m 
[33m[2020-07-20 23:58:20][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `tags`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 23:58:24][0m  [36;1m[0.57ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 23:58:24][0m  [36;1m[0.28ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:137)[0m 
[33m[2020-07-20 23:58:24][0m  [36;1m[0.63ms][0m   SELECT * FROM `blogs` GROUP BY YEAR DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:150)[0m 
[33m[2020-07-20 23:58:24][0m  [36;1m[0.75ms][0m   SELECT * FROM `blogs` where year = 2020 GROUP BY month DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:162)[0m 
[33m[2020-07-20 23:58:24][0m  [36;1m[0.59ms][0m   SELECT * FROM `blogs` where year = 2020 and month = 7 ORDER BY `id` DESC  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 23:58:24][0m  [36;1m[0.37ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=4  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 23:58:24][0m  [36;1m[0.33ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=3  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 23:58:24][0m  [36;1m[0.33ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=2  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 23:58:24][0m  [36;1m[0.32ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 23:58:25][0m  [36;1m[0.71ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 23:58:25][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 23:58:25][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:137)[0m 
[33m[2020-07-20 23:58:25][0m  [36;1m[0.62ms][0m   SELECT * FROM `blogs` GROUP BY YEAR DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:150)[0m 
[33m[2020-07-20 23:58:25][0m  [36;1m[0.64ms][0m   SELECT * FROM `blogs` where year = 2020 GROUP BY month DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:162)[0m 
[33m[2020-07-20 23:58:25][0m  [36;1m[1.17ms][0m   SELECT * FROM `blogs` where year = 2020 and month = 7 ORDER BY `id` DESC  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 23:58:25][0m  [36;1m[2.38ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=4  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 23:58:25][0m  [36;1m[0.34ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=3  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 23:58:25][0m  [36;1m[0.35ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=2  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-20 23:58:25][0m  [36;1m[0.33ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-20 23:58:29][0m  [36;1m[0.35ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 4)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-20 23:58:29][0m  [36;1m[0.49ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=4  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-20 23:58:29][0m  [36;1m[0.47ms][0m  UPDATE `blogs` SET `title` = '本博客开源公告', `content` = '今天本博客评论功能发布
# 自今天起，本博客基本功能已经完成
## 发布V1.0版本并开源
## 博客语言说明
#### 本博客后端是用golang 的gin框架+gorm编写
前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的
#### 博客效果参考本站
#一、博客简介
## 1.博客目录

    blog
    ├────controller
	├────└───admin
	|	|	├──adminblog.go
	|	|	├───adminController.go
	|	|	├──adminTag.go
	|	|	├──adminType.go
	|	|	└──adminUser.go
	|	└──page
	|		├──404.go
	|		├───about.go
	|		├──archives.go
	|		├──blog.go
	|		├──comment.go
	|		├──pagesController.go
	|		├──researchController.go
	|		└──tagsController.go
    ├── dao
	│	├──blogs.go
	│	├──comment.go
	│	├──sql.go
	│	├──tags.go
	│	├──types.go
	│	└──user.go
    ├── logic
    │   └── user.go
    ├── middlerware
	│	├──function.go
	│	├──getImg.go
	│	├──getTime.go
	│	├──markdown.go
	│	├──select.go
	│	└──session.go
    ├── model
	│	├──blog.go
	│	├──commnent.go
	│	├──tag.go
	│	├──type.go
	│	└──user/go
    ├── static
	│	└──静态文件（头像、图片、logo、css、js等）
    ├── templates
	│	└──html模板文件
    ├── go.mod（依赖）
    └── main.go
    

## 2.相关功能实现简介
### 1、评论及回复功能
comment的结构体属性如下
```go
package model

type Comment struct {
	Id     int //评论id
	BlogId int //博文id
	ReCommentId    int    //父评论id
	CommentName string //评论人姓名
	ReCommentName  string //父评论人姓名
	CommentEmail   string
	Img            string
	CommentContent string `gorm:"type:text" form:"CommentContent" json:"CommentContent"` //评论内容
	CommentTime    string ` json:"comment_time,omitempty"`
	Parent         *Comment
	Comments       []Comment
}
```
#### 实现方法
##### 1先通过查找父评论为-1的顶级评论
父评论Id为-1说明他不是任何评论的子评论
##### 2在html上遍历所有的顶级评论
在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论
###### （1）递归存储每个顶级评论的子评论
这里我用一个切片来储存一个顶级评论的所有子评论
```go
var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
	var comments []model.Comment
	DB.Debug().Where("re_comment_id = -1 AND blog_id = ?", id).Find(&comments)
	return &comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
	if count != 0 {
		fmt.Println("if判断1")
		var comments []model.Comment
		DB.Debug().Where("re_comment_id = ?", id).Find(&comments)
		count = len(comments)
		if count != 0 {
			fmt.Println("if判断2")
			for _, comment := range comments {
				fmt.Println("for判断1")
				Comments = append(Comments, comment)
				SelectCommentByComment(comment.Id, count)
			}
		}
	}
	fmt.Println(Comments)
	return &Comments

}
```
ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来
###### （2）出现问题的原因
因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量
###### （3）解决问题
```go
func ClearComments() bool {
	var comments []model.Comment
	Comments = comments
	return true
}

```
这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现
#### 这里我还加了一个小小的随机头像功能
```go
if  CommentName == user.Name && CommentEmail == user.UserEmail {
		fmt.Println("进入了1")
		comment.Img =user.UserImg
		//找相同评论人
	}else if CommentName == one.CommentName && CommentEmail == one.CommentEmail {
		fmt.Println("进入了2")
		comment.Img =one.Img
		//随机选头像
	}else{
		fmt.Println("进入了3")
		comment.Img =middleware.GetImg()
	}
```
##### 123分别代表三种不同的用户群体
1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
![](/static/images/%e5%a4%b4%e5%83%8f1.png)![](/static/images/%e5%a4%b4%e5%83%8f2.png)![](/static/images/%e5%a4%b4%e5%83%8f3.png)![](/static/images/%e5%a4%b4%e5%83%8f4.png)![](/static/images/%e5%a4%b4%e5%83%8f5.png)![](/static/images/%e5%a4%b4%e5%83%8f6.png)
### 2、归档功能
#### blog的结构体属性如下
```go
package model

type Blog struct {
	Id           int
	Title        string    `form:"title" json:"title"`                          //标题
	Content      string    `gorm:"type:longtext" form:"content" json:"content"` //内容
	Image        string    `gorm:"type:text" form:"image" json:"image"`         //首图
	Numb         int       `form:"numb" json:"numb"`                            //次数
	Flag         string    `form:"flag" json:"flag"`                            //原创或者转载
	Appreciation string    `form:"appreciation" json:"appreciation"`            //打赏开关
	ShareInfo    string    `form:"shareInfo" json:"shareInfo"`                  //版权开关
	Comment      string    `form:"comment" json:"comment"`                      //评论开关
	Recommend    string    `form:"recommend" json:"recommend"`                  //推荐开关
	Description  string    `gorm:"type:text" form:"description" json:"description"`
	CreatTime    string    `form:"creatTime"  json:"creat_time,omitempty"`   //创建时间
	UpdateTime   string    `form:"updateTime"  json:"update_time,omitempty"` //更新时间
	Comments     []Comment `form:"comments" json:"comments"`
	TypeId       int       `form:"typeId" json:"typeId"`
	Type         Type      `form:"type" gorm:"ForeignKey:TypeId"`
	Year         int       `form:"year" json:"year"`
	Month        int       `form:"month" json:"month"`
	Day          int       `form:"day" json:"day"`
}

```
#### 实现方法
我的思路是创建三个时间节点
year month day 
利用sql分组查询
##### Group By分组查询步骤
###### （1）先按照年份查询
###### （2）再按照年份遍历每个月份
并将所有保存在一个切片中
###### （3）按照月份遍历每个月的所有文章
保存在一个Map中，key是对应的月份，value是每个月份的所有文章
#### 自此归档功能实现


## 3.已知BUG
### 后台退出功能
后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧

开源地址
[github](https://github.com/likewl/blog "github")
[gitee](https://gitee.com/nculike/blog "gitee")', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1535821573,4166447487&fm=26&gp=0.jpg', `numb` = 9, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '本博客后端是用golang 的gin框架+gorm编写', `creat_time` = '2020-07-20 15:24:23', `update_time` = '2020-07-20 15:24:23', `type_id` = 4, `year` = 2020, `month` = 7, `day` = 20  WHERE `blogs`.`id` = 4  
[36;31m[1 rows affected or returned ][0m 
<p>今天本博客评论功能发布</p>

<h1>自今天起，本博客基本功能已经完成</h1>

<h2>发布V1.0版本并开源</h2>

<h2>博客语言说明</h2>

<h4>本博客后端是用golang 的gin框架+gorm编写</h4>

<p>前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的</p>

<h4>博客效果参考本站</h4>

<p>#一、博客简介</p>

<h2>1.博客目录</h2>

<pre><code>blog
├────controller
├────└───admin
|   |   ├──adminblog.go
|   |   ├───adminController.go
|   |   ├──adminTag.go
|   |   ├──adminType.go
|   |   └──adminUser.go
|   └──page
|       ├──404.go
|       ├───about.go
|       ├──archives.go
|       ├──blog.go
|       ├──comment.go
|       ├──pagesController.go
|       ├──researchController.go
|       └──tagsController.go
├── dao
│   ├──blogs.go
│   ├──comment.go
│   ├──sql.go
│   ├──tags.go
│   ├──types.go
│   └──user.go
├── logic
│   └── user.go
├── middlerware
│   ├──function.go
│   ├──getImg.go
│   ├──getTime.go
│   ├──markdown.go
│   ├──select.go
│   └──session.go
├── model
│   ├──blog.go
│   ├──commnent.go
│   ├──tag.go
│   ├──type.go
│   └──user/go
├── static
│   └──静态文件（头像、图片、logo、css、js等）
├── templates
│   └──html模板文件
├── go.mod（依赖）
└── main.go
</code></pre>

<h2>2.相关功能实现简介</h2>

<h3>1、评论及回复功能</h3>

<p>comment的结构体属性如下</p>

<pre><code class="language-go">package model

type Comment struct {
    Id     int //评论id
    BlogId int //博文id
    ReCommentId    int    //父评论id
    CommentName string //评论人姓名
    ReCommentName  string //父评论人姓名
    CommentEmail   string
    Img            string
    CommentContent string `gorm:&#34;type:text&#34; form:&#34;CommentContent&#34; json:&#34;CommentContent&#34;` //评论内容
    CommentTime    string ` json:&#34;comment_time,omitempty&#34;`
    Parent         *Comment
    Comments       []Comment
}
</code></pre>

<h4>实现方法</h4>

<h5>1先通过查找父评论为-1的顶级评论</h5>

<p>父评论Id为-1说明他不是任何评论的子评论</p>

<h5>2在html上遍历所有的顶级评论</h5>

<p>在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论</p>

<h6>（1）递归存储每个顶级评论的子评论</h6>

<p>这里我用一个切片来储存一个顶级评论的所有子评论</p>

<pre><code class="language-go">var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
    var comments []model.Comment
    DB.Debug().Where(&#34;re_comment_id = -1 AND blog_id = ?&#34;, id).Find(&amp;comments)
    return &amp;comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
    if count != 0 {
        fmt.Println(&#34;if判断1&#34;)
        var comments []model.Comment
        DB.Debug().Where(&#34;re_comment_id = ?&#34;, id).Find(&amp;comments)
        count = len(comments)
        if count != 0 {
            fmt.Println(&#34;if判断2&#34;)
            for _, comment := range comments {
                fmt.Println(&#34;for判断1&#34;)
                Comments = append(Comments, comment)
                SelectCommentByComment(comment.Id, count)
            }
        }
    }
    fmt.Println(Comments)
    return &amp;Comments

}
</code></pre>

<p>ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来</p>

<h6>（2）出现问题的原因</h6>

<p>因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量</p>

<h6>（3）解决问题</h6>

<pre><code class="language-go">func ClearComments() bool {
    var comments []model.Comment
    Comments = comments
    return true
}

</code></pre>

<p>这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现</p>

<h4>这里我还加了一个小小的随机头像功能</h4>

<pre><code class="language-go">if  CommentName == user.Name &amp;&amp; CommentEmail == user.UserEmail {
        fmt.Println(&#34;进入了1&#34;)
        comment.Img =user.UserImg
        //找相同评论人
    }else if CommentName == one.CommentName &amp;&amp; CommentEmail == one.CommentEmail {
        fmt.Println(&#34;进入了2&#34;)
        comment.Img =one.Img
        //随机选头像
    }else{
        fmt.Println(&#34;进入了3&#34;)
        comment.Img =middleware.GetImg()
    }
</code></pre>

<h5>123分别代表三种不同的用户群体</h5>

<p>1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
<img src="/static/images/%e5%a4%b4%e5%83%8f1.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f2.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f3.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f4.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f5.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f6.png" alt=""/></p>

<h3>2、归档功能</h3>

<h4>blog的结构体属性如下</h4>

<pre><code class="language-go">package model

type Blog struct {
    Id           int
    Title        string    `form:&#34;title&#34; json:&#34;title&#34;`                          //标题
    Content      string    `gorm:&#34;type:longtext&#34; form:&#34;content&#34; json:&#34;content&#34;` //内容
    Image        string    `gorm:&#34;type:text&#34; form:&#34;image&#34; json:&#34;image&#34;`         //首图
    Numb         int       `form:&#34;numb&#34; json:&#34;numb&#34;`                            //次数
    Flag         string    `form:&#34;flag&#34; json:&#34;flag&#34;`                            //原创或者转载
    Appreciation string    `form:&#34;appreciation&#34; json:&#34;appreciation&#34;`            //打赏开关
    ShareInfo    string    `form:&#34;shareInfo&#34; json:&#34;shareInfo&#34;`                  //版权开关
    Comment      string    `form:&#34;comment&#34; json:&#34;comment&#34;`                      //评论开关
    Recommend    string    `form:&#34;recommend&#34; json:&#34;recommend&#34;`                  //推荐开关
    Description  string    `gorm:&#34;type:text&#34; form:&#34;description&#34; json:&#34;description&#34;`
    CreatTime    string    `form:&#34;creatTime&#34;  json:&#34;creat_time,omitempty&#34;`   //创建时间
    UpdateTime   string    `form:&#34;updateTime&#34;  json:&#34;update_time,omitempty&#34;` //更新时间
    Comments     []Comment `form:&#34;comments&#34; json:&#34;comments&#34;`
    TypeId       int       `form:&#34;typeId&#34; json:&#34;typeId&#34;`
    Type         Type      `form:&#34;type&#34; gorm:&#34;ForeignKey:TypeId&#34;`
    Year         int       `form:&#34;year&#34; json:&#34;year&#34;`
    Month        int       `form:&#34;month&#34; json:&#34;month&#34;`
    Day          int       `form:&#34;day&#34; json:&#34;day&#34;`
}

</code></pre>

<h4>实现方法</h4>

<p>我的思路是创建三个时间节点
year month day
利用sql分组查询</p>

<h5>Group By分组查询步骤</h5>

<h6>（1）先按照年份查询</h6>

<h6>（2）再按照年份遍历每个月份</h6>

<p>并将所有保存在一个切片中</p>

<h6>（3）按照月份遍历每个月的所有文章</h6>

<p>保存在一个Map中，key是对应的月份，value是每个月份的所有文章</p>

<h4>自此归档功能实现</h4>

<h2>3.已知BUG</h2>

<h3>后台退出功能</h3>

<p>后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧</p>

<p>开源地址
<a href="https://github.com/likewl/blog" title="github" rel="nofollow">github</a>
<a href="https://gitee.com/nculike/blog" title="gitee" rel="nofollow">gitee</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 23:58:29][0m  [36;1m[0.29ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-20 23:58:34][0m  [36;1m[0.36ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 4)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-20 23:58:34][0m  [36;1m[0.46ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=4  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-20 23:58:34][0m  [36;1m[0.44ms][0m  UPDATE `blogs` SET `title` = '本博客开源公告', `content` = '今天本博客评论功能发布
# 自今天起，本博客基本功能已经完成
## 发布V1.0版本并开源
## 博客语言说明
#### 本博客后端是用golang 的gin框架+gorm编写
前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的
#### 博客效果参考本站
#一、博客简介
## 1.博客目录

    blog
    ├────controller
	├────└───admin
	|	|	├──adminblog.go
	|	|	├───adminController.go
	|	|	├──adminTag.go
	|	|	├──adminType.go
	|	|	└──adminUser.go
	|	└──page
	|		├──404.go
	|		├───about.go
	|		├──archives.go
	|		├──blog.go
	|		├──comment.go
	|		├──pagesController.go
	|		├──researchController.go
	|		└──tagsController.go
    ├── dao
	│	├──blogs.go
	│	├──comment.go
	│	├──sql.go
	│	├──tags.go
	│	├──types.go
	│	└──user.go
    ├── logic
    │   └── user.go
    ├── middlerware
	│	├──function.go
	│	├──getImg.go
	│	├──getTime.go
	│	├──markdown.go
	│	├──select.go
	│	└──session.go
    ├── model
	│	├──blog.go
	│	├──commnent.go
	│	├──tag.go
	│	├──type.go
	│	└──user/go
    ├── static
	│	└──静态文件（头像、图片、logo、css、js等）
    ├── templates
	│	└──html模板文件
    ├── go.mod（依赖）
    └── main.go
    

## 2.相关功能实现简介
### 1、评论及回复功能
comment的结构体属性如下
```go
package model

type Comment struct {
	Id     int //评论id
	BlogId int //博文id
	ReCommentId    int    //父评论id
	CommentName string //评论人姓名
	ReCommentName  string //父评论人姓名
	CommentEmail   string
	Img            string
	CommentContent string `gorm:"type:text" form:"CommentContent" json:"CommentContent"` //评论内容
	CommentTime    string ` json:"comment_time,omitempty"`
	Parent         *Comment
	Comments       []Comment
}
```
#### 实现方法
##### 1先通过查找父评论为-1的顶级评论
父评论Id为-1说明他不是任何评论的子评论
##### 2在html上遍历所有的顶级评论
在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论
###### （1）递归存储每个顶级评论的子评论
这里我用一个切片来储存一个顶级评论的所有子评论
```go
var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
	var comments []model.Comment
	DB.Debug().Where("re_comment_id = -1 AND blog_id = ?", id).Find(&comments)
	return &comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
	if count != 0 {
		fmt.Println("if判断1")
		var comments []model.Comment
		DB.Debug().Where("re_comment_id = ?", id).Find(&comments)
		count = len(comments)
		if count != 0 {
			fmt.Println("if判断2")
			for _, comment := range comments {
				fmt.Println("for判断1")
				Comments = append(Comments, comment)
				SelectCommentByComment(comment.Id, count)
			}
		}
	}
	fmt.Println(Comments)
	return &Comments

}
```
ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来
###### （2）出现问题的原因
因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量
###### （3）解决问题
```go
func ClearComments() bool {
	var comments []model.Comment
	Comments = comments
	return true
}

```
这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现
#### 这里我还加了一个小小的随机头像功能
```go
if  CommentName == user.Name && CommentEmail == user.UserEmail {
		fmt.Println("进入了1")
		comment.Img =user.UserImg
		//找相同评论人
	}else if CommentName == one.CommentName && CommentEmail == one.CommentEmail {
		fmt.Println("进入了2")
		comment.Img =one.Img
		//随机选头像
	}else{
		fmt.Println("进入了3")
		comment.Img =middleware.GetImg()
	}
```
##### 123分别代表三种不同的用户群体
1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
![](/static/images/%e5%a4%b4%e5%83%8f1.png)![](/static/images/%e5%a4%b4%e5%83%8f2.png)![](/static/images/%e5%a4%b4%e5%83%8f3.png)![](/static/images/%e5%a4%b4%e5%83%8f4.png)![](/static/images/%e5%a4%b4%e5%83%8f5.png)![](/static/images/%e5%a4%b4%e5%83%8f6.png)
### 2、归档功能
#### blog的结构体属性如下
```go
package model

type Blog struct {
	Id           int
	Title        string    `form:"title" json:"title"`                          //标题
	Content      string    `gorm:"type:longtext" form:"content" json:"content"` //内容
	Image        string    `gorm:"type:text" form:"image" json:"image"`         //首图
	Numb         int       `form:"numb" json:"numb"`                            //次数
	Flag         string    `form:"flag" json:"flag"`                            //原创或者转载
	Appreciation string    `form:"appreciation" json:"appreciation"`            //打赏开关
	ShareInfo    string    `form:"shareInfo" json:"shareInfo"`                  //版权开关
	Comment      string    `form:"comment" json:"comment"`                      //评论开关
	Recommend    string    `form:"recommend" json:"recommend"`                  //推荐开关
	Description  string    `gorm:"type:text" form:"description" json:"description"`
	CreatTime    string    `form:"creatTime"  json:"creat_time,omitempty"`   //创建时间
	UpdateTime   string    `form:"updateTime"  json:"update_time,omitempty"` //更新时间
	Comments     []Comment `form:"comments" json:"comments"`
	TypeId       int       `form:"typeId" json:"typeId"`
	Type         Type      `form:"type" gorm:"ForeignKey:TypeId"`
	Year         int       `form:"year" json:"year"`
	Month        int       `form:"month" json:"month"`
	Day          int       `form:"day" json:"day"`
}

```
#### 实现方法
我的思路是创建三个时间节点
year month day 
利用sql分组查询
##### Group By分组查询步骤
###### （1）先按照年份查询
###### （2）再按照年份遍历每个月份
并将所有保存在一个切片中
###### （3）按照月份遍历每个月的所有文章
保存在一个Map中，key是对应的月份，value是每个月份的所有文章
#### 自此归档功能实现


## 3.已知BUG
### 后台退出功能
后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧

开源地址
[github](https://github.com/likewl/blog "github")
[gitee](https://gitee.com/nculike/blog "gitee")', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1535821573,4166447487&fm=26&gp=0.jpg', `numb` = 10, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '本博客后端是用golang 的gin框架+gorm编写', `creat_time` = '2020-07-20 15:24:23', `update_time` = '2020-07-20 15:24:23', `type_id` = 4, `year` = 2020, `month` = 7, `day` = 20  WHERE `blogs`.`id` = 4  
[36;31m[1 rows affected or returned ][0m 
<p>今天本博客评论功能发布</p>

<h1>自今天起，本博客基本功能已经完成</h1>

<h2>发布V1.0版本并开源</h2>

<h2>博客语言说明</h2>

<h4>本博客后端是用golang 的gin框架+gorm编写</h4>

<p>前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的</p>

<h4>博客效果参考本站</h4>

<p>#一、博客简介</p>

<h2>1.博客目录</h2>

<pre><code>blog
├────controller
├────└───admin
|   |   ├──adminblog.go
|   |   ├───adminController.go
|   |   ├──adminTag.go
|   |   ├──adminType.go
|   |   └──adminUser.go
|   └──page
|       ├──404.go
|       ├───about.go
|       ├──archives.go
|       ├──blog.go
|       ├──comment.go
|       ├──pagesController.go
|       ├──researchController.go
|       └──tagsController.go
├── dao
│   ├──blogs.go
│   ├──comment.go
│   ├──sql.go
│   ├──tags.go
│   ├──types.go
│   └──user.go
├── logic
│   └── user.go
├── middlerware
│   ├──function.go
│   ├──getImg.go
│   ├──getTime.go
│   ├──markdown.go
│   ├──select.go
│   └──session.go
├── model
│   ├──blog.go
│   ├──commnent.go
│   ├──tag.go
│   ├──type.go
│   └──user/go
├── static
│   └──静态文件（头像、图片、logo、css、js等）
├── templates
│   └──html模板文件
├── go.mod（依赖）
└── main.go
</code></pre>

<h2>2.相关功能实现简介</h2>

<h3>1、评论及回复功能</h3>

<p>comment的结构体属性如下</p>

<pre><code class="language-go">package model

type Comment struct {
    Id     int //评论id
    BlogId int //博文id
    ReCommentId    int    //父评论id
    CommentName string //评论人姓名
    ReCommentName  string //父评论人姓名
    CommentEmail   string
    Img            string
    CommentContent string `gorm:&#34;type:text&#34; form:&#34;CommentContent&#34; json:&#34;CommentContent&#34;` //评论内容
    CommentTime    string ` json:&#34;comment_time,omitempty&#34;`
    Parent         *Comment
    Comments       []Comment
}
</code></pre>

<h4>实现方法</h4>

<h5>1先通过查找父评论为-1的顶级评论</h5>

<p>父评论Id为-1说明他不是任何评论的子评论</p>

<h5>2在html上遍历所有的顶级评论</h5>

<p>在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论</p>

<h6>（1）递归存储每个顶级评论的子评论</h6>

<p>这里我用一个切片来储存一个顶级评论的所有子评论</p>

<pre><code class="language-go">var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
    var comments []model.Comment
    DB.Debug().Where(&#34;re_comment_id = -1 AND blog_id = ?&#34;, id).Find(&amp;comments)
    return &amp;comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
    if count != 0 {
        fmt.Println(&#34;if判断1&#34;)
        var comments []model.Comment
        DB.Debug().Where(&#34;re_comment_id = ?&#34;, id).Find(&amp;comments)
        count = len(comments)
        if count != 0 {
            fmt.Println(&#34;if判断2&#34;)
            for _, comment := range comments {
                fmt.Println(&#34;for判断1&#34;)
                Comments = append(Comments, comment)
                SelectCommentByComment(comment.Id, count)
            }
        }
    }
    fmt.Println(Comments)
    return &amp;Comments

}
</code></pre>

<p>ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来</p>

<h6>（2）出现问题的原因</h6>

<p>因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量</p>

<h6>（3）解决问题</h6>

<pre><code class="language-go">func ClearComments() bool {
    var comments []model.Comment
    Comments = comments
    return true
}

</code></pre>

<p>这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现</p>

<h4>这里我还加了一个小小的随机头像功能</h4>

<pre><code class="language-go">if  CommentName == user.Name &amp;&amp; CommentEmail == user.UserEmail {
        fmt.Println(&#34;进入了1&#34;)
        comment.Img =user.UserImg
        //找相同评论人
    }else if CommentName == one.CommentName &amp;&amp; CommentEmail == one.CommentEmail {
        fmt.Println(&#34;进入了2&#34;)
        comment.Img =one.Img
        //随机选头像
    }else{
        fmt.Println(&#34;进入了3&#34;)
        comment.Img =middleware.GetImg()
    }
</code></pre>

<h5>123分别代表三种不同的用户群体</h5>

<p>1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
<img src="/static/images/%e5%a4%b4%e5%83%8f1.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f2.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f3.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f4.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f5.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f6.png" alt=""/></p>

<h3>2、归档功能</h3>

<h4>blog的结构体属性如下</h4>

<pre><code class="language-go">package model

type Blog struct {
    Id           int
    Title        string    `form:&#34;title&#34; json:&#34;title&#34;`                          //标题
    Content      string    `gorm:&#34;type:longtext&#34; form:&#34;content&#34; json:&#34;content&#34;` //内容
    Image        string    `gorm:&#34;type:text&#34; form:&#34;image&#34; json:&#34;image&#34;`         //首图
    Numb         int       `form:&#34;numb&#34; json:&#34;numb&#34;`                            //次数
    Flag         string    `form:&#34;flag&#34; json:&#34;flag&#34;`                            //原创或者转载
    Appreciation string    `form:&#34;appreciation&#34; json:&#34;appreciation&#34;`            //打赏开关
    ShareInfo    string    `form:&#34;shareInfo&#34; json:&#34;shareInfo&#34;`                  //版权开关
    Comment      string    `form:&#34;comment&#34; json:&#34;comment&#34;`                      //评论开关
    Recommend    string    `form:&#34;recommend&#34; json:&#34;recommend&#34;`                  //推荐开关
    Description  string    `gorm:&#34;type:text&#34; form:&#34;description&#34; json:&#34;description&#34;`
    CreatTime    string    `form:&#34;creatTime&#34;  json:&#34;creat_time,omitempty&#34;`   //创建时间
    UpdateTime   string    `form:&#34;updateTime&#34;  json:&#34;update_time,omitempty&#34;` //更新时间
    Comments     []Comment `form:&#34;comments&#34; json:&#34;comments&#34;`
    TypeId       int       `form:&#34;typeId&#34; json:&#34;typeId&#34;`
    Type         Type      `form:&#34;type&#34; gorm:&#34;ForeignKey:TypeId&#34;`
    Year         int       `form:&#34;year&#34; json:&#34;year&#34;`
    Month        int       `form:&#34;month&#34; json:&#34;month&#34;`
    Day          int       `form:&#34;day&#34; json:&#34;day&#34;`
}

</code></pre>

<h4>实现方法</h4>

<p>我的思路是创建三个时间节点
year month day
利用sql分组查询</p>

<h5>Group By分组查询步骤</h5>

<h6>（1）先按照年份查询</h6>

<h6>（2）再按照年份遍历每个月份</h6>

<p>并将所有保存在一个切片中</p>

<h6>（3）按照月份遍历每个月的所有文章</h6>

<p>保存在一个Map中，key是对应的月份，value是每个月份的所有文章</p>

<h4>自此归档功能实现</h4>

<h2>3.已知BUG</h2>

<h3>后台退出功能</h3>

<p>后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧</p>

<p>开源地址
<a href="https://github.com/likewl/blog" title="github" rel="nofollow">github</a>
<a href="https://gitee.com/nculike/blog" title="gitee" rel="nofollow">gitee</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 23:58:34][0m  [36;1m[0.26ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-20 23:58:53][0m  [36;1m[0.38ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 4)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-20 23:58:53][0m  [36;1m[0.51ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=4  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-20 23:58:53][0m  [36;1m[0.53ms][0m  UPDATE `blogs` SET `title` = '本博客开源公告', `content` = '今天本博客评论功能发布
# 自今天起，本博客基本功能已经完成
## 发布V1.0版本并开源
## 博客语言说明
#### 本博客后端是用golang 的gin框架+gorm编写
前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的
#### 博客效果参考本站
#一、博客简介
## 1.博客目录

    blog
    ├────controller
	├────└───admin
	|	|	├──adminblog.go
	|	|	├───adminController.go
	|	|	├──adminTag.go
	|	|	├──adminType.go
	|	|	└──adminUser.go
	|	└──page
	|		├──404.go
	|		├───about.go
	|		├──archives.go
	|		├──blog.go
	|		├──comment.go
	|		├──pagesController.go
	|		├──researchController.go
	|		└──tagsController.go
    ├── dao
	│	├──blogs.go
	│	├──comment.go
	│	├──sql.go
	│	├──tags.go
	│	├──types.go
	│	└──user.go
    ├── logic
    │   └── user.go
    ├── middlerware
	│	├──function.go
	│	├──getImg.go
	│	├──getTime.go
	│	├──markdown.go
	│	├──select.go
	│	└──session.go
    ├── model
	│	├──blog.go
	│	├──commnent.go
	│	├──tag.go
	│	├──type.go
	│	└──user/go
    ├── static
	│	└──静态文件（头像、图片、logo、css、js等）
    ├── templates
	│	└──html模板文件
    ├── go.mod（依赖）
    └── main.go
    

## 2.相关功能实现简介
### 1、评论及回复功能
comment的结构体属性如下
```go
package model

type Comment struct {
	Id     int //评论id
	BlogId int //博文id
	ReCommentId    int    //父评论id
	CommentName string //评论人姓名
	ReCommentName  string //父评论人姓名
	CommentEmail   string
	Img            string
	CommentContent string `gorm:"type:text" form:"CommentContent" json:"CommentContent"` //评论内容
	CommentTime    string ` json:"comment_time,omitempty"`
	Parent         *Comment
	Comments       []Comment
}
```
#### 实现方法
##### 1先通过查找父评论为-1的顶级评论
父评论Id为-1说明他不是任何评论的子评论
##### 2在html上遍历所有的顶级评论
在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论
###### （1）递归存储每个顶级评论的子评论
这里我用一个切片来储存一个顶级评论的所有子评论
```go
var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
	var comments []model.Comment
	DB.Debug().Where("re_comment_id = -1 AND blog_id = ?", id).Find(&comments)
	return &comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
	if count != 0 {
		fmt.Println("if判断1")
		var comments []model.Comment
		DB.Debug().Where("re_comment_id = ?", id).Find(&comments)
		count = len(comments)
		if count != 0 {
			fmt.Println("if判断2")
			for _, comment := range comments {
				fmt.Println("for判断1")
				Comments = append(Comments, comment)
				SelectCommentByComment(comment.Id, count)
			}
		}
	}
	fmt.Println(Comments)
	return &Comments

}
```
ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来
###### （2）出现问题的原因
因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量
###### （3）解决问题
```go
func ClearComments() bool {
	var comments []model.Comment
	Comments = comments
	return true
}

```
这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现
#### 这里我还加了一个小小的随机头像功能
```go
if  CommentName == user.Name && CommentEmail == user.UserEmail {
		fmt.Println("进入了1")
		comment.Img =user.UserImg
		//找相同评论人
	}else if CommentName == one.CommentName && CommentEmail == one.CommentEmail {
		fmt.Println("进入了2")
		comment.Img =one.Img
		//随机选头像
	}else{
		fmt.Println("进入了3")
		comment.Img =middleware.GetImg()
	}
```
##### 123分别代表三种不同的用户群体
1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
![](/static/images/%e5%a4%b4%e5%83%8f1.png)![](/static/images/%e5%a4%b4%e5%83%8f2.png)![](/static/images/%e5%a4%b4%e5%83%8f3.png)![](/static/images/%e5%a4%b4%e5%83%8f4.png)![](/static/images/%e5%a4%b4%e5%83%8f5.png)![](/static/images/%e5%a4%b4%e5%83%8f6.png)
### 2、归档功能
#### blog的结构体属性如下
```go
package model

type Blog struct {
	Id           int
	Title        string    `form:"title" json:"title"`                          //标题
	Content      string    `gorm:"type:longtext" form:"content" json:"content"` //内容
	Image        string    `gorm:"type:text" form:"image" json:"image"`         //首图
	Numb         int       `form:"numb" json:"numb"`                            //次数
	Flag         string    `form:"flag" json:"flag"`                            //原创或者转载
	Appreciation string    `form:"appreciation" json:"appreciation"`            //打赏开关
	ShareInfo    string    `form:"shareInfo" json:"shareInfo"`                  //版权开关
	Comment      string    `form:"comment" json:"comment"`                      //评论开关
	Recommend    string    `form:"recommend" json:"recommend"`                  //推荐开关
	Description  string    `gorm:"type:text" form:"description" json:"description"`
	CreatTime    string    `form:"creatTime"  json:"creat_time,omitempty"`   //创建时间
	UpdateTime   string    `form:"updateTime"  json:"update_time,omitempty"` //更新时间
	Comments     []Comment `form:"comments" json:"comments"`
	TypeId       int       `form:"typeId" json:"typeId"`
	Type         Type      `form:"type" gorm:"ForeignKey:TypeId"`
	Year         int       `form:"year" json:"year"`
	Month        int       `form:"month" json:"month"`
	Day          int       `form:"day" json:"day"`
}

```
#### 实现方法
我的思路是创建三个时间节点
year month day 
利用sql分组查询
##### Group By分组查询步骤
###### （1）先按照年份查询
###### （2）再按照年份遍历每个月份
并将所有保存在一个切片中
###### （3）按照月份遍历每个月的所有文章
保存在一个Map中，key是对应的月份，value是每个月份的所有文章
#### 自此归档功能实现


## 3.已知BUG
### 后台退出功能
后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧

开源地址
[github](https://github.com/likewl/blog "github")
[gitee](https://gitee.com/nculike/blog "gitee")', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1535821573,4166447487&fm=26&gp=0.jpg', `numb` = 11, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '本博客后端是用golang 的gin框架+gorm编写', `creat_time` = '2020-07-20 15:24:23', `update_time` = '2020-07-20 15:24:23', `type_id` = 4, `year` = 2020, `month` = 7, `day` = 20  WHERE `blogs`.`id` = 4  
[36;31m[1 rows affected or returned ][0m 
<p>今天本博客评论功能发布</p>

<h1>自今天起，本博客基本功能已经完成</h1>

<h2>发布V1.0版本并开源</h2>

<h2>博客语言说明</h2>

<h4>本博客后端是用golang 的gin框架+gorm编写</h4>

<p>前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的</p>

<h4>博客效果参考本站</h4>

<p>#一、博客简介</p>

<h2>1.博客目录</h2>

<pre><code>blog
├────controller
├────└───admin
|   |   ├──adminblog.go
|   |   ├───adminController.go
|   |   ├──adminTag.go
|   |   ├──adminType.go
|   |   └──adminUser.go
|   └──page
|       ├──404.go
|       ├───about.go
|       ├──archives.go
|       ├──blog.go
|       ├──comment.go
|       ├──pagesController.go
|       ├──researchController.go
|       └──tagsController.go
├── dao
│   ├──blogs.go
│   ├──comment.go
│   ├──sql.go
│   ├──tags.go
│   ├──types.go
│   └──user.go
├── logic
│   └── user.go
├── middlerware
│   ├──function.go
│   ├──getImg.go
│   ├──getTime.go
│   ├──markdown.go
│   ├──select.go
│   └──session.go
├── model
│   ├──blog.go
│   ├──commnent.go
│   ├──tag.go
│   ├──type.go
│   └──user/go
├── static
│   └──静态文件（头像、图片、logo、css、js等）
├── templates
│   └──html模板文件
├── go.mod（依赖）
└── main.go
</code></pre>

<h2>2.相关功能实现简介</h2>

<h3>1、评论及回复功能</h3>

<p>comment的结构体属性如下</p>

<pre><code class="language-go">package model

type Comment struct {
    Id     int //评论id
    BlogId int //博文id
    ReCommentId    int    //父评论id
    CommentName string //评论人姓名
    ReCommentName  string //父评论人姓名
    CommentEmail   string
    Img            string
    CommentContent string `gorm:&#34;type:text&#34; form:&#34;CommentContent&#34; json:&#34;CommentContent&#34;` //评论内容
    CommentTime    string ` json:&#34;comment_time,omitempty&#34;`
    Parent         *Comment
    Comments       []Comment
}
</code></pre>

<h4>实现方法</h4>

<h5>1先通过查找父评论为-1的顶级评论</h5>

<p>父评论Id为-1说明他不是任何评论的子评论</p>

<h5>2在html上遍历所有的顶级评论</h5>

<p>在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论</p>

<h6>（1）递归存储每个顶级评论的子评论</h6>

<p>这里我用一个切片来储存一个顶级评论的所有子评论</p>

<pre><code class="language-go">var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
    var comments []model.Comment
    DB.Debug().Where(&#34;re_comment_id = -1 AND blog_id = ?&#34;, id).Find(&amp;comments)
    return &amp;comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
    if count != 0 {
        fmt.Println(&#34;if判断1&#34;)
        var comments []model.Comment
        DB.Debug().Where(&#34;re_comment_id = ?&#34;, id).Find(&amp;comments)
        count = len(comments)
        if count != 0 {
            fmt.Println(&#34;if判断2&#34;)
            for _, comment := range comments {
                fmt.Println(&#34;for判断1&#34;)
                Comments = append(Comments, comment)
                SelectCommentByComment(comment.Id, count)
            }
        }
    }
    fmt.Println(Comments)
    return &amp;Comments

}
</code></pre>

<p>ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来</p>

<h6>（2）出现问题的原因</h6>

<p>因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量</p>

<h6>（3）解决问题</h6>

<pre><code class="language-go">func ClearComments() bool {
    var comments []model.Comment
    Comments = comments
    return true
}

</code></pre>

<p>这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现</p>

<h4>这里我还加了一个小小的随机头像功能</h4>

<pre><code class="language-go">if  CommentName == user.Name &amp;&amp; CommentEmail == user.UserEmail {
        fmt.Println(&#34;进入了1&#34;)
        comment.Img =user.UserImg
        //找相同评论人
    }else if CommentName == one.CommentName &amp;&amp; CommentEmail == one.CommentEmail {
        fmt.Println(&#34;进入了2&#34;)
        comment.Img =one.Img
        //随机选头像
    }else{
        fmt.Println(&#34;进入了3&#34;)
        comment.Img =middleware.GetImg()
    }
</code></pre>

<h5>123分别代表三种不同的用户群体</h5>

<p>1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
<img src="/static/images/%e5%a4%b4%e5%83%8f1.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f2.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f3.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f4.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f5.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f6.png" alt=""/></p>

<h3>2、归档功能</h3>

<h4>blog的结构体属性如下</h4>

<pre><code class="language-go">package model

type Blog struct {
    Id           int
    Title        string    `form:&#34;title&#34; json:&#34;title&#34;`                          //标题
    Content      string    `gorm:&#34;type:longtext&#34; form:&#34;content&#34; json:&#34;content&#34;` //内容
    Image        string    `gorm:&#34;type:text&#34; form:&#34;image&#34; json:&#34;image&#34;`         //首图
    Numb         int       `form:&#34;numb&#34; json:&#34;numb&#34;`                            //次数
    Flag         string    `form:&#34;flag&#34; json:&#34;flag&#34;`                            //原创或者转载
    Appreciation string    `form:&#34;appreciation&#34; json:&#34;appreciation&#34;`            //打赏开关
    ShareInfo    string    `form:&#34;shareInfo&#34; json:&#34;shareInfo&#34;`                  //版权开关
    Comment      string    `form:&#34;comment&#34; json:&#34;comment&#34;`                      //评论开关
    Recommend    string    `form:&#34;recommend&#34; json:&#34;recommend&#34;`                  //推荐开关
    Description  string    `gorm:&#34;type:text&#34; form:&#34;description&#34; json:&#34;description&#34;`
    CreatTime    string    `form:&#34;creatTime&#34;  json:&#34;creat_time,omitempty&#34;`   //创建时间
    UpdateTime   string    `form:&#34;updateTime&#34;  json:&#34;update_time,omitempty&#34;` //更新时间
    Comments     []Comment `form:&#34;comments&#34; json:&#34;comments&#34;`
    TypeId       int       `form:&#34;typeId&#34; json:&#34;typeId&#34;`
    Type         Type      `form:&#34;type&#34; gorm:&#34;ForeignKey:TypeId&#34;`
    Year         int       `form:&#34;year&#34; json:&#34;year&#34;`
    Month        int       `form:&#34;month&#34; json:&#34;month&#34;`
    Day          int       `form:&#34;day&#34; json:&#34;day&#34;`
}

</code></pre>

<h4>实现方法</h4>

<p>我的思路是创建三个时间节点
year month day
利用sql分组查询</p>

<h5>Group By分组查询步骤</h5>

<h6>（1）先按照年份查询</h6>

<h6>（2）再按照年份遍历每个月份</h6>

<p>并将所有保存在一个切片中</p>

<h6>（3）按照月份遍历每个月的所有文章</h6>

<p>保存在一个Map中，key是对应的月份，value是每个月份的所有文章</p>

<h4>自此归档功能实现</h4>

<h2>3.已知BUG</h2>

<h3>后台退出功能</h3>

<p>后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧</p>

<p>开源地址
<a href="https://github.com/likewl/blog" title="github" rel="nofollow">github</a>
<a href="https://gitee.com/nculike/blog" title="gitee" rel="nofollow">gitee</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 23:58:53][0m  [36;1m[0.29ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-20 23:59:09][0m  [36;1m[0.36ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 4)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-20 23:59:09][0m  [36;1m[0.43ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=4  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-20 23:59:09][0m  [36;1m[0.48ms][0m  UPDATE `blogs` SET `title` = '本博客开源公告', `content` = '今天本博客评论功能发布
# 自今天起，本博客基本功能已经完成
## 发布V1.0版本并开源
## 博客语言说明
#### 本博客后端是用golang 的gin框架+gorm编写
前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的
#### 博客效果参考本站
#一、博客简介
## 1.博客目录

    blog
    ├────controller
	├────└───admin
	|	|	├──adminblog.go
	|	|	├───adminController.go
	|	|	├──adminTag.go
	|	|	├──adminType.go
	|	|	└──adminUser.go
	|	└──page
	|		├──404.go
	|		├───about.go
	|		├──archives.go
	|		├──blog.go
	|		├──comment.go
	|		├──pagesController.go
	|		├──researchController.go
	|		└──tagsController.go
    ├── dao
	│	├──blogs.go
	│	├──comment.go
	│	├──sql.go
	│	├──tags.go
	│	├──types.go
	│	└──user.go
    ├── logic
    │   └── user.go
    ├── middlerware
	│	├──function.go
	│	├──getImg.go
	│	├──getTime.go
	│	├──markdown.go
	│	├──select.go
	│	└──session.go
    ├── model
	│	├──blog.go
	│	├──commnent.go
	│	├──tag.go
	│	├──type.go
	│	└──user/go
    ├── static
	│	└──静态文件（头像、图片、logo、css、js等）
    ├── templates
	│	└──html模板文件
    ├── go.mod（依赖）
    └── main.go
    

## 2.相关功能实现简介
### 1、评论及回复功能
comment的结构体属性如下
```go
package model

type Comment struct {
	Id     int //评论id
	BlogId int //博文id
	ReCommentId    int    //父评论id
	CommentName string //评论人姓名
	ReCommentName  string //父评论人姓名
	CommentEmail   string
	Img            string
	CommentContent string `gorm:"type:text" form:"CommentContent" json:"CommentContent"` //评论内容
	CommentTime    string ` json:"comment_time,omitempty"`
	Parent         *Comment
	Comments       []Comment
}
```
#### 实现方法
##### 1先通过查找父评论为-1的顶级评论
父评论Id为-1说明他不是任何评论的子评论
##### 2在html上遍历所有的顶级评论
在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论
###### （1）递归存储每个顶级评论的子评论
这里我用一个切片来储存一个顶级评论的所有子评论
```go
var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
	var comments []model.Comment
	DB.Debug().Where("re_comment_id = -1 AND blog_id = ?", id).Find(&comments)
	return &comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
	if count != 0 {
		fmt.Println("if判断1")
		var comments []model.Comment
		DB.Debug().Where("re_comment_id = ?", id).Find(&comments)
		count = len(comments)
		if count != 0 {
			fmt.Println("if判断2")
			for _, comment := range comments {
				fmt.Println("for判断1")
				Comments = append(Comments, comment)
				SelectCommentByComment(comment.Id, count)
			}
		}
	}
	fmt.Println(Comments)
	return &Comments

}
```
ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来
###### （2）出现问题的原因
因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量
###### （3）解决问题
```go
func ClearComments() bool {
	var comments []model.Comment
	Comments = comments
	return true
}

```
这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现
#### 这里我还加了一个小小的随机头像功能
```go
if  CommentName == user.Name && CommentEmail == user.UserEmail {
		fmt.Println("进入了1")
		comment.Img =user.UserImg
		//找相同评论人
	}else if CommentName == one.CommentName && CommentEmail == one.CommentEmail {
		fmt.Println("进入了2")
		comment.Img =one.Img
		//随机选头像
	}else{
		fmt.Println("进入了3")
		comment.Img =middleware.GetImg()
	}
```
##### 123分别代表三种不同的用户群体
1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
![](/static/images/%e5%a4%b4%e5%83%8f1.png)![](/static/images/%e5%a4%b4%e5%83%8f2.png)![](/static/images/%e5%a4%b4%e5%83%8f3.png)![](/static/images/%e5%a4%b4%e5%83%8f4.png)![](/static/images/%e5%a4%b4%e5%83%8f5.png)![](/static/images/%e5%a4%b4%e5%83%8f6.png)
### 2、归档功能
#### blog的结构体属性如下
```go
package model

type Blog struct {
	Id           int
	Title        string    `form:"title" json:"title"`                          //标题
	Content      string    `gorm:"type:longtext" form:"content" json:"content"` //内容
	Image        string    `gorm:"type:text" form:"image" json:"image"`         //首图
	Numb         int       `form:"numb" json:"numb"`                            //次数
	Flag         string    `form:"flag" json:"flag"`                            //原创或者转载
	Appreciation string    `form:"appreciation" json:"appreciation"`            //打赏开关
	ShareInfo    string    `form:"shareInfo" json:"shareInfo"`                  //版权开关
	Comment      string    `form:"comment" json:"comment"`                      //评论开关
	Recommend    string    `form:"recommend" json:"recommend"`                  //推荐开关
	Description  string    `gorm:"type:text" form:"description" json:"description"`
	CreatTime    string    `form:"creatTime"  json:"creat_time,omitempty"`   //创建时间
	UpdateTime   string    `form:"updateTime"  json:"update_time,omitempty"` //更新时间
	Comments     []Comment `form:"comments" json:"comments"`
	TypeId       int       `form:"typeId" json:"typeId"`
	Type         Type      `form:"type" gorm:"ForeignKey:TypeId"`
	Year         int       `form:"year" json:"year"`
	Month        int       `form:"month" json:"month"`
	Day          int       `form:"day" json:"day"`
}

```
#### 实现方法
我的思路是创建三个时间节点
year month day 
利用sql分组查询
##### Group By分组查询步骤
###### （1）先按照年份查询
###### （2）再按照年份遍历每个月份
并将所有保存在一个切片中
###### （3）按照月份遍历每个月的所有文章
保存在一个Map中，key是对应的月份，value是每个月份的所有文章
#### 自此归档功能实现


## 3.已知BUG
### 后台退出功能
后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧

开源地址
[github](https://github.com/likewl/blog "github")
[gitee](https://gitee.com/nculike/blog "gitee")', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1535821573,4166447487&fm=26&gp=0.jpg', `numb` = 12, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '本博客后端是用golang 的gin框架+gorm编写', `creat_time` = '2020-07-20 15:24:23', `update_time` = '2020-07-20 15:24:23', `type_id` = 4, `year` = 2020, `month` = 7, `day` = 20  WHERE `blogs`.`id` = 4  
[36;31m[1 rows affected or returned ][0m 
<p>今天本博客评论功能发布</p>

<h1>自今天起，本博客基本功能已经完成</h1>

<h2>发布V1.0版本并开源</h2>

<h2>博客语言说明</h2>

<h4>本博客后端是用golang 的gin框架+gorm编写</h4>

<p>前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的</p>

<h4>博客效果参考本站</h4>

<p>#一、博客简介</p>

<h2>1.博客目录</h2>

<pre><code>blog
├────controller
├────└───admin
|   |   ├──adminblog.go
|   |   ├───adminController.go
|   |   ├──adminTag.go
|   |   ├──adminType.go
|   |   └──adminUser.go
|   └──page
|       ├──404.go
|       ├───about.go
|       ├──archives.go
|       ├──blog.go
|       ├──comment.go
|       ├──pagesController.go
|       ├──researchController.go
|       └──tagsController.go
├── dao
│   ├──blogs.go
│   ├──comment.go
│   ├──sql.go
│   ├──tags.go
│   ├──types.go
│   └──user.go
├── logic
│   └── user.go
├── middlerware
│   ├──function.go
│   ├──getImg.go
│   ├──getTime.go
│   ├──markdown.go
│   ├──select.go
│   └──session.go
├── model
│   ├──blog.go
│   ├──commnent.go
│   ├──tag.go
│   ├──type.go
│   └──user/go
├── static
│   └──静态文件（头像、图片、logo、css、js等）
├── templates
│   └──html模板文件
├── go.mod（依赖）
└── main.go
</code></pre>

<h2>2.相关功能实现简介</h2>

<h3>1、评论及回复功能</h3>

<p>comment的结构体属性如下</p>

<pre><code class="language-go">package model

type Comment struct {
    Id     int //评论id
    BlogId int //博文id
    ReCommentId    int    //父评论id
    CommentName string //评论人姓名
    ReCommentName  string //父评论人姓名
    CommentEmail   string
    Img            string
    CommentContent string `gorm:&#34;type:text&#34; form:&#34;CommentContent&#34; json:&#34;CommentContent&#34;` //评论内容
    CommentTime    string ` json:&#34;comment_time,omitempty&#34;`
    Parent         *Comment
    Comments       []Comment
}
</code></pre>

<h4>实现方法</h4>

<h5>1先通过查找父评论为-1的顶级评论</h5>

<p>父评论Id为-1说明他不是任何评论的子评论</p>

<h5>2在html上遍历所有的顶级评论</h5>

<p>在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论</p>

<h6>（1）递归存储每个顶级评论的子评论</h6>

<p>这里我用一个切片来储存一个顶级评论的所有子评论</p>

<pre><code class="language-go">var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
    var comments []model.Comment
    DB.Debug().Where(&#34;re_comment_id = -1 AND blog_id = ?&#34;, id).Find(&amp;comments)
    return &amp;comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
    if count != 0 {
        fmt.Println(&#34;if判断1&#34;)
        var comments []model.Comment
        DB.Debug().Where(&#34;re_comment_id = ?&#34;, id).Find(&amp;comments)
        count = len(comments)
        if count != 0 {
            fmt.Println(&#34;if判断2&#34;)
            for _, comment := range comments {
                fmt.Println(&#34;for判断1&#34;)
                Comments = append(Comments, comment)
                SelectCommentByComment(comment.Id, count)
            }
        }
    }
    fmt.Println(Comments)
    return &amp;Comments

}
</code></pre>

<p>ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来</p>

<h6>（2）出现问题的原因</h6>

<p>因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量</p>

<h6>（3）解决问题</h6>

<pre><code class="language-go">func ClearComments() bool {
    var comments []model.Comment
    Comments = comments
    return true
}

</code></pre>

<p>这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现</p>

<h4>这里我还加了一个小小的随机头像功能</h4>

<pre><code class="language-go">if  CommentName == user.Name &amp;&amp; CommentEmail == user.UserEmail {
        fmt.Println(&#34;进入了1&#34;)
        comment.Img =user.UserImg
        //找相同评论人
    }else if CommentName == one.CommentName &amp;&amp; CommentEmail == one.CommentEmail {
        fmt.Println(&#34;进入了2&#34;)
        comment.Img =one.Img
        //随机选头像
    }else{
        fmt.Println(&#34;进入了3&#34;)
        comment.Img =middleware.GetImg()
    }
</code></pre>

<h5>123分别代表三种不同的用户群体</h5>

<p>1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
<img src="/static/images/%e5%a4%b4%e5%83%8f1.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f2.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f3.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f4.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f5.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f6.png" alt=""/></p>

<h3>2、归档功能</h3>

<h4>blog的结构体属性如下</h4>

<pre><code class="language-go">package model

type Blog struct {
    Id           int
    Title        string    `form:&#34;title&#34; json:&#34;title&#34;`                          //标题
    Content      string    `gorm:&#34;type:longtext&#34; form:&#34;content&#34; json:&#34;content&#34;` //内容
    Image        string    `gorm:&#34;type:text&#34; form:&#34;image&#34; json:&#34;image&#34;`         //首图
    Numb         int       `form:&#34;numb&#34; json:&#34;numb&#34;`                            //次数
    Flag         string    `form:&#34;flag&#34; json:&#34;flag&#34;`                            //原创或者转载
    Appreciation string    `form:&#34;appreciation&#34; json:&#34;appreciation&#34;`            //打赏开关
    ShareInfo    string    `form:&#34;shareInfo&#34; json:&#34;shareInfo&#34;`                  //版权开关
    Comment      string    `form:&#34;comment&#34; json:&#34;comment&#34;`                      //评论开关
    Recommend    string    `form:&#34;recommend&#34; json:&#34;recommend&#34;`                  //推荐开关
    Description  string    `gorm:&#34;type:text&#34; form:&#34;description&#34; json:&#34;description&#34;`
    CreatTime    string    `form:&#34;creatTime&#34;  json:&#34;creat_time,omitempty&#34;`   //创建时间
    UpdateTime   string    `form:&#34;updateTime&#34;  json:&#34;update_time,omitempty&#34;` //更新时间
    Comments     []Comment `form:&#34;comments&#34; json:&#34;comments&#34;`
    TypeId       int       `form:&#34;typeId&#34; json:&#34;typeId&#34;`
    Type         Type      `form:&#34;type&#34; gorm:&#34;ForeignKey:TypeId&#34;`
    Year         int       `form:&#34;year&#34; json:&#34;year&#34;`
    Month        int       `form:&#34;month&#34; json:&#34;month&#34;`
    Day          int       `form:&#34;day&#34; json:&#34;day&#34;`
}

</code></pre>

<h4>实现方法</h4>

<p>我的思路是创建三个时间节点
year month day
利用sql分组查询</p>

<h5>Group By分组查询步骤</h5>

<h6>（1）先按照年份查询</h6>

<h6>（2）再按照年份遍历每个月份</h6>

<p>并将所有保存在一个切片中</p>

<h6>（3）按照月份遍历每个月的所有文章</h6>

<p>保存在一个Map中，key是对应的月份，value是每个月份的所有文章</p>

<h4>自此归档功能实现</h4>

<h2>3.已知BUG</h2>

<h3>后台退出功能</h3>

<p>后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧</p>

<p>开源地址
<a href="https://github.com/likewl/blog" title="github" rel="nofollow">github</a>
<a href="https://gitee.com/nculike/blog" title="gitee" rel="nofollow">gitee</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 23:59:09][0m  [36;1m[0.25ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-20 23:59:15][0m  [36;1m[0.40ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 4)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-20 23:59:15][0m  [36;1m[0.45ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=4  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-20 23:59:15][0m  [36;1m[0.45ms][0m  UPDATE `blogs` SET `title` = '本博客开源公告', `content` = '今天本博客评论功能发布
# 自今天起，本博客基本功能已经完成
## 发布V1.0版本并开源
## 博客语言说明
#### 本博客后端是用golang 的gin框架+gorm编写
前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的
#### 博客效果参考本站
#一、博客简介
## 1.博客目录

    blog
    ├────controller
	├────└───admin
	|	|	├──adminblog.go
	|	|	├───adminController.go
	|	|	├──adminTag.go
	|	|	├──adminType.go
	|	|	└──adminUser.go
	|	└──page
	|		├──404.go
	|		├───about.go
	|		├──archives.go
	|		├──blog.go
	|		├──comment.go
	|		├──pagesController.go
	|		├──researchController.go
	|		└──tagsController.go
    ├── dao
	│	├──blogs.go
	│	├──comment.go
	│	├──sql.go
	│	├──tags.go
	│	├──types.go
	│	└──user.go
    ├── logic
    │   └── user.go
    ├── middlerware
	│	├──function.go
	│	├──getImg.go
	│	├──getTime.go
	│	├──markdown.go
	│	├──select.go
	│	└──session.go
    ├── model
	│	├──blog.go
	│	├──commnent.go
	│	├──tag.go
	│	├──type.go
	│	└──user/go
    ├── static
	│	└──静态文件（头像、图片、logo、css、js等）
    ├── templates
	│	└──html模板文件
    ├── go.mod（依赖）
    └── main.go
    

## 2.相关功能实现简介
### 1、评论及回复功能
comment的结构体属性如下
```go
package model

type Comment struct {
	Id     int //评论id
	BlogId int //博文id
	ReCommentId    int    //父评论id
	CommentName string //评论人姓名
	ReCommentName  string //父评论人姓名
	CommentEmail   string
	Img            string
	CommentContent string `gorm:"type:text" form:"CommentContent" json:"CommentContent"` //评论内容
	CommentTime    string ` json:"comment_time,omitempty"`
	Parent         *Comment
	Comments       []Comment
}
```
#### 实现方法
##### 1先通过查找父评论为-1的顶级评论
父评论Id为-1说明他不是任何评论的子评论
##### 2在html上遍历所有的顶级评论
在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论
###### （1）递归存储每个顶级评论的子评论
这里我用一个切片来储存一个顶级评论的所有子评论
```go
var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
	var comments []model.Comment
	DB.Debug().Where("re_comment_id = -1 AND blog_id = ?", id).Find(&comments)
	return &comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
	if count != 0 {
		fmt.Println("if判断1")
		var comments []model.Comment
		DB.Debug().Where("re_comment_id = ?", id).Find(&comments)
		count = len(comments)
		if count != 0 {
			fmt.Println("if判断2")
			for _, comment := range comments {
				fmt.Println("for判断1")
				Comments = append(Comments, comment)
				SelectCommentByComment(comment.Id, count)
			}
		}
	}
	fmt.Println(Comments)
	return &Comments

}
```
ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来
###### （2）出现问题的原因
因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量
###### （3）解决问题
```go
func ClearComments() bool {
	var comments []model.Comment
	Comments = comments
	return true
}

```
这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现
#### 这里我还加了一个小小的随机头像功能
```go
if  CommentName == user.Name && CommentEmail == user.UserEmail {
		fmt.Println("进入了1")
		comment.Img =user.UserImg
		//找相同评论人
	}else if CommentName == one.CommentName && CommentEmail == one.CommentEmail {
		fmt.Println("进入了2")
		comment.Img =one.Img
		//随机选头像
	}else{
		fmt.Println("进入了3")
		comment.Img =middleware.GetImg()
	}
```
##### 123分别代表三种不同的用户群体
1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
![](/static/images/%e5%a4%b4%e5%83%8f1.png)![](/static/images/%e5%a4%b4%e5%83%8f2.png)![](/static/images/%e5%a4%b4%e5%83%8f3.png)![](/static/images/%e5%a4%b4%e5%83%8f4.png)![](/static/images/%e5%a4%b4%e5%83%8f5.png)![](/static/images/%e5%a4%b4%e5%83%8f6.png)
### 2、归档功能
#### blog的结构体属性如下
```go
package model

type Blog struct {
	Id           int
	Title        string    `form:"title" json:"title"`                          //标题
	Content      string    `gorm:"type:longtext" form:"content" json:"content"` //内容
	Image        string    `gorm:"type:text" form:"image" json:"image"`         //首图
	Numb         int       `form:"numb" json:"numb"`                            //次数
	Flag         string    `form:"flag" json:"flag"`                            //原创或者转载
	Appreciation string    `form:"appreciation" json:"appreciation"`            //打赏开关
	ShareInfo    string    `form:"shareInfo" json:"shareInfo"`                  //版权开关
	Comment      string    `form:"comment" json:"comment"`                      //评论开关
	Recommend    string    `form:"recommend" json:"recommend"`                  //推荐开关
	Description  string    `gorm:"type:text" form:"description" json:"description"`
	CreatTime    string    `form:"creatTime"  json:"creat_time,omitempty"`   //创建时间
	UpdateTime   string    `form:"updateTime"  json:"update_time,omitempty"` //更新时间
	Comments     []Comment `form:"comments" json:"comments"`
	TypeId       int       `form:"typeId" json:"typeId"`
	Type         Type      `form:"type" gorm:"ForeignKey:TypeId"`
	Year         int       `form:"year" json:"year"`
	Month        int       `form:"month" json:"month"`
	Day          int       `form:"day" json:"day"`
}

```
#### 实现方法
我的思路是创建三个时间节点
year month day 
利用sql分组查询
##### Group By分组查询步骤
###### （1）先按照年份查询
###### （2）再按照年份遍历每个月份
并将所有保存在一个切片中
###### （3）按照月份遍历每个月的所有文章
保存在一个Map中，key是对应的月份，value是每个月份的所有文章
#### 自此归档功能实现


## 3.已知BUG
### 后台退出功能
后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧

开源地址
[github](https://github.com/likewl/blog "github")
[gitee](https://gitee.com/nculike/blog "gitee")', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1535821573,4166447487&fm=26&gp=0.jpg', `numb` = 13, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '本博客后端是用golang 的gin框架+gorm编写', `creat_time` = '2020-07-20 15:24:23', `update_time` = '2020-07-20 15:24:23', `type_id` = 4, `year` = 2020, `month` = 7, `day` = 20  WHERE `blogs`.`id` = 4  
[36;31m[1 rows affected or returned ][0m 
<p>今天本博客评论功能发布</p>

<h1>自今天起，本博客基本功能已经完成</h1>

<h2>发布V1.0版本并开源</h2>

<h2>博客语言说明</h2>

<h4>本博客后端是用golang 的gin框架+gorm编写</h4>

<p>前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的</p>

<h4>博客效果参考本站</h4>

<p>#一、博客简介</p>

<h2>1.博客目录</h2>

<pre><code>blog
├────controller
├────└───admin
|   |   ├──adminblog.go
|   |   ├───adminController.go
|   |   ├──adminTag.go
|   |   ├──adminType.go
|   |   └──adminUser.go
|   └──page
|       ├──404.go
|       ├───about.go
|       ├──archives.go
|       ├──blog.go
|       ├──comment.go
|       ├──pagesController.go
|       ├──researchController.go
|       └──tagsController.go
├── dao
│   ├──blogs.go
│   ├──comment.go
│   ├──sql.go
│   ├──tags.go
│   ├──types.go
│   └──user.go
├── logic
│   └── user.go
├── middlerware
│   ├──function.go
│   ├──getImg.go
│   ├──getTime.go
│   ├──markdown.go
│   ├──select.go
│   └──session.go
├── model
│   ├──blog.go
│   ├──commnent.go
│   ├──tag.go
│   ├──type.go
│   └──user/go
├── static
│   └──静态文件（头像、图片、logo、css、js等）
├── templates
│   └──html模板文件
├── go.mod（依赖）
└── main.go
</code></pre>

<h2>2.相关功能实现简介</h2>

<h3>1、评论及回复功能</h3>

<p>comment的结构体属性如下</p>

<pre><code class="language-go">package model

type Comment struct {
    Id     int //评论id
    BlogId int //博文id
    ReCommentId    int    //父评论id
    CommentName string //评论人姓名
    ReCommentName  string //父评论人姓名
    CommentEmail   string
    Img            string
    CommentContent string `gorm:&#34;type:text&#34; form:&#34;CommentContent&#34; json:&#34;CommentContent&#34;` //评论内容
    CommentTime    string ` json:&#34;comment_time,omitempty&#34;`
    Parent         *Comment
    Comments       []Comment
}
</code></pre>

<h4>实现方法</h4>

<h5>1先通过查找父评论为-1的顶级评论</h5>

<p>父评论Id为-1说明他不是任何评论的子评论</p>

<h5>2在html上遍历所有的顶级评论</h5>

<p>在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论</p>

<h6>（1）递归存储每个顶级评论的子评论</h6>

<p>这里我用一个切片来储存一个顶级评论的所有子评论</p>

<pre><code class="language-go">var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
    var comments []model.Comment
    DB.Debug().Where(&#34;re_comment_id = -1 AND blog_id = ?&#34;, id).Find(&amp;comments)
    return &amp;comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
    if count != 0 {
        fmt.Println(&#34;if判断1&#34;)
        var comments []model.Comment
        DB.Debug().Where(&#34;re_comment_id = ?&#34;, id).Find(&amp;comments)
        count = len(comments)
        if count != 0 {
            fmt.Println(&#34;if判断2&#34;)
            for _, comment := range comments {
                fmt.Println(&#34;for判断1&#34;)
                Comments = append(Comments, comment)
                SelectCommentByComment(comment.Id, count)
            }
        }
    }
    fmt.Println(Comments)
    return &amp;Comments

}
</code></pre>

<p>ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来</p>

<h6>（2）出现问题的原因</h6>

<p>因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量</p>

<h6>（3）解决问题</h6>

<pre><code class="language-go">func ClearComments() bool {
    var comments []model.Comment
    Comments = comments
    return true
}

</code></pre>

<p>这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现</p>

<h4>这里我还加了一个小小的随机头像功能</h4>

<pre><code class="language-go">if  CommentName == user.Name &amp;&amp; CommentEmail == user.UserEmail {
        fmt.Println(&#34;进入了1&#34;)
        comment.Img =user.UserImg
        //找相同评论人
    }else if CommentName == one.CommentName &amp;&amp; CommentEmail == one.CommentEmail {
        fmt.Println(&#34;进入了2&#34;)
        comment.Img =one.Img
        //随机选头像
    }else{
        fmt.Println(&#34;进入了3&#34;)
        comment.Img =middleware.GetImg()
    }
</code></pre>

<h5>123分别代表三种不同的用户群体</h5>

<p>1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
<img src="/static/images/%e5%a4%b4%e5%83%8f1.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f2.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f3.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f4.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f5.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f6.png" alt=""/></p>

<h3>2、归档功能</h3>

<h4>blog的结构体属性如下</h4>

<pre><code class="language-go">package model

type Blog struct {
    Id           int
    Title        string    `form:&#34;title&#34; json:&#34;title&#34;`                          //标题
    Content      string    `gorm:&#34;type:longtext&#34; form:&#34;content&#34; json:&#34;content&#34;` //内容
    Image        string    `gorm:&#34;type:text&#34; form:&#34;image&#34; json:&#34;image&#34;`         //首图
    Numb         int       `form:&#34;numb&#34; json:&#34;numb&#34;`                            //次数
    Flag         string    `form:&#34;flag&#34; json:&#34;flag&#34;`                            //原创或者转载
    Appreciation string    `form:&#34;appreciation&#34; json:&#34;appreciation&#34;`            //打赏开关
    ShareInfo    string    `form:&#34;shareInfo&#34; json:&#34;shareInfo&#34;`                  //版权开关
    Comment      string    `form:&#34;comment&#34; json:&#34;comment&#34;`                      //评论开关
    Recommend    string    `form:&#34;recommend&#34; json:&#34;recommend&#34;`                  //推荐开关
    Description  string    `gorm:&#34;type:text&#34; form:&#34;description&#34; json:&#34;description&#34;`
    CreatTime    string    `form:&#34;creatTime&#34;  json:&#34;creat_time,omitempty&#34;`   //创建时间
    UpdateTime   string    `form:&#34;updateTime&#34;  json:&#34;update_time,omitempty&#34;` //更新时间
    Comments     []Comment `form:&#34;comments&#34; json:&#34;comments&#34;`
    TypeId       int       `form:&#34;typeId&#34; json:&#34;typeId&#34;`
    Type         Type      `form:&#34;type&#34; gorm:&#34;ForeignKey:TypeId&#34;`
    Year         int       `form:&#34;year&#34; json:&#34;year&#34;`
    Month        int       `form:&#34;month&#34; json:&#34;month&#34;`
    Day          int       `form:&#34;day&#34; json:&#34;day&#34;`
}

</code></pre>

<h4>实现方法</h4>

<p>我的思路是创建三个时间节点
year month day
利用sql分组查询</p>

<h5>Group By分组查询步骤</h5>

<h6>（1）先按照年份查询</h6>

<h6>（2）再按照年份遍历每个月份</h6>

<p>并将所有保存在一个切片中</p>

<h6>（3）按照月份遍历每个月的所有文章</h6>

<p>保存在一个Map中，key是对应的月份，value是每个月份的所有文章</p>

<h4>自此归档功能实现</h4>

<h2>3.已知BUG</h2>

<h3>后台退出功能</h3>

<p>后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧</p>

<p>开源地址
<a href="https://github.com/likewl/blog" title="github" rel="nofollow">github</a>
<a href="https://gitee.com/nculike/blog" title="gitee" rel="nofollow">gitee</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 23:59:15][0m  [36;1m[0.33ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-20 23:59:24][0m  [36;1m[0.59ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 23:59:24][0m  [36;1m[0.25ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 23:59:24][0m  [36;1m[0.69ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-20 23:59:24][0m  [36;1m[0.18ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-20 23:59:26][0m  [36;1m[0.38ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 2)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-20 23:59:26][0m  [36;1m[0.44ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=2  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-20 23:59:26][0m  [36;1m[0.37ms][0m  UPDATE `blogs` SET `title` = '解决Linux关闭终端后运行的程序自动停止', `content` = '# 问题发现
  昨天博客发布，操作完关闭终端就睡了
  然而今天醒来突然发现终端不能访问了
  查看发现原来博客项目进程被杀死了
# 解决办法
    go build main.go
执行完后

    nohup ./main &
让程序在后台运行就可了


[========]
# ps:这个方法并不完美，因为我也是刚刚接触还不知道怎么切回来', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3696516981,3671280793&fm=26&gp=0.jpg', `numb` = 13, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '昨天博客发布，操作完关闭终端就睡了，然而今天醒来突然发现终端不能访问了，查看发现原来博客项目进程被杀死了', `creat_time` = '2020-07-19 19:05:36', `update_time` = '2020-07-19 19:05:36', `type_id` = 2, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 3  
[36;31m[1 rows affected or returned ][0m 
<h1>问题发现</h1>

<p>昨天博客发布，操作完关闭终端就睡了
  然而今天醒来突然发现终端不能访问了
  查看发现原来博客项目进程被杀死了</p>

<h1>解决办法</h1>

<pre><code>go build main.go
</code></pre>

<p>执行完后</p>

<pre><code>nohup ./main &amp;
</code></pre>

<p>让程序在后台运行就可了</p>

<p>[========]</p>

<h1>ps:这个方法并不完美，因为我也是刚刚接触还不知道怎么切回来</h1>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 23:59:26][0m  [36;1m[0.27ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-20 23:59:30][0m  [36;1m[0.46ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 4)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-20 23:59:30][0m  [36;1m[0.53ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=4  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-20 23:59:30][0m  [36;1m[0.54ms][0m  UPDATE `blogs` SET `title` = '本博客开源公告', `content` = '今天本博客评论功能发布
# 自今天起，本博客基本功能已经完成
## 发布V1.0版本并开源
## 博客语言说明
#### 本博客后端是用golang 的gin框架+gorm编写
前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的
#### 博客效果参考本站
#一、博客简介
## 1.博客目录

    blog
    ├────controller
	├────└───admin
	|	|	├──adminblog.go
	|	|	├───adminController.go
	|	|	├──adminTag.go
	|	|	├──adminType.go
	|	|	└──adminUser.go
	|	└──page
	|		├──404.go
	|		├───about.go
	|		├──archives.go
	|		├──blog.go
	|		├──comment.go
	|		├──pagesController.go
	|		├──researchController.go
	|		└──tagsController.go
    ├── dao
	│	├──blogs.go
	│	├──comment.go
	│	├──sql.go
	│	├──tags.go
	│	├──types.go
	│	└──user.go
    ├── logic
    │   └── user.go
    ├── middlerware
	│	├──function.go
	│	├──getImg.go
	│	├──getTime.go
	│	├──markdown.go
	│	├──select.go
	│	└──session.go
    ├── model
	│	├──blog.go
	│	├──commnent.go
	│	├──tag.go
	│	├──type.go
	│	└──user/go
    ├── static
	│	└──静态文件（头像、图片、logo、css、js等）
    ├── templates
	│	└──html模板文件
    ├── go.mod（依赖）
    └── main.go
    

## 2.相关功能实现简介
### 1、评论及回复功能
comment的结构体属性如下
```go
package model

type Comment struct {
	Id     int //评论id
	BlogId int //博文id
	ReCommentId    int    //父评论id
	CommentName string //评论人姓名
	ReCommentName  string //父评论人姓名
	CommentEmail   string
	Img            string
	CommentContent string `gorm:"type:text" form:"CommentContent" json:"CommentContent"` //评论内容
	CommentTime    string ` json:"comment_time,omitempty"`
	Parent         *Comment
	Comments       []Comment
}
```
#### 实现方法
##### 1先通过查找父评论为-1的顶级评论
父评论Id为-1说明他不是任何评论的子评论
##### 2在html上遍历所有的顶级评论
在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论
###### （1）递归存储每个顶级评论的子评论
这里我用一个切片来储存一个顶级评论的所有子评论
```go
var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
	var comments []model.Comment
	DB.Debug().Where("re_comment_id = -1 AND blog_id = ?", id).Find(&comments)
	return &comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
	if count != 0 {
		fmt.Println("if判断1")
		var comments []model.Comment
		DB.Debug().Where("re_comment_id = ?", id).Find(&comments)
		count = len(comments)
		if count != 0 {
			fmt.Println("if判断2")
			for _, comment := range comments {
				fmt.Println("for判断1")
				Comments = append(Comments, comment)
				SelectCommentByComment(comment.Id, count)
			}
		}
	}
	fmt.Println(Comments)
	return &Comments

}
```
ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来
###### （2）出现问题的原因
因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量
###### （3）解决问题
```go
func ClearComments() bool {
	var comments []model.Comment
	Comments = comments
	return true
}

```
这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现
#### 这里我还加了一个小小的随机头像功能
```go
if  CommentName == user.Name && CommentEmail == user.UserEmail {
		fmt.Println("进入了1")
		comment.Img =user.UserImg
		//找相同评论人
	}else if CommentName == one.CommentName && CommentEmail == one.CommentEmail {
		fmt.Println("进入了2")
		comment.Img =one.Img
		//随机选头像
	}else{
		fmt.Println("进入了3")
		comment.Img =middleware.GetImg()
	}
```
##### 123分别代表三种不同的用户群体
1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
![](/static/images/%e5%a4%b4%e5%83%8f1.png)![](/static/images/%e5%a4%b4%e5%83%8f2.png)![](/static/images/%e5%a4%b4%e5%83%8f3.png)![](/static/images/%e5%a4%b4%e5%83%8f4.png)![](/static/images/%e5%a4%b4%e5%83%8f5.png)![](/static/images/%e5%a4%b4%e5%83%8f6.png)
### 2、归档功能
#### blog的结构体属性如下
```go
package model

type Blog struct {
	Id           int
	Title        string    `form:"title" json:"title"`                          //标题
	Content      string    `gorm:"type:longtext" form:"content" json:"content"` //内容
	Image        string    `gorm:"type:text" form:"image" json:"image"`         //首图
	Numb         int       `form:"numb" json:"numb"`                            //次数
	Flag         string    `form:"flag" json:"flag"`                            //原创或者转载
	Appreciation string    `form:"appreciation" json:"appreciation"`            //打赏开关
	ShareInfo    string    `form:"shareInfo" json:"shareInfo"`                  //版权开关
	Comment      string    `form:"comment" json:"comment"`                      //评论开关
	Recommend    string    `form:"recommend" json:"recommend"`                  //推荐开关
	Description  string    `gorm:"type:text" form:"description" json:"description"`
	CreatTime    string    `form:"creatTime"  json:"creat_time,omitempty"`   //创建时间
	UpdateTime   string    `form:"updateTime"  json:"update_time,omitempty"` //更新时间
	Comments     []Comment `form:"comments" json:"comments"`
	TypeId       int       `form:"typeId" json:"typeId"`
	Type         Type      `form:"type" gorm:"ForeignKey:TypeId"`
	Year         int       `form:"year" json:"year"`
	Month        int       `form:"month" json:"month"`
	Day          int       `form:"day" json:"day"`
}

```
#### 实现方法
我的思路是创建三个时间节点
year month day 
利用sql分组查询
##### Group By分组查询步骤
###### （1）先按照年份查询
###### （2）再按照年份遍历每个月份
并将所有保存在一个切片中
###### （3）按照月份遍历每个月的所有文章
保存在一个Map中，key是对应的月份，value是每个月份的所有文章
#### 自此归档功能实现


## 3.已知BUG
### 后台退出功能
后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧

开源地址
[github](https://github.com/likewl/blog "github")
[gitee](https://gitee.com/nculike/blog "gitee")', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1535821573,4166447487&fm=26&gp=0.jpg', `numb` = 14, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '本博客后端是用golang 的gin框架+gorm编写', `creat_time` = '2020-07-20 15:24:23', `update_time` = '2020-07-20 15:24:23', `type_id` = 4, `year` = 2020, `month` = 7, `day` = 20  WHERE `blogs`.`id` = 4  
[36;31m[1 rows affected or returned ][0m 
<p>今天本博客评论功能发布</p>

<h1>自今天起，本博客基本功能已经完成</h1>

<h2>发布V1.0版本并开源</h2>

<h2>博客语言说明</h2>

<h4>本博客后端是用golang 的gin框架+gorm编写</h4>

<p>前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的</p>

<h4>博客效果参考本站</h4>

<p>#一、博客简介</p>

<h2>1.博客目录</h2>

<pre><code>blog
├────controller
├────└───admin
|   |   ├──adminblog.go
|   |   ├───adminController.go
|   |   ├──adminTag.go
|   |   ├──adminType.go
|   |   └──adminUser.go
|   └──page
|       ├──404.go
|       ├───about.go
|       ├──archives.go
|       ├──blog.go
|       ├──comment.go
|       ├──pagesController.go
|       ├──researchController.go
|       └──tagsController.go
├── dao
│   ├──blogs.go
│   ├──comment.go
│   ├──sql.go
│   ├──tags.go
│   ├──types.go
│   └──user.go
├── logic
│   └── user.go
├── middlerware
│   ├──function.go
│   ├──getImg.go
│   ├──getTime.go
│   ├──markdown.go
│   ├──select.go
│   └──session.go
├── model
│   ├──blog.go
│   ├──commnent.go
│   ├──tag.go
│   ├──type.go
│   └──user/go
├── static
│   └──静态文件（头像、图片、logo、css、js等）
├── templates
│   └──html模板文件
├── go.mod（依赖）
└── main.go
</code></pre>

<h2>2.相关功能实现简介</h2>

<h3>1、评论及回复功能</h3>

<p>comment的结构体属性如下</p>

<pre><code class="language-go">package model

type Comment struct {
    Id     int //评论id
    BlogId int //博文id
    ReCommentId    int    //父评论id
    CommentName string //评论人姓名
    ReCommentName  string //父评论人姓名
    CommentEmail   string
    Img            string
    CommentContent string `gorm:&#34;type:text&#34; form:&#34;CommentContent&#34; json:&#34;CommentContent&#34;` //评论内容
    CommentTime    string ` json:&#34;comment_time,omitempty&#34;`
    Parent         *Comment
    Comments       []Comment
}
</code></pre>

<h4>实现方法</h4>

<h5>1先通过查找父评论为-1的顶级评论</h5>

<p>父评论Id为-1说明他不是任何评论的子评论</p>

<h5>2在html上遍历所有的顶级评论</h5>

<p>在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论</p>

<h6>（1）递归存储每个顶级评论的子评论</h6>

<p>这里我用一个切片来储存一个顶级评论的所有子评论</p>

<pre><code class="language-go">var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
    var comments []model.Comment
    DB.Debug().Where(&#34;re_comment_id = -1 AND blog_id = ?&#34;, id).Find(&amp;comments)
    return &amp;comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
    if count != 0 {
        fmt.Println(&#34;if判断1&#34;)
        var comments []model.Comment
        DB.Debug().Where(&#34;re_comment_id = ?&#34;, id).Find(&amp;comments)
        count = len(comments)
        if count != 0 {
            fmt.Println(&#34;if判断2&#34;)
            for _, comment := range comments {
                fmt.Println(&#34;for判断1&#34;)
                Comments = append(Comments, comment)
                SelectCommentByComment(comment.Id, count)
            }
        }
    }
    fmt.Println(Comments)
    return &amp;Comments

}
</code></pre>

<p>ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来</p>

<h6>（2）出现问题的原因</h6>

<p>因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量</p>

<h6>（3）解决问题</h6>

<pre><code class="language-go">func ClearComments() bool {
    var comments []model.Comment
    Comments = comments
    return true
}

</code></pre>

<p>这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现</p>

<h4>这里我还加了一个小小的随机头像功能</h4>

<pre><code class="language-go">if  CommentName == user.Name &amp;&amp; CommentEmail == user.UserEmail {
        fmt.Println(&#34;进入了1&#34;)
        comment.Img =user.UserImg
        //找相同评论人
    }else if CommentName == one.CommentName &amp;&amp; CommentEmail == one.CommentEmail {
        fmt.Println(&#34;进入了2&#34;)
        comment.Img =one.Img
        //随机选头像
    }else{
        fmt.Println(&#34;进入了3&#34;)
        comment.Img =middleware.GetImg()
    }
</code></pre>

<h5>123分别代表三种不同的用户群体</h5>

<p>1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
<img src="/static/images/%e5%a4%b4%e5%83%8f1.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f2.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f3.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f4.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f5.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f6.png" alt=""/></p>

<h3>2、归档功能</h3>

<h4>blog的结构体属性如下</h4>

<pre><code class="language-go">package model

type Blog struct {
    Id           int
    Title        string    `form:&#34;title&#34; json:&#34;title&#34;`                          //标题
    Content      string    `gorm:&#34;type:longtext&#34; form:&#34;content&#34; json:&#34;content&#34;` //内容
    Image        string    `gorm:&#34;type:text&#34; form:&#34;image&#34; json:&#34;image&#34;`         //首图
    Numb         int       `form:&#34;numb&#34; json:&#34;numb&#34;`                            //次数
    Flag         string    `form:&#34;flag&#34; json:&#34;flag&#34;`                            //原创或者转载
    Appreciation string    `form:&#34;appreciation&#34; json:&#34;appreciation&#34;`            //打赏开关
    ShareInfo    string    `form:&#34;shareInfo&#34; json:&#34;shareInfo&#34;`                  //版权开关
    Comment      string    `form:&#34;comment&#34; json:&#34;comment&#34;`                      //评论开关
    Recommend    string    `form:&#34;recommend&#34; json:&#34;recommend&#34;`                  //推荐开关
    Description  string    `gorm:&#34;type:text&#34; form:&#34;description&#34; json:&#34;description&#34;`
    CreatTime    string    `form:&#34;creatTime&#34;  json:&#34;creat_time,omitempty&#34;`   //创建时间
    UpdateTime   string    `form:&#34;updateTime&#34;  json:&#34;update_time,omitempty&#34;` //更新时间
    Comments     []Comment `form:&#34;comments&#34; json:&#34;comments&#34;`
    TypeId       int       `form:&#34;typeId&#34; json:&#34;typeId&#34;`
    Type         Type      `form:&#34;type&#34; gorm:&#34;ForeignKey:TypeId&#34;`
    Year         int       `form:&#34;year&#34; json:&#34;year&#34;`
    Month        int       `form:&#34;month&#34; json:&#34;month&#34;`
    Day          int       `form:&#34;day&#34; json:&#34;day&#34;`
}

</code></pre>

<h4>实现方法</h4>

<p>我的思路是创建三个时间节点
year month day
利用sql分组查询</p>

<h5>Group By分组查询步骤</h5>

<h6>（1）先按照年份查询</h6>

<h6>（2）再按照年份遍历每个月份</h6>

<p>并将所有保存在一个切片中</p>

<h6>（3）按照月份遍历每个月的所有文章</h6>

<p>保存在一个Map中，key是对应的月份，value是每个月份的所有文章</p>

<h4>自此归档功能实现</h4>

<h2>3.已知BUG</h2>

<h3>后台退出功能</h3>

<p>后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧</p>

<p>开源地址
<a href="https://github.com/likewl/blog" title="github" rel="nofollow">github</a>
<a href="https://gitee.com/nculike/blog" title="gitee" rel="nofollow">gitee</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 23:59:30][0m  [36;1m[0.27ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-20 23:59:46][0m  [36;1m[0.56ms][0m  SELECT * FROM `tags`    
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 23:59:46][0m  [36;1m[0.25ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:68)[0m 
[33m[2020-07-20 23:59:46][0m  [36;1m[0.42ms][0m  SELECT * FROM `tags`  WHERE (tag_name='linux指令') ORDER BY `tags`.`id` ASC LIMIT 1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:76)[0m 
[33m[2020-07-20 23:59:46][0m  [36;1m[0.93ms][0m   SELECT b.id,b.title,b.type_id,t.tag_name,b.description,b.recommend,b.numb,b.update_time,b.image,a.`type_name`  FROM `blogs` b LEFT JOIN `tag_blogs` tb ON b.id = tb.`blog_id` LEFT JOIN tags t ON tb.`tag_id`=t.`id` LEFT JOIN `types` a ON b.type_id = a.`id` WHERE t.`id`=2 ORDER BY b.id  DESC LIMIT 10 OFFSET 0  
[36;31m[3 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:31)[0m 
[33m[2020-07-20 23:59:46][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `tags`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 23:59:50][0m  [36;1m[0.84ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-20 23:59:50][0m  [36;1m[1.06ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-20 23:59:50][0m  [36;1m[0.29ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-20 23:59:50][0m  [36;1m[0.44ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-20 23:59:50][0m  [36;1m[0.39ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-20 23:59:50][0m  [36;1m[0.49ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-20 23:59:51][0m  [36;1m[0.39ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 4)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-20 23:59:51][0m  [36;1m[0.43ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=4  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-20 23:59:51][0m  [36;1m[0.48ms][0m  UPDATE `blogs` SET `title` = '本博客开源公告', `content` = '今天本博客评论功能发布
# 自今天起，本博客基本功能已经完成
## 发布V1.0版本并开源
## 博客语言说明
#### 本博客后端是用golang 的gin框架+gorm编写
前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的
#### 博客效果参考本站
#一、博客简介
## 1.博客目录

    blog
    ├────controller
	├────└───admin
	|	|	├──adminblog.go
	|	|	├───adminController.go
	|	|	├──adminTag.go
	|	|	├──adminType.go
	|	|	└──adminUser.go
	|	└──page
	|		├──404.go
	|		├───about.go
	|		├──archives.go
	|		├──blog.go
	|		├──comment.go
	|		├──pagesController.go
	|		├──researchController.go
	|		└──tagsController.go
    ├── dao
	│	├──blogs.go
	│	├──comment.go
	│	├──sql.go
	│	├──tags.go
	│	├──types.go
	│	└──user.go
    ├── logic
    │   └── user.go
    ├── middlerware
	│	├──function.go
	│	├──getImg.go
	│	├──getTime.go
	│	├──markdown.go
	│	├──select.go
	│	└──session.go
    ├── model
	│	├──blog.go
	│	├──commnent.go
	│	├──tag.go
	│	├──type.go
	│	└──user/go
    ├── static
	│	└──静态文件（头像、图片、logo、css、js等）
    ├── templates
	│	└──html模板文件
    ├── go.mod（依赖）
    └── main.go
    

## 2.相关功能实现简介
### 1、评论及回复功能
comment的结构体属性如下
```go
package model

type Comment struct {
	Id     int //评论id
	BlogId int //博文id
	ReCommentId    int    //父评论id
	CommentName string //评论人姓名
	ReCommentName  string //父评论人姓名
	CommentEmail   string
	Img            string
	CommentContent string `gorm:"type:text" form:"CommentContent" json:"CommentContent"` //评论内容
	CommentTime    string ` json:"comment_time,omitempty"`
	Parent         *Comment
	Comments       []Comment
}
```
#### 实现方法
##### 1先通过查找父评论为-1的顶级评论
父评论Id为-1说明他不是任何评论的子评论
##### 2在html上遍历所有的顶级评论
在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论
###### （1）递归存储每个顶级评论的子评论
这里我用一个切片来储存一个顶级评论的所有子评论
```go
var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
	var comments []model.Comment
	DB.Debug().Where("re_comment_id = -1 AND blog_id = ?", id).Find(&comments)
	return &comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
	if count != 0 {
		fmt.Println("if判断1")
		var comments []model.Comment
		DB.Debug().Where("re_comment_id = ?", id).Find(&comments)
		count = len(comments)
		if count != 0 {
			fmt.Println("if判断2")
			for _, comment := range comments {
				fmt.Println("for判断1")
				Comments = append(Comments, comment)
				SelectCommentByComment(comment.Id, count)
			}
		}
	}
	fmt.Println(Comments)
	return &Comments

}
```
ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来
###### （2）出现问题的原因
因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量
###### （3）解决问题
```go
func ClearComments() bool {
	var comments []model.Comment
	Comments = comments
	return true
}

```
这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现
#### 这里我还加了一个小小的随机头像功能
```go
if  CommentName == user.Name && CommentEmail == user.UserEmail {
		fmt.Println("进入了1")
		comment.Img =user.UserImg
		//找相同评论人
	}else if CommentName == one.CommentName && CommentEmail == one.CommentEmail {
		fmt.Println("进入了2")
		comment.Img =one.Img
		//随机选头像
	}else{
		fmt.Println("进入了3")
		comment.Img =middleware.GetImg()
	}
```
##### 123分别代表三种不同的用户群体
1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
![](/static/images/%e5%a4%b4%e5%83%8f1.png)![](/static/images/%e5%a4%b4%e5%83%8f2.png)![](/static/images/%e5%a4%b4%e5%83%8f3.png)![](/static/images/%e5%a4%b4%e5%83%8f4.png)![](/static/images/%e5%a4%b4%e5%83%8f5.png)![](/static/images/%e5%a4%b4%e5%83%8f6.png)
### 2、归档功能
#### blog的结构体属性如下
```go
package model

type Blog struct {
	Id           int
	Title        string    `form:"title" json:"title"`                          //标题
	Content      string    `gorm:"type:longtext" form:"content" json:"content"` //内容
	Image        string    `gorm:"type:text" form:"image" json:"image"`         //首图
	Numb         int       `form:"numb" json:"numb"`                            //次数
	Flag         string    `form:"flag" json:"flag"`                            //原创或者转载
	Appreciation string    `form:"appreciation" json:"appreciation"`            //打赏开关
	ShareInfo    string    `form:"shareInfo" json:"shareInfo"`                  //版权开关
	Comment      string    `form:"comment" json:"comment"`                      //评论开关
	Recommend    string    `form:"recommend" json:"recommend"`                  //推荐开关
	Description  string    `gorm:"type:text" form:"description" json:"description"`
	CreatTime    string    `form:"creatTime"  json:"creat_time,omitempty"`   //创建时间
	UpdateTime   string    `form:"updateTime"  json:"update_time,omitempty"` //更新时间
	Comments     []Comment `form:"comments" json:"comments"`
	TypeId       int       `form:"typeId" json:"typeId"`
	Type         Type      `form:"type" gorm:"ForeignKey:TypeId"`
	Year         int       `form:"year" json:"year"`
	Month        int       `form:"month" json:"month"`
	Day          int       `form:"day" json:"day"`
}

```
#### 实现方法
我的思路是创建三个时间节点
year month day 
利用sql分组查询
##### Group By分组查询步骤
###### （1）先按照年份查询
###### （2）再按照年份遍历每个月份
并将所有保存在一个切片中
###### （3）按照月份遍历每个月的所有文章
保存在一个Map中，key是对应的月份，value是每个月份的所有文章
#### 自此归档功能实现


## 3.已知BUG
### 后台退出功能
后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧

开源地址
[github](https://github.com/likewl/blog "github")
[gitee](https://gitee.com/nculike/blog "gitee")', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1535821573,4166447487&fm=26&gp=0.jpg', `numb` = 15, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '本博客后端是用golang 的gin框架+gorm编写', `creat_time` = '2020-07-20 15:24:23', `update_time` = '2020-07-20 15:24:23', `type_id` = 4, `year` = 2020, `month` = 7, `day` = 20  WHERE `blogs`.`id` = 4  
[36;31m[1 rows affected or returned ][0m 
<p>今天本博客评论功能发布</p>

<h1>自今天起，本博客基本功能已经完成</h1>

<h2>发布V1.0版本并开源</h2>

<h2>博客语言说明</h2>

<h4>本博客后端是用golang 的gin框架+gorm编写</h4>

<p>前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的</p>

<h4>博客效果参考本站</h4>

<p>#一、博客简介</p>

<h2>1.博客目录</h2>

<pre><code>blog
├────controller
├────└───admin
|   |   ├──adminblog.go
|   |   ├───adminController.go
|   |   ├──adminTag.go
|   |   ├──adminType.go
|   |   └──adminUser.go
|   └──page
|       ├──404.go
|       ├───about.go
|       ├──archives.go
|       ├──blog.go
|       ├──comment.go
|       ├──pagesController.go
|       ├──researchController.go
|       └──tagsController.go
├── dao
│   ├──blogs.go
│   ├──comment.go
│   ├──sql.go
│   ├──tags.go
│   ├──types.go
│   └──user.go
├── logic
│   └── user.go
├── middlerware
│   ├──function.go
│   ├──getImg.go
│   ├──getTime.go
│   ├──markdown.go
│   ├──select.go
│   └──session.go
├── model
│   ├──blog.go
│   ├──commnent.go
│   ├──tag.go
│   ├──type.go
│   └──user/go
├── static
│   └──静态文件（头像、图片、logo、css、js等）
├── templates
│   └──html模板文件
├── go.mod（依赖）
└── main.go
</code></pre>

<h2>2.相关功能实现简介</h2>

<h3>1、评论及回复功能</h3>

<p>comment的结构体属性如下</p>

<pre><code class="language-go">package model

type Comment struct {
    Id     int //评论id
    BlogId int //博文id
    ReCommentId    int    //父评论id
    CommentName string //评论人姓名
    ReCommentName  string //父评论人姓名
    CommentEmail   string
    Img            string
    CommentContent string `gorm:&#34;type:text&#34; form:&#34;CommentContent&#34; json:&#34;CommentContent&#34;` //评论内容
    CommentTime    string ` json:&#34;comment_time,omitempty&#34;`
    Parent         *Comment
    Comments       []Comment
}
</code></pre>

<h4>实现方法</h4>

<h5>1先通过查找父评论为-1的顶级评论</h5>

<p>父评论Id为-1说明他不是任何评论的子评论</p>

<h5>2在html上遍历所有的顶级评论</h5>

<p>在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论</p>

<h6>（1）递归存储每个顶级评论的子评论</h6>

<p>这里我用一个切片来储存一个顶级评论的所有子评论</p>

<pre><code class="language-go">var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
    var comments []model.Comment
    DB.Debug().Where(&#34;re_comment_id = -1 AND blog_id = ?&#34;, id).Find(&amp;comments)
    return &amp;comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
    if count != 0 {
        fmt.Println(&#34;if判断1&#34;)
        var comments []model.Comment
        DB.Debug().Where(&#34;re_comment_id = ?&#34;, id).Find(&amp;comments)
        count = len(comments)
        if count != 0 {
            fmt.Println(&#34;if判断2&#34;)
            for _, comment := range comments {
                fmt.Println(&#34;for判断1&#34;)
                Comments = append(Comments, comment)
                SelectCommentByComment(comment.Id, count)
            }
        }
    }
    fmt.Println(Comments)
    return &amp;Comments

}
</code></pre>

<p>ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来</p>

<h6>（2）出现问题的原因</h6>

<p>因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量</p>

<h6>（3）解决问题</h6>

<pre><code class="language-go">func ClearComments() bool {
    var comments []model.Comment
    Comments = comments
    return true
}

</code></pre>

<p>这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现</p>

<h4>这里我还加了一个小小的随机头像功能</h4>

<pre><code class="language-go">if  CommentName == user.Name &amp;&amp; CommentEmail == user.UserEmail {
        fmt.Println(&#34;进入了1&#34;)
        comment.Img =user.UserImg
        //找相同评论人
    }else if CommentName == one.CommentName &amp;&amp; CommentEmail == one.CommentEmail {
        fmt.Println(&#34;进入了2&#34;)
        comment.Img =one.Img
        //随机选头像
    }else{
        fmt.Println(&#34;进入了3&#34;)
        comment.Img =middleware.GetImg()
    }
</code></pre>

<h5>123分别代表三种不同的用户群体</h5>

<p>1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
<img src="/static/images/%e5%a4%b4%e5%83%8f1.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f2.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f3.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f4.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f5.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f6.png" alt=""/></p>

<h3>2、归档功能</h3>

<h4>blog的结构体属性如下</h4>

<pre><code class="language-go">package model

type Blog struct {
    Id           int
    Title        string    `form:&#34;title&#34; json:&#34;title&#34;`                          //标题
    Content      string    `gorm:&#34;type:longtext&#34; form:&#34;content&#34; json:&#34;content&#34;` //内容
    Image        string    `gorm:&#34;type:text&#34; form:&#34;image&#34; json:&#34;image&#34;`         //首图
    Numb         int       `form:&#34;numb&#34; json:&#34;numb&#34;`                            //次数
    Flag         string    `form:&#34;flag&#34; json:&#34;flag&#34;`                            //原创或者转载
    Appreciation string    `form:&#34;appreciation&#34; json:&#34;appreciation&#34;`            //打赏开关
    ShareInfo    string    `form:&#34;shareInfo&#34; json:&#34;shareInfo&#34;`                  //版权开关
    Comment      string    `form:&#34;comment&#34; json:&#34;comment&#34;`                      //评论开关
    Recommend    string    `form:&#34;recommend&#34; json:&#34;recommend&#34;`                  //推荐开关
    Description  string    `gorm:&#34;type:text&#34; form:&#34;description&#34; json:&#34;description&#34;`
    CreatTime    string    `form:&#34;creatTime&#34;  json:&#34;creat_time,omitempty&#34;`   //创建时间
    UpdateTime   string    `form:&#34;updateTime&#34;  json:&#34;update_time,omitempty&#34;` //更新时间
    Comments     []Comment `form:&#34;comments&#34; json:&#34;comments&#34;`
    TypeId       int       `form:&#34;typeId&#34; json:&#34;typeId&#34;`
    Type         Type      `form:&#34;type&#34; gorm:&#34;ForeignKey:TypeId&#34;`
    Year         int       `form:&#34;year&#34; json:&#34;year&#34;`
    Month        int       `form:&#34;month&#34; json:&#34;month&#34;`
    Day          int       `form:&#34;day&#34; json:&#34;day&#34;`
}

</code></pre>

<h4>实现方法</h4>

<p>我的思路是创建三个时间节点
year month day
利用sql分组查询</p>

<h5>Group By分组查询步骤</h5>

<h6>（1）先按照年份查询</h6>

<h6>（2）再按照年份遍历每个月份</h6>

<p>并将所有保存在一个切片中</p>

<h6>（3）按照月份遍历每个月的所有文章</h6>

<p>保存在一个Map中，key是对应的月份，value是每个月份的所有文章</p>

<h4>自此归档功能实现</h4>

<h2>3.已知BUG</h2>

<h3>后台退出功能</h3>

<p>后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧</p>

<p>开源地址
<a href="https://github.com/likewl/blog" title="github" rel="nofollow">github</a>
<a href="https://gitee.com/nculike/blog" title="gitee" rel="nofollow">gitee</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-20 23:59:51][0m  [36;1m[0.30ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-21 00:00:12][0m  [36;1m[0.49ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 1)  
[36;31m[2 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-21 00:00:12][0m  [36;1m[0.48ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=1  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-21 00:00:12][0m  [36;1m[0.49ms][0m  UPDATE `blogs` SET `title` = 'golang项目简单服务器部署到阿里云(linux)', `content` = '# 我个人比较推荐使用Xftp和Xshell 
# 重要是个人免费用
# 舒服又好用

# 1.下载安装go安装包：
	## （1）go语言下载地址：
	[Go语言中文网](https://studygolang.com/dl "Go语言中文网")
下载linux版本的安装包。

## （2）使用Xftp将安装包上传至指定的路径：

![](https://img-blog.csdnimg.cn/20190719142701389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
	这里上传到root目录下就行
	方便解压
## （3）解压并移到/usr/local/下：

进入指定目录，查看已有文件并且解压文件：

![](https://img-blog.csdnimg.cn/20190719143211340.png)
```
#在root目录输入ls查看目录文件
ls
#在root解压go包
tar -zxvf go的包名
```

解压完成后发现目录下多了一个go文件夹：
![](https://img-blog.csdnimg.cn/20190719143042938.png)
将文件夹移动到/usr/local/
![](https://img-blog.csdnimg.cn/20190719143137645.png)
# 2.配置环境变量：
## （1）进入目的目录查看go文件夹是否移动成功：
![](https://img-blog.csdnimg.cn/20190719143506382.png)
## （2）在usr下创建文件夹，用来存放自己的项目：
workspace
## （3）进入新建的目录workspace新建三个文件夹：
src
pkg
bin
### 说明：

	src 目录存放的是我们的go源代码，不同工程项目的代码以包名区分
	pkg 编译后生成的文件
	bin文件夹存放go install命名生成的可执行文件（这个文件夹会配置到环境变量中）
## （4）配置环境变量：

进入 /etc 修改profile文件：
![](https://img-blog.csdnimg.cn/20190719144319621.png)
```
#进入etc目录
cd /etc/
#配置 profile
vim profile
```
![](https://img-blog.csdnimg.cn/20190719145650864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
在此文件夹下加入上图的代码，代码如下：
```
// 设置go安装路径
export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin
 
// 设置工程目录
export GOPATH=/usr/workspace
export PATH=$PATH:$GOPATH/bin
```

## （5）刷新环境变量：
```
source /etc/profile
```
##  （6）查看go环境是否配置成功：
```
go version
```
## （7）查看详细配置：
```
go env
```
结果如下：  
![](https://img-blog.csdnimg.cn/20190719145255720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70) 
# 3.上传项目代码：
在刚刚创建的workspace下新创建的三个文件夹中，src 目录存放的是我们的go源代码
# 4运行
```go
go build main.go
//或者
go run main.go
```
最后执行 ./main 就行了。
如果想让项目在后台执行：执行 nohup ./main & ，这样就可以程序在后台运行了。

参考教程https://blog.csdn.net/qq_42410605/article/details/96479892', `image` = 'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3111860246,1925938903&fm=26&gp=0.jpg', `numb` = 40, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '简单又详细的教程', `creat_time` = '2020-07-19 18:32:31', `update_time` = '2020-07-20 13:11:56', `type_id` = 1, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 1  
[36;31m[1 rows affected or returned ][0m 
<h1>我个人比较推荐使用Xftp和Xshell</h1>

<h1>重要是个人免费用</h1>

<h1>舒服又好用</h1>

<h1>1.下载安装go安装包：</h1>

<pre><code>## （1）go语言下载地址：
[Go语言中文网](https://studygolang.com/dl &#34;Go语言中文网&#34;)
</code></pre>

<p>下载linux版本的安装包。</p>

<h2>（2）使用Xftp将安装包上传至指定的路径：</h2>

<p><img src="https://img-blog.csdnimg.cn/20190719142701389.png?x-oss-process=image%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1%2Csize_16%2Ccolor_FFFFFF%2Ct_70" alt=""/>
    这里上传到root目录下就行
    方便解压</p>

<h2>（3）解压并移到/usr/local/下：</h2>

<p>进入指定目录，查看已有文件并且解压文件：</p>

<p><img src="https://img-blog.csdnimg.cn/20190719143211340.png" alt=""/></p>

<pre><code>#在root目录输入ls查看目录文件
ls
#在root解压go包
tar -zxvf go的包名
</code></pre>

<p>解压完成后发现目录下多了一个go文件夹：
<img src="https://img-blog.csdnimg.cn/20190719143042938.png" alt=""/>
将文件夹移动到/usr/local/
<img src="https://img-blog.csdnimg.cn/20190719143137645.png" alt=""/></p>

<h1>2.配置环境变量：</h1>

<h2>（1）进入目的目录查看go文件夹是否移动成功：</h2>

<p><img src="https://img-blog.csdnimg.cn/20190719143506382.png" alt=""/></p>

<h2>（2）在usr下创建文件夹，用来存放自己的项目：</h2>

<p>workspace</p>

<h2>（3）进入新建的目录workspace新建三个文件夹：</h2>

<p>src
pkg
bin</p>

<h3>说明：</h3>

<pre><code>src 目录存放的是我们的go源代码，不同工程项目的代码以包名区分
pkg 编译后生成的文件
bin文件夹存放go install命名生成的可执行文件（这个文件夹会配置到环境变量中）
</code></pre>

<h2>（4）配置环境变量：</h2>

<p>进入 /etc 修改profile文件：
<img src="https://img-blog.csdnimg.cn/20190719144319621.png" alt=""/></p>

<pre><code>#进入etc目录
cd /etc/
#配置 profile
vim profile
</code></pre>

<p><img src="https://img-blog.csdnimg.cn/20190719145650864.png?x-oss-process=image%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1%2Csize_16%2Ccolor_FFFFFF%2Ct_70" alt=""/>
在此文件夹下加入上图的代码，代码如下：</p>

<pre><code>// 设置go安装路径
export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin
 
// 设置工程目录
export GOPATH=/usr/workspace
export PATH=$PATH:$GOPATH/bin
</code></pre>

<h2>（5）刷新环境变量：</h2>

<pre><code>source /etc/profile
</code></pre>

<h2> （6）查看go环境是否配置成功：</h2>

<pre><code>go version
</code></pre>

<h2>（7）查看详细配置：</h2>

<pre><code>go env
</code></pre>

<p>结果如下：  
<img src="https://img-blog.csdnimg.cn/20190719145255720.png?x-oss-process=image%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1%2Csize_16%2Ccolor_FFFFFF%2Ct_70" alt=""/> </p>

<h1>3.上传项目代码：</h1>

<p>在刚刚创建的workspace下新创建的三个文件夹中，src 目录存放的是我们的go源代码</p>

<h1>4运行</h1>

<pre><code class="language-go">go build main.go
//或者
go run main.go
</code></pre>

<p>最后执行 ./main 就行了。
如果想让项目在后台执行：执行 nohup ./main &amp; ，这样就可以程序在后台运行了。</p>

<p>参考教程<a href="https://blog.csdn.net/qq_42410605/article/details/96479892" rel="nofollow">https://blog.csdn.net/qq_42410605/article/details/96479892</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:00:12][0m  [36;1m[0.42ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-21 00:00:12][0m  [36;1m[0.62ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 1)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-21 00:00:12][0m  [36;1m[0.38ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 2)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-21 00:00:12][0m  [36;1m[0.38ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 4)  
[36;31m[0 rows affected or returned ][0m 
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-21 00:00:12][0m  [36;1m[0.37ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 3)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-21 00:00:12][0m  [36;1m[0.33ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 5)  
[36;31m[0 rows affected or returned ][0m 
[{5 1 3 like 狗科 535889315@qq.com /static/images/header.jpg ？？？ 2020-07-20 13:30:17 <nil> []}]
[{5 1 3 like 狗科 535889315@qq.com /static/images/header.jpg ？？？ 2020-07-20 13:30:17 <nil> []}]

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-21 00:00:18][0m  [36;1m[0.35ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 3)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-21 00:00:18][0m  [36;1m[0.45ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=3  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-21 00:00:18][0m  [36;1m[0.36ms][0m  UPDATE `blogs` SET `title` = 'mysql5.7 查询数据，group by 报错：Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 't.id' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by？', `content` = '在做归档功能时用到了分组查询
结果出现了这样的错误
```
Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 't.id' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by

```
查询才知道
mysql 5.7 加入的新特性，only_full_group_by，它只允许你的查询字段是包括在 group by 里面的字段，这种模式导致无法我们无法得到想要的字段值，我们可以禁用掉 only_full_group_by：
### 第一步：
```
select @@GLOBAL.sql_mode;
```
得到现有的 sql_mode, 如下：
```
ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION

```
### 第二步：
```
set global sql_mode ='STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION';

set session sql_mode= 'STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION';
```
去除 ONLY_FULL_GROUP_BY，重新设置，就 ok 了。', `image` = 'https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2507389442,2201469096&fm=26&gp=0.jpg', `numb` = 20, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '在做归档功能时用到了分组查询，结果出现了这样的错误，原来是mysql57的新功能
', `creat_time` = '2020-07-19 18:58:22', `update_time` = '2020-07-19 18:59:30', `type_id` = 3, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 2  
[36;31m[1 rows affected or returned ][0m 
<p>在做归档功能时用到了分组查询
结果出现了这样的错误</p>

<pre><code>Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column &#39;t.id&#39; which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by

</code></pre>

<p>查询才知道
mysql 5.7 加入的新特性，only_full_group_by，它只允许你的查询字段是包括在 group by 里面的字段，这种模式导致无法我们无法得到想要的字段值，我们可以禁用掉 only_full_group_by：</p>

<h3>第一步：</h3>

<pre><code>select @@GLOBAL.sql_mode;
</code></pre>

<p>得到现有的 sql_mode, 如下：</p>

<pre><code>ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION

</code></pre>

<h3>第二步：</h3>

<pre><code>set global sql_mode =&#39;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&#39;;

set session sql_mode= &#39;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&#39;;
</code></pre>

<p>去除 ONLY_FULL_GROUP_BY，重新设置，就 ok 了。</p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:00:18][0m  [36;1m[1.83ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-21 00:00:32][0m  [36;1m[0.37ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 4)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-21 00:00:32][0m  [36;1m[0.43ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=4  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-21 00:00:32][0m  [36;1m[0.43ms][0m  UPDATE `blogs` SET `title` = '本博客开源公告', `content` = '今天本博客评论功能发布
# 自今天起，本博客基本功能已经完成
## 发布V1.0版本并开源
## 博客语言说明
#### 本博客后端是用golang 的gin框架+gorm编写
前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的
#### 博客效果参考本站
#一、博客简介
## 1.博客目录

    blog
    ├────controller
	├────└───admin
	|	|	├──adminblog.go
	|	|	├───adminController.go
	|	|	├──adminTag.go
	|	|	├──adminType.go
	|	|	└──adminUser.go
	|	└──page
	|		├──404.go
	|		├───about.go
	|		├──archives.go
	|		├──blog.go
	|		├──comment.go
	|		├──pagesController.go
	|		├──researchController.go
	|		└──tagsController.go
    ├── dao
	│	├──blogs.go
	│	├──comment.go
	│	├──sql.go
	│	├──tags.go
	│	├──types.go
	│	└──user.go
    ├── logic
    │   └── user.go
    ├── middlerware
	│	├──function.go
	│	├──getImg.go
	│	├──getTime.go
	│	├──markdown.go
	│	├──select.go
	│	└──session.go
    ├── model
	│	├──blog.go
	│	├──commnent.go
	│	├──tag.go
	│	├──type.go
	│	└──user/go
    ├── static
	│	└──静态文件（头像、图片、logo、css、js等）
    ├── templates
	│	└──html模板文件
    ├── go.mod（依赖）
    └── main.go
    

## 2.相关功能实现简介
### 1、评论及回复功能
comment的结构体属性如下
```go
package model

type Comment struct {
	Id     int //评论id
	BlogId int //博文id
	ReCommentId    int    //父评论id
	CommentName string //评论人姓名
	ReCommentName  string //父评论人姓名
	CommentEmail   string
	Img            string
	CommentContent string `gorm:"type:text" form:"CommentContent" json:"CommentContent"` //评论内容
	CommentTime    string ` json:"comment_time,omitempty"`
	Parent         *Comment
	Comments       []Comment
}
```
#### 实现方法
##### 1先通过查找父评论为-1的顶级评论
父评论Id为-1说明他不是任何评论的子评论
##### 2在html上遍历所有的顶级评论
在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论
###### （1）递归存储每个顶级评论的子评论
这里我用一个切片来储存一个顶级评论的所有子评论
```go
var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
	var comments []model.Comment
	DB.Debug().Where("re_comment_id = -1 AND blog_id = ?", id).Find(&comments)
	return &comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
	if count != 0 {
		fmt.Println("if判断1")
		var comments []model.Comment
		DB.Debug().Where("re_comment_id = ?", id).Find(&comments)
		count = len(comments)
		if count != 0 {
			fmt.Println("if判断2")
			for _, comment := range comments {
				fmt.Println("for判断1")
				Comments = append(Comments, comment)
				SelectCommentByComment(comment.Id, count)
			}
		}
	}
	fmt.Println(Comments)
	return &Comments

}
```
ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来
###### （2）出现问题的原因
因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量
###### （3）解决问题
```go
func ClearComments() bool {
	var comments []model.Comment
	Comments = comments
	return true
}

```
这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现
#### 这里我还加了一个小小的随机头像功能
```go
if  CommentName == user.Name && CommentEmail == user.UserEmail {
		fmt.Println("进入了1")
		comment.Img =user.UserImg
		//找相同评论人
	}else if CommentName == one.CommentName && CommentEmail == one.CommentEmail {
		fmt.Println("进入了2")
		comment.Img =one.Img
		//随机选头像
	}else{
		fmt.Println("进入了3")
		comment.Img =middleware.GetImg()
	}
```
##### 123分别代表三种不同的用户群体
1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
![](/static/images/%e5%a4%b4%e5%83%8f1.png)![](/static/images/%e5%a4%b4%e5%83%8f2.png)![](/static/images/%e5%a4%b4%e5%83%8f3.png)![](/static/images/%e5%a4%b4%e5%83%8f4.png)![](/static/images/%e5%a4%b4%e5%83%8f5.png)![](/static/images/%e5%a4%b4%e5%83%8f6.png)
### 2、归档功能
#### blog的结构体属性如下
```go
package model

type Blog struct {
	Id           int
	Title        string    `form:"title" json:"title"`                          //标题
	Content      string    `gorm:"type:longtext" form:"content" json:"content"` //内容
	Image        string    `gorm:"type:text" form:"image" json:"image"`         //首图
	Numb         int       `form:"numb" json:"numb"`                            //次数
	Flag         string    `form:"flag" json:"flag"`                            //原创或者转载
	Appreciation string    `form:"appreciation" json:"appreciation"`            //打赏开关
	ShareInfo    string    `form:"shareInfo" json:"shareInfo"`                  //版权开关
	Comment      string    `form:"comment" json:"comment"`                      //评论开关
	Recommend    string    `form:"recommend" json:"recommend"`                  //推荐开关
	Description  string    `gorm:"type:text" form:"description" json:"description"`
	CreatTime    string    `form:"creatTime"  json:"creat_time,omitempty"`   //创建时间
	UpdateTime   string    `form:"updateTime"  json:"update_time,omitempty"` //更新时间
	Comments     []Comment `form:"comments" json:"comments"`
	TypeId       int       `form:"typeId" json:"typeId"`
	Type         Type      `form:"type" gorm:"ForeignKey:TypeId"`
	Year         int       `form:"year" json:"year"`
	Month        int       `form:"month" json:"month"`
	Day          int       `form:"day" json:"day"`
}

```
#### 实现方法
我的思路是创建三个时间节点
year month day 
利用sql分组查询
##### Group By分组查询步骤
###### （1）先按照年份查询
###### （2）再按照年份遍历每个月份
并将所有保存在一个切片中
###### （3）按照月份遍历每个月的所有文章
保存在一个Map中，key是对应的月份，value是每个月份的所有文章
#### 自此归档功能实现


## 3.已知BUG
### 后台退出功能
后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧

开源地址
[github](https://github.com/likewl/blog "github")
[gitee](https://gitee.com/nculike/blog "gitee")', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1535821573,4166447487&fm=26&gp=0.jpg', `numb` = 16, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '本博客后端是用golang 的gin框架+gorm编写', `creat_time` = '2020-07-20 15:24:23', `update_time` = '2020-07-20 15:24:23', `type_id` = 4, `year` = 2020, `month` = 7, `day` = 20  WHERE `blogs`.`id` = 4  
[36;31m[1 rows affected or returned ][0m 
<p>今天本博客评论功能发布</p>

<h1>自今天起，本博客基本功能已经完成</h1>

<h2>发布V1.0版本并开源</h2>

<h2>博客语言说明</h2>

<h4>本博客后端是用golang 的gin框架+gorm编写</h4>

<p>前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的</p>

<h4>博客效果参考本站</h4>

<p>#一、博客简介</p>

<h2>1.博客目录</h2>

<pre><code>blog
├────controller
├────└───admin
|   |   ├──adminblog.go
|   |   ├───adminController.go
|   |   ├──adminTag.go
|   |   ├──adminType.go
|   |   └──adminUser.go
|   └──page
|       ├──404.go
|       ├───about.go
|       ├──archives.go
|       ├──blog.go
|       ├──comment.go
|       ├──pagesController.go
|       ├──researchController.go
|       └──tagsController.go
├── dao
│   ├──blogs.go
│   ├──comment.go
│   ├──sql.go
│   ├──tags.go
│   ├──types.go
│   └──user.go
├── logic
│   └── user.go
├── middlerware
│   ├──function.go
│   ├──getImg.go
│   ├──getTime.go
│   ├──markdown.go
│   ├──select.go
│   └──session.go
├── model
│   ├──blog.go
│   ├──commnent.go
│   ├──tag.go
│   ├──type.go
│   └──user/go
├── static
│   └──静态文件（头像、图片、logo、css、js等）
├── templates
│   └──html模板文件
├── go.mod（依赖）
└── main.go
</code></pre>

<h2>2.相关功能实现简介</h2>

<h3>1、评论及回复功能</h3>

<p>comment的结构体属性如下</p>

<pre><code class="language-go">package model

type Comment struct {
    Id     int //评论id
    BlogId int //博文id
    ReCommentId    int    //父评论id
    CommentName string //评论人姓名
    ReCommentName  string //父评论人姓名
    CommentEmail   string
    Img            string
    CommentContent string `gorm:&#34;type:text&#34; form:&#34;CommentContent&#34; json:&#34;CommentContent&#34;` //评论内容
    CommentTime    string ` json:&#34;comment_time,omitempty&#34;`
    Parent         *Comment
    Comments       []Comment
}
</code></pre>

<h4>实现方法</h4>

<h5>1先通过查找父评论为-1的顶级评论</h5>

<p>父评论Id为-1说明他不是任何评论的子评论</p>

<h5>2在html上遍历所有的顶级评论</h5>

<p>在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论</p>

<h6>（1）递归存储每个顶级评论的子评论</h6>

<p>这里我用一个切片来储存一个顶级评论的所有子评论</p>

<pre><code class="language-go">var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
    var comments []model.Comment
    DB.Debug().Where(&#34;re_comment_id = -1 AND blog_id = ?&#34;, id).Find(&amp;comments)
    return &amp;comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
    if count != 0 {
        fmt.Println(&#34;if判断1&#34;)
        var comments []model.Comment
        DB.Debug().Where(&#34;re_comment_id = ?&#34;, id).Find(&amp;comments)
        count = len(comments)
        if count != 0 {
            fmt.Println(&#34;if判断2&#34;)
            for _, comment := range comments {
                fmt.Println(&#34;for判断1&#34;)
                Comments = append(Comments, comment)
                SelectCommentByComment(comment.Id, count)
            }
        }
    }
    fmt.Println(Comments)
    return &amp;Comments

}
</code></pre>

<p>ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来</p>

<h6>（2）出现问题的原因</h6>

<p>因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量</p>

<h6>（3）解决问题</h6>

<pre><code class="language-go">func ClearComments() bool {
    var comments []model.Comment
    Comments = comments
    return true
}

</code></pre>

<p>这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现</p>

<h4>这里我还加了一个小小的随机头像功能</h4>

<pre><code class="language-go">if  CommentName == user.Name &amp;&amp; CommentEmail == user.UserEmail {
        fmt.Println(&#34;进入了1&#34;)
        comment.Img =user.UserImg
        //找相同评论人
    }else if CommentName == one.CommentName &amp;&amp; CommentEmail == one.CommentEmail {
        fmt.Println(&#34;进入了2&#34;)
        comment.Img =one.Img
        //随机选头像
    }else{
        fmt.Println(&#34;进入了3&#34;)
        comment.Img =middleware.GetImg()
    }
</code></pre>

<h5>123分别代表三种不同的用户群体</h5>

<p>1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
<img src="/static/images/%e5%a4%b4%e5%83%8f1.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f2.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f3.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f4.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f5.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f6.png" alt=""/></p>

<h3>2、归档功能</h3>

<h4>blog的结构体属性如下</h4>

<pre><code class="language-go">package model

type Blog struct {
    Id           int
    Title        string    `form:&#34;title&#34; json:&#34;title&#34;`                          //标题
    Content      string    `gorm:&#34;type:longtext&#34; form:&#34;content&#34; json:&#34;content&#34;` //内容
    Image        string    `gorm:&#34;type:text&#34; form:&#34;image&#34; json:&#34;image&#34;`         //首图
    Numb         int       `form:&#34;numb&#34; json:&#34;numb&#34;`                            //次数
    Flag         string    `form:&#34;flag&#34; json:&#34;flag&#34;`                            //原创或者转载
    Appreciation string    `form:&#34;appreciation&#34; json:&#34;appreciation&#34;`            //打赏开关
    ShareInfo    string    `form:&#34;shareInfo&#34; json:&#34;shareInfo&#34;`                  //版权开关
    Comment      string    `form:&#34;comment&#34; json:&#34;comment&#34;`                      //评论开关
    Recommend    string    `form:&#34;recommend&#34; json:&#34;recommend&#34;`                  //推荐开关
    Description  string    `gorm:&#34;type:text&#34; form:&#34;description&#34; json:&#34;description&#34;`
    CreatTime    string    `form:&#34;creatTime&#34;  json:&#34;creat_time,omitempty&#34;`   //创建时间
    UpdateTime   string    `form:&#34;updateTime&#34;  json:&#34;update_time,omitempty&#34;` //更新时间
    Comments     []Comment `form:&#34;comments&#34; json:&#34;comments&#34;`
    TypeId       int       `form:&#34;typeId&#34; json:&#34;typeId&#34;`
    Type         Type      `form:&#34;type&#34; gorm:&#34;ForeignKey:TypeId&#34;`
    Year         int       `form:&#34;year&#34; json:&#34;year&#34;`
    Month        int       `form:&#34;month&#34; json:&#34;month&#34;`
    Day          int       `form:&#34;day&#34; json:&#34;day&#34;`
}

</code></pre>

<h4>实现方法</h4>

<p>我的思路是创建三个时间节点
year month day
利用sql分组查询</p>

<h5>Group By分组查询步骤</h5>

<h6>（1）先按照年份查询</h6>

<h6>（2）再按照年份遍历每个月份</h6>

<p>并将所有保存在一个切片中</p>

<h6>（3）按照月份遍历每个月的所有文章</h6>

<p>保存在一个Map中，key是对应的月份，value是每个月份的所有文章</p>

<h4>自此归档功能实现</h4>

<h2>3.已知BUG</h2>

<h3>后台退出功能</h3>

<p>后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧</p>

<p>开源地址
<a href="https://github.com/likewl/blog" title="github" rel="nofollow">github</a>
<a href="https://gitee.com/nculike/blog" title="gitee" rel="nofollow">gitee</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:00:32][0m  [36;1m[0.27ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-21 00:02:13][0m  [36;1m[0.38ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 4)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-21 00:02:13][0m  [36;1m[0.44ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=4  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-21 00:02:13][0m  [36;1m[0.43ms][0m  UPDATE `blogs` SET `title` = '本博客开源公告', `content` = '今天本博客评论功能发布
# 自今天起，本博客基本功能已经完成
## 发布V1.0版本并开源
## 博客语言说明
#### 本博客后端是用golang 的gin框架+gorm编写
前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的
#### 博客效果参考本站
#一、博客简介
## 1.博客目录

    blog
    ├────controller
	├────└───admin
	|	|	├──adminblog.go
	|	|	├───adminController.go
	|	|	├──adminTag.go
	|	|	├──adminType.go
	|	|	└──adminUser.go
	|	└──page
	|		├──404.go
	|		├───about.go
	|		├──archives.go
	|		├──blog.go
	|		├──comment.go
	|		├──pagesController.go
	|		├──researchController.go
	|		└──tagsController.go
    ├── dao
	│	├──blogs.go
	│	├──comment.go
	│	├──sql.go
	│	├──tags.go
	│	├──types.go
	│	└──user.go
    ├── logic
    │   └── user.go
    ├── middlerware
	│	├──function.go
	│	├──getImg.go
	│	├──getTime.go
	│	├──markdown.go
	│	├──select.go
	│	└──session.go
    ├── model
	│	├──blog.go
	│	├──commnent.go
	│	├──tag.go
	│	├──type.go
	│	└──user/go
    ├── static
	│	└──静态文件（头像、图片、logo、css、js等）
    ├── templates
	│	└──html模板文件
    ├── go.mod（依赖）
    └── main.go
    

## 2.相关功能实现简介
### 1、评论及回复功能
comment的结构体属性如下
```go
package model

type Comment struct {
	Id     int //评论id
	BlogId int //博文id
	ReCommentId    int    //父评论id
	CommentName string //评论人姓名
	ReCommentName  string //父评论人姓名
	CommentEmail   string
	Img            string
	CommentContent string `gorm:"type:text" form:"CommentContent" json:"CommentContent"` //评论内容
	CommentTime    string ` json:"comment_time,omitempty"`
	Parent         *Comment
	Comments       []Comment
}
```
#### 实现方法
##### 1先通过查找父评论为-1的顶级评论
父评论Id为-1说明他不是任何评论的子评论
##### 2在html上遍历所有的顶级评论
在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论
###### （1）递归存储每个顶级评论的子评论
这里我用一个切片来储存一个顶级评论的所有子评论
```go
var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
	var comments []model.Comment
	DB.Debug().Where("re_comment_id = -1 AND blog_id = ?", id).Find(&comments)
	return &comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
	if count != 0 {
		fmt.Println("if判断1")
		var comments []model.Comment
		DB.Debug().Where("re_comment_id = ?", id).Find(&comments)
		count = len(comments)
		if count != 0 {
			fmt.Println("if判断2")
			for _, comment := range comments {
				fmt.Println("for判断1")
				Comments = append(Comments, comment)
				SelectCommentByComment(comment.Id, count)
			}
		}
	}
	fmt.Println(Comments)
	return &Comments

}
```
ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来
###### （2）出现问题的原因
因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量
###### （3）解决问题
```go
func ClearComments() bool {
	var comments []model.Comment
	Comments = comments
	return true
}

```
这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现
#### 这里我还加了一个小小的随机头像功能
```go
if  CommentName == user.Name && CommentEmail == user.UserEmail {
		fmt.Println("进入了1")
		comment.Img =user.UserImg
		//找相同评论人
	}else if CommentName == one.CommentName && CommentEmail == one.CommentEmail {
		fmt.Println("进入了2")
		comment.Img =one.Img
		//随机选头像
	}else{
		fmt.Println("进入了3")
		comment.Img =middleware.GetImg()
	}
```
##### 123分别代表三种不同的用户群体
1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
![](/static/images/%e5%a4%b4%e5%83%8f1.png)![](/static/images/%e5%a4%b4%e5%83%8f2.png)![](/static/images/%e5%a4%b4%e5%83%8f3.png)![](/static/images/%e5%a4%b4%e5%83%8f4.png)![](/static/images/%e5%a4%b4%e5%83%8f5.png)![](/static/images/%e5%a4%b4%e5%83%8f6.png)
### 2、归档功能
#### blog的结构体属性如下
```go
package model

type Blog struct {
	Id           int
	Title        string    `form:"title" json:"title"`                          //标题
	Content      string    `gorm:"type:longtext" form:"content" json:"content"` //内容
	Image        string    `gorm:"type:text" form:"image" json:"image"`         //首图
	Numb         int       `form:"numb" json:"numb"`                            //次数
	Flag         string    `form:"flag" json:"flag"`                            //原创或者转载
	Appreciation string    `form:"appreciation" json:"appreciation"`            //打赏开关
	ShareInfo    string    `form:"shareInfo" json:"shareInfo"`                  //版权开关
	Comment      string    `form:"comment" json:"comment"`                      //评论开关
	Recommend    string    `form:"recommend" json:"recommend"`                  //推荐开关
	Description  string    `gorm:"type:text" form:"description" json:"description"`
	CreatTime    string    `form:"creatTime"  json:"creat_time,omitempty"`   //创建时间
	UpdateTime   string    `form:"updateTime"  json:"update_time,omitempty"` //更新时间
	Comments     []Comment `form:"comments" json:"comments"`
	TypeId       int       `form:"typeId" json:"typeId"`
	Type         Type      `form:"type" gorm:"ForeignKey:TypeId"`
	Year         int       `form:"year" json:"year"`
	Month        int       `form:"month" json:"month"`
	Day          int       `form:"day" json:"day"`
}

```
#### 实现方法
我的思路是创建三个时间节点
year month day 
利用sql分组查询
##### Group By分组查询步骤
###### （1）先按照年份查询
###### （2）再按照年份遍历每个月份
并将所有保存在一个切片中
###### （3）按照月份遍历每个月的所有文章
保存在一个Map中，key是对应的月份，value是每个月份的所有文章
#### 自此归档功能实现


## 3.已知BUG
### 后台退出功能
后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧

开源地址
[github](https://github.com/likewl/blog "github")
[gitee](https://gitee.com/nculike/blog "gitee")', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1535821573,4166447487&fm=26&gp=0.jpg', `numb` = 17, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '本博客后端是用golang 的gin框架+gorm编写', `creat_time` = '2020-07-20 15:24:23', `update_time` = '2020-07-20 15:24:23', `type_id` = 4, `year` = 2020, `month` = 7, `day` = 20  WHERE `blogs`.`id` = 4  
[36;31m[1 rows affected or returned ][0m 
<p>今天本博客评论功能发布</p>

<h1>自今天起，本博客基本功能已经完成</h1>

<h2>发布V1.0版本并开源</h2>

<h2>博客语言说明</h2>

<h4>本博客后端是用golang 的gin框架+gorm编写</h4>

<p>前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的</p>

<h4>博客效果参考本站</h4>

<p>#一、博客简介</p>

<h2>1.博客目录</h2>

<pre><code>blog
├────controller
├────└───admin
|   |   ├──adminblog.go
|   |   ├───adminController.go
|   |   ├──adminTag.go
|   |   ├──adminType.go
|   |   └──adminUser.go
|   └──page
|       ├──404.go
|       ├───about.go
|       ├──archives.go
|       ├──blog.go
|       ├──comment.go
|       ├──pagesController.go
|       ├──researchController.go
|       └──tagsController.go
├── dao
│   ├──blogs.go
│   ├──comment.go
│   ├──sql.go
│   ├──tags.go
│   ├──types.go
│   └──user.go
├── logic
│   └── user.go
├── middlerware
│   ├──function.go
│   ├──getImg.go
│   ├──getTime.go
│   ├──markdown.go
│   ├──select.go
│   └──session.go
├── model
│   ├──blog.go
│   ├──commnent.go
│   ├──tag.go
│   ├──type.go
│   └──user/go
├── static
│   └──静态文件（头像、图片、logo、css、js等）
├── templates
│   └──html模板文件
├── go.mod（依赖）
└── main.go
</code></pre>

<h2>2.相关功能实现简介</h2>

<h3>1、评论及回复功能</h3>

<p>comment的结构体属性如下</p>

<pre><code class="language-go">package model

type Comment struct {
    Id     int //评论id
    BlogId int //博文id
    ReCommentId    int    //父评论id
    CommentName string //评论人姓名
    ReCommentName  string //父评论人姓名
    CommentEmail   string
    Img            string
    CommentContent string `gorm:&#34;type:text&#34; form:&#34;CommentContent&#34; json:&#34;CommentContent&#34;` //评论内容
    CommentTime    string ` json:&#34;comment_time,omitempty&#34;`
    Parent         *Comment
    Comments       []Comment
}
</code></pre>

<h4>实现方法</h4>

<h5>1先通过查找父评论为-1的顶级评论</h5>

<p>父评论Id为-1说明他不是任何评论的子评论</p>

<h5>2在html上遍历所有的顶级评论</h5>

<p>在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论</p>

<h6>（1）递归存储每个顶级评论的子评论</h6>

<p>这里我用一个切片来储存一个顶级评论的所有子评论</p>

<pre><code class="language-go">var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
    var comments []model.Comment
    DB.Debug().Where(&#34;re_comment_id = -1 AND blog_id = ?&#34;, id).Find(&amp;comments)
    return &amp;comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
    if count != 0 {
        fmt.Println(&#34;if判断1&#34;)
        var comments []model.Comment
        DB.Debug().Where(&#34;re_comment_id = ?&#34;, id).Find(&amp;comments)
        count = len(comments)
        if count != 0 {
            fmt.Println(&#34;if判断2&#34;)
            for _, comment := range comments {
                fmt.Println(&#34;for判断1&#34;)
                Comments = append(Comments, comment)
                SelectCommentByComment(comment.Id, count)
            }
        }
    }
    fmt.Println(Comments)
    return &amp;Comments

}
</code></pre>

<p>ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来</p>

<h6>（2）出现问题的原因</h6>

<p>因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量</p>

<h6>（3）解决问题</h6>

<pre><code class="language-go">func ClearComments() bool {
    var comments []model.Comment
    Comments = comments
    return true
}

</code></pre>

<p>这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现</p>

<h4>这里我还加了一个小小的随机头像功能</h4>

<pre><code class="language-go">if  CommentName == user.Name &amp;&amp; CommentEmail == user.UserEmail {
        fmt.Println(&#34;进入了1&#34;)
        comment.Img =user.UserImg
        //找相同评论人
    }else if CommentName == one.CommentName &amp;&amp; CommentEmail == one.CommentEmail {
        fmt.Println(&#34;进入了2&#34;)
        comment.Img =one.Img
        //随机选头像
    }else{
        fmt.Println(&#34;进入了3&#34;)
        comment.Img =middleware.GetImg()
    }
</code></pre>

<h5>123分别代表三种不同的用户群体</h5>

<p>1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
<img src="/static/images/%e5%a4%b4%e5%83%8f1.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f2.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f3.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f4.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f5.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f6.png" alt=""/></p>

<h3>2、归档功能</h3>

<h4>blog的结构体属性如下</h4>

<pre><code class="language-go">package model

type Blog struct {
    Id           int
    Title        string    `form:&#34;title&#34; json:&#34;title&#34;`                          //标题
    Content      string    `gorm:&#34;type:longtext&#34; form:&#34;content&#34; json:&#34;content&#34;` //内容
    Image        string    `gorm:&#34;type:text&#34; form:&#34;image&#34; json:&#34;image&#34;`         //首图
    Numb         int       `form:&#34;numb&#34; json:&#34;numb&#34;`                            //次数
    Flag         string    `form:&#34;flag&#34; json:&#34;flag&#34;`                            //原创或者转载
    Appreciation string    `form:&#34;appreciation&#34; json:&#34;appreciation&#34;`            //打赏开关
    ShareInfo    string    `form:&#34;shareInfo&#34; json:&#34;shareInfo&#34;`                  //版权开关
    Comment      string    `form:&#34;comment&#34; json:&#34;comment&#34;`                      //评论开关
    Recommend    string    `form:&#34;recommend&#34; json:&#34;recommend&#34;`                  //推荐开关
    Description  string    `gorm:&#34;type:text&#34; form:&#34;description&#34; json:&#34;description&#34;`
    CreatTime    string    `form:&#34;creatTime&#34;  json:&#34;creat_time,omitempty&#34;`   //创建时间
    UpdateTime   string    `form:&#34;updateTime&#34;  json:&#34;update_time,omitempty&#34;` //更新时间
    Comments     []Comment `form:&#34;comments&#34; json:&#34;comments&#34;`
    TypeId       int       `form:&#34;typeId&#34; json:&#34;typeId&#34;`
    Type         Type      `form:&#34;type&#34; gorm:&#34;ForeignKey:TypeId&#34;`
    Year         int       `form:&#34;year&#34; json:&#34;year&#34;`
    Month        int       `form:&#34;month&#34; json:&#34;month&#34;`
    Day          int       `form:&#34;day&#34; json:&#34;day&#34;`
}

</code></pre>

<h4>实现方法</h4>

<p>我的思路是创建三个时间节点
year month day
利用sql分组查询</p>

<h5>Group By分组查询步骤</h5>

<h6>（1）先按照年份查询</h6>

<h6>（2）再按照年份遍历每个月份</h6>

<p>并将所有保存在一个切片中</p>

<h6>（3）按照月份遍历每个月的所有文章</h6>

<p>保存在一个Map中，key是对应的月份，value是每个月份的所有文章</p>

<h4>自此归档功能实现</h4>

<h2>3.已知BUG</h2>

<h3>后台退出功能</h3>

<p>后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧</p>

<p>开源地址
<a href="https://github.com/likewl/blog" title="github" rel="nofollow">github</a>
<a href="https://gitee.com/nculike/blog" title="gitee" rel="nofollow">gitee</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:02:13][0m  [36;1m[1.62ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:02:24][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 00:02:24][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:137)[0m 
[33m[2020-07-21 00:02:24][0m  [36;1m[0.66ms][0m   SELECT * FROM `blogs` GROUP BY YEAR DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:150)[0m 
[33m[2020-07-21 00:02:24][0m  [36;1m[0.69ms][0m   SELECT * FROM `blogs` where year = 2020 GROUP BY month DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:162)[0m 
[33m[2020-07-21 00:02:24][0m  [36;1m[0.62ms][0m   SELECT * FROM `blogs` where year = 2020 and month = 7 ORDER BY `id` DESC  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 00:02:24][0m  [36;1m[0.40ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=4  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 00:02:24][0m  [36;1m[0.34ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=3  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 00:02:24][0m  [36;1m[0.36ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=2  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 00:02:24][0m  [36;1m[0.34ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:02:25][0m  [36;1m[0.53ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:02:26][0m  [36;1m[0.56ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 00:02:26][0m  [36;1m[0.70ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 00:02:26][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 00:02:26][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 00:02:26][0m  [36;1m[0.28ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 00:02:26][0m  [36;1m[0.39ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:02:32][0m  [36;1m[0.58ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 00:02:32][0m  [36;1m[0.75ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 00:02:32][0m  [36;1m[0.22ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 00:02:32][0m  [36;1m[0.32ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 00:02:32][0m  [36;1m[0.25ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 00:02:32][0m  [36;1m[0.36ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:02:35][0m  [36;1m[0.58ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 00:02:35][0m  [36;1m[0.74ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 00:02:35][0m  [36;1m[0.58ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 00:02:35][0m  [36;1m[0.33ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 00:02:35][0m  [36;1m[0.29ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 00:02:35][0m  [36;1m[0.34ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-21 00:07:30][0m  [36;1m[0.49ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 1)  
[36;31m[2 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-21 00:07:30][0m  [36;1m[0.50ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=1  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-21 00:07:30][0m  [36;1m[0.43ms][0m  UPDATE `blogs` SET `title` = 'golang项目简单服务器部署到阿里云(linux)', `content` = '# 我个人比较推荐使用Xftp和Xshell 
# 重要是个人免费用
# 舒服又好用

# 1.下载安装go安装包：
	## （1）go语言下载地址：
	[Go语言中文网](https://studygolang.com/dl "Go语言中文网")
下载linux版本的安装包。

## （2）使用Xftp将安装包上传至指定的路径：

![](https://img-blog.csdnimg.cn/20190719142701389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
	这里上传到root目录下就行
	方便解压
## （3）解压并移到/usr/local/下：

进入指定目录，查看已有文件并且解压文件：

![](https://img-blog.csdnimg.cn/20190719143211340.png)
```
#在root目录输入ls查看目录文件
ls
#在root解压go包
tar -zxvf go的包名
```

解压完成后发现目录下多了一个go文件夹：
![](https://img-blog.csdnimg.cn/20190719143042938.png)
将文件夹移动到/usr/local/
![](https://img-blog.csdnimg.cn/20190719143137645.png)
# 2.配置环境变量：
## （1）进入目的目录查看go文件夹是否移动成功：
![](https://img-blog.csdnimg.cn/20190719143506382.png)
## （2）在usr下创建文件夹，用来存放自己的项目：
workspace
## （3）进入新建的目录workspace新建三个文件夹：
src
pkg
bin
### 说明：

	src 目录存放的是我们的go源代码，不同工程项目的代码以包名区分
	pkg 编译后生成的文件
	bin文件夹存放go install命名生成的可执行文件（这个文件夹会配置到环境变量中）
## （4）配置环境变量：

进入 /etc 修改profile文件：
![](https://img-blog.csdnimg.cn/20190719144319621.png)
```
#进入etc目录
cd /etc/
#配置 profile
vim profile
```
![](https://img-blog.csdnimg.cn/20190719145650864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
在此文件夹下加入上图的代码，代码如下：
```
// 设置go安装路径
export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin
 
// 设置工程目录
export GOPATH=/usr/workspace
export PATH=$PATH:$GOPATH/bin
```

## （5）刷新环境变量：
```
source /etc/profile
```
##  （6）查看go环境是否配置成功：
```
go version
```
## （7）查看详细配置：
```
go env
```
结果如下：  
![](https://img-blog.csdnimg.cn/20190719145255720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70) 
# 3.上传项目代码：
在刚刚创建的workspace下新创建的三个文件夹中，src 目录存放的是我们的go源代码
# 4运行
```go
go build main.go
//或者
go run main.go
```
最后执行 ./main 就行了。
如果想让项目在后台执行：执行 nohup ./main & ，这样就可以程序在后台运行了。

参考教程https://blog.csdn.net/qq_42410605/article/details/96479892', `image` = 'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3111860246,1925938903&fm=26&gp=0.jpg', `numb` = 41, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '简单又详细的教程', `creat_time` = '2020-07-19 18:32:31', `update_time` = '2020-07-20 13:11:56', `type_id` = 1, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 1  
[36;31m[1 rows affected or returned ][0m 
<h1>我个人比较推荐使用Xftp和Xshell</h1>

<h1>重要是个人免费用</h1>

<h1>舒服又好用</h1>

<h1>1.下载安装go安装包：</h1>

<pre><code>## （1）go语言下载地址：
[Go语言中文网](https://studygolang.com/dl &#34;Go语言中文网&#34;)
</code></pre>

<p>下载linux版本的安装包。</p>

<h2>（2）使用Xftp将安装包上传至指定的路径：</h2>

<p><img src="https://img-blog.csdnimg.cn/20190719142701389.png?x-oss-process=image%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1%2Csize_16%2Ccolor_FFFFFF%2Ct_70" alt=""/>
    这里上传到root目录下就行
    方便解压</p>

<h2>（3）解压并移到/usr/local/下：</h2>

<p>进入指定目录，查看已有文件并且解压文件：</p>

<p><img src="https://img-blog.csdnimg.cn/20190719143211340.png" alt=""/></p>

<pre><code>#在root目录输入ls查看目录文件
ls
#在root解压go包
tar -zxvf go的包名
</code></pre>

<p>解压完成后发现目录下多了一个go文件夹：
<img src="https://img-blog.csdnimg.cn/20190719143042938.png" alt=""/>
将文件夹移动到/usr/local/
<img src="https://img-blog.csdnimg.cn/20190719143137645.png" alt=""/></p>

<h1>2.配置环境变量：</h1>

<h2>（1）进入目的目录查看go文件夹是否移动成功：</h2>

<p><img src="https://img-blog.csdnimg.cn/20190719143506382.png" alt=""/></p>

<h2>（2）在usr下创建文件夹，用来存放自己的项目：</h2>

<p>workspace</p>

<h2>（3）进入新建的目录workspace新建三个文件夹：</h2>

<p>src
pkg
bin</p>

<h3>说明：</h3>

<pre><code>src 目录存放的是我们的go源代码，不同工程项目的代码以包名区分
pkg 编译后生成的文件
bin文件夹存放go install命名生成的可执行文件（这个文件夹会配置到环境变量中）
</code></pre>

<h2>（4）配置环境变量：</h2>

<p>进入 /etc 修改profile文件：
<img src="https://img-blog.csdnimg.cn/20190719144319621.png" alt=""/></p>

<pre><code>#进入etc目录
cd /etc/
#配置 profile
vim profile
</code></pre>

<p><img src="https://img-blog.csdnimg.cn/20190719145650864.png?x-oss-process=image%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1%2Csize_16%2Ccolor_FFFFFF%2Ct_70" alt=""/>
在此文件夹下加入上图的代码，代码如下：</p>

<pre><code>// 设置go安装路径
export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin
 
// 设置工程目录
export GOPATH=/usr/workspace
export PATH=$PATH:$GOPATH/bin
</code></pre>

<h2>（5）刷新环境变量：</h2>

<pre><code>source /etc/profile
</code></pre>

<h2> （6）查看go环境是否配置成功：</h2>

<pre><code>go version
</code></pre>

<h2>（7）查看详细配置：</h2>

<pre><code>go env
</code></pre>

<p>结果如下：  
<img src="https://img-blog.csdnimg.cn/20190719145255720.png?x-oss-process=image%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1%2Csize_16%2Ccolor_FFFFFF%2Ct_70" alt=""/> </p>

<h1>3.上传项目代码：</h1>

<p>在刚刚创建的workspace下新创建的三个文件夹中，src 目录存放的是我们的go源代码</p>

<h1>4运行</h1>

<pre><code class="language-go">go build main.go
//或者
go run main.go
</code></pre>

<p>最后执行 ./main 就行了。
如果想让项目在后台执行：执行 nohup ./main &amp; ，这样就可以程序在后台运行了。</p>

<p>参考教程<a href="https://blog.csdn.net/qq_42410605/article/details/96479892" rel="nofollow">https://blog.csdn.net/qq_42410605/article/details/96479892</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:07:30][0m  [36;1m[0.28ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-21 00:07:31][0m  [36;1m[0.44ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 1)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-21 00:07:31][0m  [36;1m[0.39ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 2)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-21 00:07:31][0m  [36;1m[0.35ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 4)  
[36;31m[0 rows affected or returned ][0m 
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-21 00:07:31][0m  [36;1m[0.40ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 3)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-21 00:07:31][0m  [36;1m[0.35ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 5)  
[36;31m[0 rows affected or returned ][0m 
[{5 1 3 like 狗科 535889315@qq.com /static/images/header.jpg ？？？ 2020-07-20 13:30:17 <nil> []}]
[{5 1 3 like 狗科 535889315@qq.com /static/images/header.jpg ？？？ 2020-07-20 13:30:17 <nil> []}]

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-21 00:08:19][0m  [36;1m[0.45ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 1)  
[36;31m[2 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-21 00:08:19][0m  [36;1m[0.48ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=1  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-21 00:08:19][0m  [36;1m[0.45ms][0m  UPDATE `blogs` SET `title` = 'golang项目简单服务器部署到阿里云(linux)', `content` = '# 我个人比较推荐使用Xftp和Xshell 
# 重要是个人免费用
# 舒服又好用

# 1.下载安装go安装包：
	## （1）go语言下载地址：
	[Go语言中文网](https://studygolang.com/dl "Go语言中文网")
下载linux版本的安装包。

## （2）使用Xftp将安装包上传至指定的路径：

![](https://img-blog.csdnimg.cn/20190719142701389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
	这里上传到root目录下就行
	方便解压
## （3）解压并移到/usr/local/下：

进入指定目录，查看已有文件并且解压文件：

![](https://img-blog.csdnimg.cn/20190719143211340.png)
```
#在root目录输入ls查看目录文件
ls
#在root解压go包
tar -zxvf go的包名
```

解压完成后发现目录下多了一个go文件夹：
![](https://img-blog.csdnimg.cn/20190719143042938.png)
将文件夹移动到/usr/local/
![](https://img-blog.csdnimg.cn/20190719143137645.png)
# 2.配置环境变量：
## （1）进入目的目录查看go文件夹是否移动成功：
![](https://img-blog.csdnimg.cn/20190719143506382.png)
## （2）在usr下创建文件夹，用来存放自己的项目：
workspace
## （3）进入新建的目录workspace新建三个文件夹：
src
pkg
bin
### 说明：

	src 目录存放的是我们的go源代码，不同工程项目的代码以包名区分
	pkg 编译后生成的文件
	bin文件夹存放go install命名生成的可执行文件（这个文件夹会配置到环境变量中）
## （4）配置环境变量：

进入 /etc 修改profile文件：
![](https://img-blog.csdnimg.cn/20190719144319621.png)
```
#进入etc目录
cd /etc/
#配置 profile
vim profile
```
![](https://img-blog.csdnimg.cn/20190719145650864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
在此文件夹下加入上图的代码，代码如下：
```
// 设置go安装路径
export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin
 
// 设置工程目录
export GOPATH=/usr/workspace
export PATH=$PATH:$GOPATH/bin
```

## （5）刷新环境变量：
```
source /etc/profile
```
##  （6）查看go环境是否配置成功：
```
go version
```
## （7）查看详细配置：
```
go env
```
结果如下：  
![](https://img-blog.csdnimg.cn/20190719145255720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70) 
# 3.上传项目代码：
在刚刚创建的workspace下新创建的三个文件夹中，src 目录存放的是我们的go源代码
# 4运行
```go
go build main.go
//或者
go run main.go
```
最后执行 ./main 就行了。
如果想让项目在后台执行：执行 nohup ./main & ，这样就可以程序在后台运行了。

参考教程https://blog.csdn.net/qq_42410605/article/details/96479892', `image` = 'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3111860246,1925938903&fm=26&gp=0.jpg', `numb` = 42, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '简单又详细的教程', `creat_time` = '2020-07-19 18:32:31', `update_time` = '2020-07-20 13:11:56', `type_id` = 1, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 1  
[36;31m[1 rows affected or returned ][0m 
<h1>我个人比较推荐使用Xftp和Xshell</h1>

<h1>重要是个人免费用</h1>

<h1>舒服又好用</h1>

<h1>1.下载安装go安装包：</h1>

<pre><code>## （1）go语言下载地址：
[Go语言中文网](https://studygolang.com/dl &#34;Go语言中文网&#34;)
</code></pre>

<p>下载linux版本的安装包。</p>

<h2>（2）使用Xftp将安装包上传至指定的路径：</h2>

<p><img src="https://img-blog.csdnimg.cn/20190719142701389.png?x-oss-process=image%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1%2Csize_16%2Ccolor_FFFFFF%2Ct_70" alt=""/>
    这里上传到root目录下就行
    方便解压</p>

<h2>（3）解压并移到/usr/local/下：</h2>

<p>进入指定目录，查看已有文件并且解压文件：</p>

<p><img src="https://img-blog.csdnimg.cn/20190719143211340.png" alt=""/></p>

<pre><code>#在root目录输入ls查看目录文件
ls
#在root解压go包
tar -zxvf go的包名
</code></pre>

<p>解压完成后发现目录下多了一个go文件夹：
<img src="https://img-blog.csdnimg.cn/20190719143042938.png" alt=""/>
将文件夹移动到/usr/local/
<img src="https://img-blog.csdnimg.cn/20190719143137645.png" alt=""/></p>

<h1>2.配置环境变量：</h1>

<h2>（1）进入目的目录查看go文件夹是否移动成功：</h2>

<p><img src="https://img-blog.csdnimg.cn/20190719143506382.png" alt=""/></p>

<h2>（2）在usr下创建文件夹，用来存放自己的项目：</h2>

<p>workspace</p>

<h2>（3）进入新建的目录workspace新建三个文件夹：</h2>

<p>src
pkg
bin</p>

<h3>说明：</h3>

<pre><code>src 目录存放的是我们的go源代码，不同工程项目的代码以包名区分
pkg 编译后生成的文件
bin文件夹存放go install命名生成的可执行文件（这个文件夹会配置到环境变量中）
</code></pre>

<h2>（4）配置环境变量：</h2>

<p>进入 /etc 修改profile文件：
<img src="https://img-blog.csdnimg.cn/20190719144319621.png" alt=""/></p>

<pre><code>#进入etc目录
cd /etc/
#配置 profile
vim profile
</code></pre>

<p><img src="https://img-blog.csdnimg.cn/20190719145650864.png?x-oss-process=image%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1%2Csize_16%2Ccolor_FFFFFF%2Ct_70" alt=""/>
在此文件夹下加入上图的代码，代码如下：</p>

<pre><code>// 设置go安装路径
export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin
 
// 设置工程目录
export GOPATH=/usr/workspace
export PATH=$PATH:$GOPATH/bin
</code></pre>

<h2>（5）刷新环境变量：</h2>

<pre><code>source /etc/profile
</code></pre>

<h2> （6）查看go环境是否配置成功：</h2>

<pre><code>go version
</code></pre>

<h2>（7）查看详细配置：</h2>

<pre><code>go env
</code></pre>

<p>结果如下：  
<img src="https://img-blog.csdnimg.cn/20190719145255720.png?x-oss-process=image%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1%2Csize_16%2Ccolor_FFFFFF%2Ct_70" alt=""/> </p>

<h1>3.上传项目代码：</h1>

<p>在刚刚创建的workspace下新创建的三个文件夹中，src 目录存放的是我们的go源代码</p>

<h1>4运行</h1>

<pre><code class="language-go">go build main.go
//或者
go run main.go
</code></pre>

<p>最后执行 ./main 就行了。
如果想让项目在后台执行：执行 nohup ./main &amp; ，这样就可以程序在后台运行了。</p>

<p>参考教程<a href="https://blog.csdn.net/qq_42410605/article/details/96479892" rel="nofollow">https://blog.csdn.net/qq_42410605/article/details/96479892</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:08:19][0m  [36;1m[0.28ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-21 00:08:19][0m  [36;1m[1.87ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 1)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-21 00:08:19][0m  [36;1m[0.37ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 2)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-21 00:08:19][0m  [36;1m[0.32ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 4)  
[36;31m[0 rows affected or returned ][0m 
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-21 00:08:19][0m  [36;1m[0.35ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 3)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-21 00:08:19][0m  [36;1m[0.32ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 5)  
[36;31m[0 rows affected or returned ][0m 
[{5 1 3 like 狗科 535889315@qq.com /static/images/header.jpg ？？？ 2020-07-20 13:30:17 <nil> []}]
[{5 1 3 like 狗科 535889315@qq.com /static/images/header.jpg ？？？ 2020-07-20 13:30:17 <nil> []}]

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:08:29][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 00:08:29][0m  [36;1m[0.72ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 00:08:29][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 00:08:29][0m  [36;1m[0.29ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 00:08:29][0m  [36;1m[0.27ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 00:08:29][0m  [36;1m[0.32ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-21 00:08:30][0m  [36;1m[0.35ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 4)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-21 00:08:30][0m  [36;1m[0.45ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=4  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-21 00:08:30][0m  [36;1m[0.53ms][0m  UPDATE `blogs` SET `title` = '本博客开源公告', `content` = '今天本博客评论功能发布
# 自今天起，本博客基本功能已经完成
## 发布V1.0版本并开源
## 博客语言说明
#### 本博客后端是用golang 的gin框架+gorm编写
前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的
#### 博客效果参考本站
#一、博客简介
## 1.博客目录

    blog
    ├────controller
	├────└───admin
	|	|	├──adminblog.go
	|	|	├───adminController.go
	|	|	├──adminTag.go
	|	|	├──adminType.go
	|	|	└──adminUser.go
	|	└──page
	|		├──404.go
	|		├───about.go
	|		├──archives.go
	|		├──blog.go
	|		├──comment.go
	|		├──pagesController.go
	|		├──researchController.go
	|		└──tagsController.go
    ├── dao
	│	├──blogs.go
	│	├──comment.go
	│	├──sql.go
	│	├──tags.go
	│	├──types.go
	│	└──user.go
    ├── logic
    │   └── user.go
    ├── middlerware
	│	├──function.go
	│	├──getImg.go
	│	├──getTime.go
	│	├──markdown.go
	│	├──select.go
	│	└──session.go
    ├── model
	│	├──blog.go
	│	├──commnent.go
	│	├──tag.go
	│	├──type.go
	│	└──user/go
    ├── static
	│	└──静态文件（头像、图片、logo、css、js等）
    ├── templates
	│	└──html模板文件
    ├── go.mod（依赖）
    └── main.go
    

## 2.相关功能实现简介
### 1、评论及回复功能
comment的结构体属性如下
```go
package model

type Comment struct {
	Id     int //评论id
	BlogId int //博文id
	ReCommentId    int    //父评论id
	CommentName string //评论人姓名
	ReCommentName  string //父评论人姓名
	CommentEmail   string
	Img            string
	CommentContent string `gorm:"type:text" form:"CommentContent" json:"CommentContent"` //评论内容
	CommentTime    string ` json:"comment_time,omitempty"`
	Parent         *Comment
	Comments       []Comment
}
```
#### 实现方法
##### 1先通过查找父评论为-1的顶级评论
父评论Id为-1说明他不是任何评论的子评论
##### 2在html上遍历所有的顶级评论
在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论
###### （1）递归存储每个顶级评论的子评论
这里我用一个切片来储存一个顶级评论的所有子评论
```go
var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
	var comments []model.Comment
	DB.Debug().Where("re_comment_id = -1 AND blog_id = ?", id).Find(&comments)
	return &comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
	if count != 0 {
		fmt.Println("if判断1")
		var comments []model.Comment
		DB.Debug().Where("re_comment_id = ?", id).Find(&comments)
		count = len(comments)
		if count != 0 {
			fmt.Println("if判断2")
			for _, comment := range comments {
				fmt.Println("for判断1")
				Comments = append(Comments, comment)
				SelectCommentByComment(comment.Id, count)
			}
		}
	}
	fmt.Println(Comments)
	return &Comments

}
```
ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来
###### （2）出现问题的原因
因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量
###### （3）解决问题
```go
func ClearComments() bool {
	var comments []model.Comment
	Comments = comments
	return true
}

```
这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现
#### 这里我还加了一个小小的随机头像功能
```go
if  CommentName == user.Name && CommentEmail == user.UserEmail {
		fmt.Println("进入了1")
		comment.Img =user.UserImg
		//找相同评论人
	}else if CommentName == one.CommentName && CommentEmail == one.CommentEmail {
		fmt.Println("进入了2")
		comment.Img =one.Img
		//随机选头像
	}else{
		fmt.Println("进入了3")
		comment.Img =middleware.GetImg()
	}
```
##### 123分别代表三种不同的用户群体
1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
![](/static/images/%e5%a4%b4%e5%83%8f1.png)![](/static/images/%e5%a4%b4%e5%83%8f2.png)![](/static/images/%e5%a4%b4%e5%83%8f3.png)![](/static/images/%e5%a4%b4%e5%83%8f4.png)![](/static/images/%e5%a4%b4%e5%83%8f5.png)![](/static/images/%e5%a4%b4%e5%83%8f6.png)
### 2、归档功能
#### blog的结构体属性如下
```go
package model

type Blog struct {
	Id           int
	Title        string    `form:"title" json:"title"`                          //标题
	Content      string    `gorm:"type:longtext" form:"content" json:"content"` //内容
	Image        string    `gorm:"type:text" form:"image" json:"image"`         //首图
	Numb         int       `form:"numb" json:"numb"`                            //次数
	Flag         string    `form:"flag" json:"flag"`                            //原创或者转载
	Appreciation string    `form:"appreciation" json:"appreciation"`            //打赏开关
	ShareInfo    string    `form:"shareInfo" json:"shareInfo"`                  //版权开关
	Comment      string    `form:"comment" json:"comment"`                      //评论开关
	Recommend    string    `form:"recommend" json:"recommend"`                  //推荐开关
	Description  string    `gorm:"type:text" form:"description" json:"description"`
	CreatTime    string    `form:"creatTime"  json:"creat_time,omitempty"`   //创建时间
	UpdateTime   string    `form:"updateTime"  json:"update_time,omitempty"` //更新时间
	Comments     []Comment `form:"comments" json:"comments"`
	TypeId       int       `form:"typeId" json:"typeId"`
	Type         Type      `form:"type" gorm:"ForeignKey:TypeId"`
	Year         int       `form:"year" json:"year"`
	Month        int       `form:"month" json:"month"`
	Day          int       `form:"day" json:"day"`
}

```
#### 实现方法
我的思路是创建三个时间节点
year month day 
利用sql分组查询
##### Group By分组查询步骤
###### （1）先按照年份查询
###### （2）再按照年份遍历每个月份
并将所有保存在一个切片中
###### （3）按照月份遍历每个月的所有文章
保存在一个Map中，key是对应的月份，value是每个月份的所有文章
#### 自此归档功能实现


## 3.已知BUG
### 后台退出功能
后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧

开源地址
[github](https://github.com/likewl/blog "github")
[gitee](https://gitee.com/nculike/blog "gitee")', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1535821573,4166447487&fm=26&gp=0.jpg', `numb` = 18, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '本博客后端是用golang 的gin框架+gorm编写', `creat_time` = '2020-07-20 15:24:23', `update_time` = '2020-07-20 15:24:23', `type_id` = 4, `year` = 2020, `month` = 7, `day` = 20  WHERE `blogs`.`id` = 4  
[36;31m[1 rows affected or returned ][0m 
<p>今天本博客评论功能发布</p>

<h1>自今天起，本博客基本功能已经完成</h1>

<h2>发布V1.0版本并开源</h2>

<h2>博客语言说明</h2>

<h4>本博客后端是用golang 的gin框架+gorm编写</h4>

<p>前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的</p>

<h4>博客效果参考本站</h4>

<p>#一、博客简介</p>

<h2>1.博客目录</h2>

<pre><code>blog
├────controller
├────└───admin
|   |   ├──adminblog.go
|   |   ├───adminController.go
|   |   ├──adminTag.go
|   |   ├──adminType.go
|   |   └──adminUser.go
|   └──page
|       ├──404.go
|       ├───about.go
|       ├──archives.go
|       ├──blog.go
|       ├──comment.go
|       ├──pagesController.go
|       ├──researchController.go
|       └──tagsController.go
├── dao
│   ├──blogs.go
│   ├──comment.go
│   ├──sql.go
│   ├──tags.go
│   ├──types.go
│   └──user.go
├── logic
│   └── user.go
├── middlerware
│   ├──function.go
│   ├──getImg.go
│   ├──getTime.go
│   ├──markdown.go
│   ├──select.go
│   └──session.go
├── model
│   ├──blog.go
│   ├──commnent.go
│   ├──tag.go
│   ├──type.go
│   └──user/go
├── static
│   └──静态文件（头像、图片、logo、css、js等）
├── templates
│   └──html模板文件
├── go.mod（依赖）
└── main.go
</code></pre>

<h2>2.相关功能实现简介</h2>

<h3>1、评论及回复功能</h3>

<p>comment的结构体属性如下</p>

<pre><code class="language-go">package model

type Comment struct {
    Id     int //评论id
    BlogId int //博文id
    ReCommentId    int    //父评论id
    CommentName string //评论人姓名
    ReCommentName  string //父评论人姓名
    CommentEmail   string
    Img            string
    CommentContent string `gorm:&#34;type:text&#34; form:&#34;CommentContent&#34; json:&#34;CommentContent&#34;` //评论内容
    CommentTime    string ` json:&#34;comment_time,omitempty&#34;`
    Parent         *Comment
    Comments       []Comment
}
</code></pre>

<h4>实现方法</h4>

<h5>1先通过查找父评论为-1的顶级评论</h5>

<p>父评论Id为-1说明他不是任何评论的子评论</p>

<h5>2在html上遍历所有的顶级评论</h5>

<p>在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论</p>

<h6>（1）递归存储每个顶级评论的子评论</h6>

<p>这里我用一个切片来储存一个顶级评论的所有子评论</p>

<pre><code class="language-go">var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
    var comments []model.Comment
    DB.Debug().Where(&#34;re_comment_id = -1 AND blog_id = ?&#34;, id).Find(&amp;comments)
    return &amp;comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
    if count != 0 {
        fmt.Println(&#34;if判断1&#34;)
        var comments []model.Comment
        DB.Debug().Where(&#34;re_comment_id = ?&#34;, id).Find(&amp;comments)
        count = len(comments)
        if count != 0 {
            fmt.Println(&#34;if判断2&#34;)
            for _, comment := range comments {
                fmt.Println(&#34;for判断1&#34;)
                Comments = append(Comments, comment)
                SelectCommentByComment(comment.Id, count)
            }
        }
    }
    fmt.Println(Comments)
    return &amp;Comments

}
</code></pre>

<p>ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来</p>

<h6>（2）出现问题的原因</h6>

<p>因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量</p>

<h6>（3）解决问题</h6>

<pre><code class="language-go">func ClearComments() bool {
    var comments []model.Comment
    Comments = comments
    return true
}

</code></pre>

<p>这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现</p>

<h4>这里我还加了一个小小的随机头像功能</h4>

<pre><code class="language-go">if  CommentName == user.Name &amp;&amp; CommentEmail == user.UserEmail {
        fmt.Println(&#34;进入了1&#34;)
        comment.Img =user.UserImg
        //找相同评论人
    }else if CommentName == one.CommentName &amp;&amp; CommentEmail == one.CommentEmail {
        fmt.Println(&#34;进入了2&#34;)
        comment.Img =one.Img
        //随机选头像
    }else{
        fmt.Println(&#34;进入了3&#34;)
        comment.Img =middleware.GetImg()
    }
</code></pre>

<h5>123分别代表三种不同的用户群体</h5>

<p>1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
<img src="/static/images/%e5%a4%b4%e5%83%8f1.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f2.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f3.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f4.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f5.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f6.png" alt=""/></p>

<h3>2、归档功能</h3>

<h4>blog的结构体属性如下</h4>

<pre><code class="language-go">package model

type Blog struct {
    Id           int
    Title        string    `form:&#34;title&#34; json:&#34;title&#34;`                          //标题
    Content      string    `gorm:&#34;type:longtext&#34; form:&#34;content&#34; json:&#34;content&#34;` //内容
    Image        string    `gorm:&#34;type:text&#34; form:&#34;image&#34; json:&#34;image&#34;`         //首图
    Numb         int       `form:&#34;numb&#34; json:&#34;numb&#34;`                            //次数
    Flag         string    `form:&#34;flag&#34; json:&#34;flag&#34;`                            //原创或者转载
    Appreciation string    `form:&#34;appreciation&#34; json:&#34;appreciation&#34;`            //打赏开关
    ShareInfo    string    `form:&#34;shareInfo&#34; json:&#34;shareInfo&#34;`                  //版权开关
    Comment      string    `form:&#34;comment&#34; json:&#34;comment&#34;`                      //评论开关
    Recommend    string    `form:&#34;recommend&#34; json:&#34;recommend&#34;`                  //推荐开关
    Description  string    `gorm:&#34;type:text&#34; form:&#34;description&#34; json:&#34;description&#34;`
    CreatTime    string    `form:&#34;creatTime&#34;  json:&#34;creat_time,omitempty&#34;`   //创建时间
    UpdateTime   string    `form:&#34;updateTime&#34;  json:&#34;update_time,omitempty&#34;` //更新时间
    Comments     []Comment `form:&#34;comments&#34; json:&#34;comments&#34;`
    TypeId       int       `form:&#34;typeId&#34; json:&#34;typeId&#34;`
    Type         Type      `form:&#34;type&#34; gorm:&#34;ForeignKey:TypeId&#34;`
    Year         int       `form:&#34;year&#34; json:&#34;year&#34;`
    Month        int       `form:&#34;month&#34; json:&#34;month&#34;`
    Day          int       `form:&#34;day&#34; json:&#34;day&#34;`
}

</code></pre>

<h4>实现方法</h4>

<p>我的思路是创建三个时间节点
year month day
利用sql分组查询</p>

<h5>Group By分组查询步骤</h5>

<h6>（1）先按照年份查询</h6>

<h6>（2）再按照年份遍历每个月份</h6>

<p>并将所有保存在一个切片中</p>

<h6>（3）按照月份遍历每个月的所有文章</h6>

<p>保存在一个Map中，key是对应的月份，value是每个月份的所有文章</p>

<h4>自此归档功能实现</h4>

<h2>3.已知BUG</h2>

<h3>后台退出功能</h3>

<p>后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧</p>

<p>开源地址
<a href="https://github.com/likewl/blog" title="github" rel="nofollow">github</a>
<a href="https://gitee.com/nculike/blog" title="gitee" rel="nofollow">gitee</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:08:30][0m  [36;1m[0.27ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-21 00:08:42][0m  [36;1m[0.37ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 4)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-21 00:08:42][0m  [36;1m[0.45ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=4  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-21 00:08:42][0m  [36;1m[0.50ms][0m  UPDATE `blogs` SET `title` = '本博客开源公告', `content` = '今天本博客评论功能发布
# 自今天起，本博客基本功能已经完成
## 发布V1.0版本并开源
## 博客语言说明
#### 本博客后端是用golang 的gin框架+gorm编写
前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的
#### 博客效果参考本站
#一、博客简介
## 1.博客目录

    blog
    ├────controller
	├────└───admin
	|	|	├──adminblog.go
	|	|	├───adminController.go
	|	|	├──adminTag.go
	|	|	├──adminType.go
	|	|	└──adminUser.go
	|	└──page
	|		├──404.go
	|		├───about.go
	|		├──archives.go
	|		├──blog.go
	|		├──comment.go
	|		├──pagesController.go
	|		├──researchController.go
	|		└──tagsController.go
    ├── dao
	│	├──blogs.go
	│	├──comment.go
	│	├──sql.go
	│	├──tags.go
	│	├──types.go
	│	└──user.go
    ├── logic
    │   └── user.go
    ├── middlerware
	│	├──function.go
	│	├──getImg.go
	│	├──getTime.go
	│	├──markdown.go
	│	├──select.go
	│	└──session.go
    ├── model
	│	├──blog.go
	│	├──commnent.go
	│	├──tag.go
	│	├──type.go
	│	└──user/go
    ├── static
	│	└──静态文件（头像、图片、logo、css、js等）
    ├── templates
	│	└──html模板文件
    ├── go.mod（依赖）
    └── main.go
    

## 2.相关功能实现简介
### 1、评论及回复功能
comment的结构体属性如下
```go
package model

type Comment struct {
	Id     int //评论id
	BlogId int //博文id
	ReCommentId    int    //父评论id
	CommentName string //评论人姓名
	ReCommentName  string //父评论人姓名
	CommentEmail   string
	Img            string
	CommentContent string `gorm:"type:text" form:"CommentContent" json:"CommentContent"` //评论内容
	CommentTime    string ` json:"comment_time,omitempty"`
	Parent         *Comment
	Comments       []Comment
}
```
#### 实现方法
##### 1先通过查找父评论为-1的顶级评论
父评论Id为-1说明他不是任何评论的子评论
##### 2在html上遍历所有的顶级评论
在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论
###### （1）递归存储每个顶级评论的子评论
这里我用一个切片来储存一个顶级评论的所有子评论
```go
var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
	var comments []model.Comment
	DB.Debug().Where("re_comment_id = -1 AND blog_id = ?", id).Find(&comments)
	return &comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
	if count != 0 {
		fmt.Println("if判断1")
		var comments []model.Comment
		DB.Debug().Where("re_comment_id = ?", id).Find(&comments)
		count = len(comments)
		if count != 0 {
			fmt.Println("if判断2")
			for _, comment := range comments {
				fmt.Println("for判断1")
				Comments = append(Comments, comment)
				SelectCommentByComment(comment.Id, count)
			}
		}
	}
	fmt.Println(Comments)
	return &Comments

}
```
ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来
###### （2）出现问题的原因
因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量
###### （3）解决问题
```go
func ClearComments() bool {
	var comments []model.Comment
	Comments = comments
	return true
}

```
这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现
#### 这里我还加了一个小小的随机头像功能
```go
if  CommentName == user.Name && CommentEmail == user.UserEmail {
		fmt.Println("进入了1")
		comment.Img =user.UserImg
		//找相同评论人
	}else if CommentName == one.CommentName && CommentEmail == one.CommentEmail {
		fmt.Println("进入了2")
		comment.Img =one.Img
		//随机选头像
	}else{
		fmt.Println("进入了3")
		comment.Img =middleware.GetImg()
	}
```
##### 123分别代表三种不同的用户群体
1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
![](/static/images/%e5%a4%b4%e5%83%8f1.png)![](/static/images/%e5%a4%b4%e5%83%8f2.png)![](/static/images/%e5%a4%b4%e5%83%8f3.png)![](/static/images/%e5%a4%b4%e5%83%8f4.png)![](/static/images/%e5%a4%b4%e5%83%8f5.png)![](/static/images/%e5%a4%b4%e5%83%8f6.png)
### 2、归档功能
#### blog的结构体属性如下
```go
package model

type Blog struct {
	Id           int
	Title        string    `form:"title" json:"title"`                          //标题
	Content      string    `gorm:"type:longtext" form:"content" json:"content"` //内容
	Image        string    `gorm:"type:text" form:"image" json:"image"`         //首图
	Numb         int       `form:"numb" json:"numb"`                            //次数
	Flag         string    `form:"flag" json:"flag"`                            //原创或者转载
	Appreciation string    `form:"appreciation" json:"appreciation"`            //打赏开关
	ShareInfo    string    `form:"shareInfo" json:"shareInfo"`                  //版权开关
	Comment      string    `form:"comment" json:"comment"`                      //评论开关
	Recommend    string    `form:"recommend" json:"recommend"`                  //推荐开关
	Description  string    `gorm:"type:text" form:"description" json:"description"`
	CreatTime    string    `form:"creatTime"  json:"creat_time,omitempty"`   //创建时间
	UpdateTime   string    `form:"updateTime"  json:"update_time,omitempty"` //更新时间
	Comments     []Comment `form:"comments" json:"comments"`
	TypeId       int       `form:"typeId" json:"typeId"`
	Type         Type      `form:"type" gorm:"ForeignKey:TypeId"`
	Year         int       `form:"year" json:"year"`
	Month        int       `form:"month" json:"month"`
	Day          int       `form:"day" json:"day"`
}

```
#### 实现方法
我的思路是创建三个时间节点
year month day 
利用sql分组查询
##### Group By分组查询步骤
###### （1）先按照年份查询
###### （2）再按照年份遍历每个月份
并将所有保存在一个切片中
###### （3）按照月份遍历每个月的所有文章
保存在一个Map中，key是对应的月份，value是每个月份的所有文章
#### 自此归档功能实现


## 3.已知BUG
### 后台退出功能
后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧

开源地址
[github](https://github.com/likewl/blog "github")
[gitee](https://gitee.com/nculike/blog "gitee")', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1535821573,4166447487&fm=26&gp=0.jpg', `numb` = 19, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '本博客后端是用golang 的gin框架+gorm编写', `creat_time` = '2020-07-20 15:24:23', `update_time` = '2020-07-20 15:24:23', `type_id` = 4, `year` = 2020, `month` = 7, `day` = 20  WHERE `blogs`.`id` = 4  
[36;31m[1 rows affected or returned ][0m 
<p>今天本博客评论功能发布</p>

<h1>自今天起，本博客基本功能已经完成</h1>

<h2>发布V1.0版本并开源</h2>

<h2>博客语言说明</h2>

<h4>本博客后端是用golang 的gin框架+gorm编写</h4>

<p>前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的</p>

<h4>博客效果参考本站</h4>

<p>#一、博客简介</p>

<h2>1.博客目录</h2>

<pre><code>blog
├────controller
├────└───admin
|   |   ├──adminblog.go
|   |   ├───adminController.go
|   |   ├──adminTag.go
|   |   ├──adminType.go
|   |   └──adminUser.go
|   └──page
|       ├──404.go
|       ├───about.go
|       ├──archives.go
|       ├──blog.go
|       ├──comment.go
|       ├──pagesController.go
|       ├──researchController.go
|       └──tagsController.go
├── dao
│   ├──blogs.go
│   ├──comment.go
│   ├──sql.go
│   ├──tags.go
│   ├──types.go
│   └──user.go
├── logic
│   └── user.go
├── middlerware
│   ├──function.go
│   ├──getImg.go
│   ├──getTime.go
│   ├──markdown.go
│   ├──select.go
│   └──session.go
├── model
│   ├──blog.go
│   ├──commnent.go
│   ├──tag.go
│   ├──type.go
│   └──user/go
├── static
│   └──静态文件（头像、图片、logo、css、js等）
├── templates
│   └──html模板文件
├── go.mod（依赖）
└── main.go
</code></pre>

<h2>2.相关功能实现简介</h2>

<h3>1、评论及回复功能</h3>

<p>comment的结构体属性如下</p>

<pre><code class="language-go">package model

type Comment struct {
    Id     int //评论id
    BlogId int //博文id
    ReCommentId    int    //父评论id
    CommentName string //评论人姓名
    ReCommentName  string //父评论人姓名
    CommentEmail   string
    Img            string
    CommentContent string `gorm:&#34;type:text&#34; form:&#34;CommentContent&#34; json:&#34;CommentContent&#34;` //评论内容
    CommentTime    string ` json:&#34;comment_time,omitempty&#34;`
    Parent         *Comment
    Comments       []Comment
}
</code></pre>

<h4>实现方法</h4>

<h5>1先通过查找父评论为-1的顶级评论</h5>

<p>父评论Id为-1说明他不是任何评论的子评论</p>

<h5>2在html上遍历所有的顶级评论</h5>

<p>在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论</p>

<h6>（1）递归存储每个顶级评论的子评论</h6>

<p>这里我用一个切片来储存一个顶级评论的所有子评论</p>

<pre><code class="language-go">var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
    var comments []model.Comment
    DB.Debug().Where(&#34;re_comment_id = -1 AND blog_id = ?&#34;, id).Find(&amp;comments)
    return &amp;comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
    if count != 0 {
        fmt.Println(&#34;if判断1&#34;)
        var comments []model.Comment
        DB.Debug().Where(&#34;re_comment_id = ?&#34;, id).Find(&amp;comments)
        count = len(comments)
        if count != 0 {
            fmt.Println(&#34;if判断2&#34;)
            for _, comment := range comments {
                fmt.Println(&#34;for判断1&#34;)
                Comments = append(Comments, comment)
                SelectCommentByComment(comment.Id, count)
            }
        }
    }
    fmt.Println(Comments)
    return &amp;Comments

}
</code></pre>

<p>ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来</p>

<h6>（2）出现问题的原因</h6>

<p>因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量</p>

<h6>（3）解决问题</h6>

<pre><code class="language-go">func ClearComments() bool {
    var comments []model.Comment
    Comments = comments
    return true
}

</code></pre>

<p>这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现</p>

<h4>这里我还加了一个小小的随机头像功能</h4>

<pre><code class="language-go">if  CommentName == user.Name &amp;&amp; CommentEmail == user.UserEmail {
        fmt.Println(&#34;进入了1&#34;)
        comment.Img =user.UserImg
        //找相同评论人
    }else if CommentName == one.CommentName &amp;&amp; CommentEmail == one.CommentEmail {
        fmt.Println(&#34;进入了2&#34;)
        comment.Img =one.Img
        //随机选头像
    }else{
        fmt.Println(&#34;进入了3&#34;)
        comment.Img =middleware.GetImg()
    }
</code></pre>

<h5>123分别代表三种不同的用户群体</h5>

<p>1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
<img src="/static/images/%e5%a4%b4%e5%83%8f1.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f2.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f3.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f4.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f5.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f6.png" alt=""/></p>

<h3>2、归档功能</h3>

<h4>blog的结构体属性如下</h4>

<pre><code class="language-go">package model

type Blog struct {
    Id           int
    Title        string    `form:&#34;title&#34; json:&#34;title&#34;`                          //标题
    Content      string    `gorm:&#34;type:longtext&#34; form:&#34;content&#34; json:&#34;content&#34;` //内容
    Image        string    `gorm:&#34;type:text&#34; form:&#34;image&#34; json:&#34;image&#34;`         //首图
    Numb         int       `form:&#34;numb&#34; json:&#34;numb&#34;`                            //次数
    Flag         string    `form:&#34;flag&#34; json:&#34;flag&#34;`                            //原创或者转载
    Appreciation string    `form:&#34;appreciation&#34; json:&#34;appreciation&#34;`            //打赏开关
    ShareInfo    string    `form:&#34;shareInfo&#34; json:&#34;shareInfo&#34;`                  //版权开关
    Comment      string    `form:&#34;comment&#34; json:&#34;comment&#34;`                      //评论开关
    Recommend    string    `form:&#34;recommend&#34; json:&#34;recommend&#34;`                  //推荐开关
    Description  string    `gorm:&#34;type:text&#34; form:&#34;description&#34; json:&#34;description&#34;`
    CreatTime    string    `form:&#34;creatTime&#34;  json:&#34;creat_time,omitempty&#34;`   //创建时间
    UpdateTime   string    `form:&#34;updateTime&#34;  json:&#34;update_time,omitempty&#34;` //更新时间
    Comments     []Comment `form:&#34;comments&#34; json:&#34;comments&#34;`
    TypeId       int       `form:&#34;typeId&#34; json:&#34;typeId&#34;`
    Type         Type      `form:&#34;type&#34; gorm:&#34;ForeignKey:TypeId&#34;`
    Year         int       `form:&#34;year&#34; json:&#34;year&#34;`
    Month        int       `form:&#34;month&#34; json:&#34;month&#34;`
    Day          int       `form:&#34;day&#34; json:&#34;day&#34;`
}

</code></pre>

<h4>实现方法</h4>

<p>我的思路是创建三个时间节点
year month day
利用sql分组查询</p>

<h5>Group By分组查询步骤</h5>

<h6>（1）先按照年份查询</h6>

<h6>（2）再按照年份遍历每个月份</h6>

<p>并将所有保存在一个切片中</p>

<h6>（3）按照月份遍历每个月的所有文章</h6>

<p>保存在一个Map中，key是对应的月份，value是每个月份的所有文章</p>

<h4>自此归档功能实现</h4>

<h2>3.已知BUG</h2>

<h3>后台退出功能</h3>

<p>后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧</p>

<p>开源地址
<a href="https://github.com/likewl/blog" title="github" rel="nofollow">github</a>
<a href="https://gitee.com/nculike/blog" title="gitee" rel="nofollow">gitee</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:08:42][0m  [36;1m[1.61ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-21 00:09:09][0m  [36;1m[0.41ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 4)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-21 00:09:09][0m  [36;1m[0.49ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=4  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-21 00:09:09][0m  [36;1m[0.49ms][0m  UPDATE `blogs` SET `title` = '本博客开源公告', `content` = '今天本博客评论功能发布
# 自今天起，本博客基本功能已经完成
## 发布V1.0版本并开源
## 博客语言说明
#### 本博客后端是用golang 的gin框架+gorm编写
前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的
#### 博客效果参考本站
#一、博客简介
## 1.博客目录

    blog
    ├────controller
	├────└───admin
	|	|	├──adminblog.go
	|	|	├───adminController.go
	|	|	├──adminTag.go
	|	|	├──adminType.go
	|	|	└──adminUser.go
	|	└──page
	|		├──404.go
	|		├───about.go
	|		├──archives.go
	|		├──blog.go
	|		├──comment.go
	|		├──pagesController.go
	|		├──researchController.go
	|		└──tagsController.go
    ├── dao
	│	├──blogs.go
	│	├──comment.go
	│	├──sql.go
	│	├──tags.go
	│	├──types.go
	│	└──user.go
    ├── logic
    │   └── user.go
    ├── middlerware
	│	├──function.go
	│	├──getImg.go
	│	├──getTime.go
	│	├──markdown.go
	│	├──select.go
	│	└──session.go
    ├── model
	│	├──blog.go
	│	├──commnent.go
	│	├──tag.go
	│	├──type.go
	│	└──user/go
    ├── static
	│	└──静态文件（头像、图片、logo、css、js等）
    ├── templates
	│	└──html模板文件
    ├── go.mod（依赖）
    └── main.go
    

## 2.相关功能实现简介
### 1、评论及回复功能
comment的结构体属性如下
```go
package model

type Comment struct {
	Id     int //评论id
	BlogId int //博文id
	ReCommentId    int    //父评论id
	CommentName string //评论人姓名
	ReCommentName  string //父评论人姓名
	CommentEmail   string
	Img            string
	CommentContent string `gorm:"type:text" form:"CommentContent" json:"CommentContent"` //评论内容
	CommentTime    string ` json:"comment_time,omitempty"`
	Parent         *Comment
	Comments       []Comment
}
```
#### 实现方法
##### 1先通过查找父评论为-1的顶级评论
父评论Id为-1说明他不是任何评论的子评论
##### 2在html上遍历所有的顶级评论
在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论
###### （1）递归存储每个顶级评论的子评论
这里我用一个切片来储存一个顶级评论的所有子评论
```go
var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
	var comments []model.Comment
	DB.Debug().Where("re_comment_id = -1 AND blog_id = ?", id).Find(&comments)
	return &comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
	if count != 0 {
		fmt.Println("if判断1")
		var comments []model.Comment
		DB.Debug().Where("re_comment_id = ?", id).Find(&comments)
		count = len(comments)
		if count != 0 {
			fmt.Println("if判断2")
			for _, comment := range comments {
				fmt.Println("for判断1")
				Comments = append(Comments, comment)
				SelectCommentByComment(comment.Id, count)
			}
		}
	}
	fmt.Println(Comments)
	return &Comments

}
```
ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来
###### （2）出现问题的原因
因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量
###### （3）解决问题
```go
func ClearComments() bool {
	var comments []model.Comment
	Comments = comments
	return true
}

```
这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现
#### 这里我还加了一个小小的随机头像功能
```go
if  CommentName == user.Name && CommentEmail == user.UserEmail {
		fmt.Println("进入了1")
		comment.Img =user.UserImg
		//找相同评论人
	}else if CommentName == one.CommentName && CommentEmail == one.CommentEmail {
		fmt.Println("进入了2")
		comment.Img =one.Img
		//随机选头像
	}else{
		fmt.Println("进入了3")
		comment.Img =middleware.GetImg()
	}
```
##### 123分别代表三种不同的用户群体
1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
![](/static/images/%e5%a4%b4%e5%83%8f1.png)![](/static/images/%e5%a4%b4%e5%83%8f2.png)![](/static/images/%e5%a4%b4%e5%83%8f3.png)![](/static/images/%e5%a4%b4%e5%83%8f4.png)![](/static/images/%e5%a4%b4%e5%83%8f5.png)![](/static/images/%e5%a4%b4%e5%83%8f6.png)
### 2、归档功能
#### blog的结构体属性如下
```go
package model

type Blog struct {
	Id           int
	Title        string    `form:"title" json:"title"`                          //标题
	Content      string    `gorm:"type:longtext" form:"content" json:"content"` //内容
	Image        string    `gorm:"type:text" form:"image" json:"image"`         //首图
	Numb         int       `form:"numb" json:"numb"`                            //次数
	Flag         string    `form:"flag" json:"flag"`                            //原创或者转载
	Appreciation string    `form:"appreciation" json:"appreciation"`            //打赏开关
	ShareInfo    string    `form:"shareInfo" json:"shareInfo"`                  //版权开关
	Comment      string    `form:"comment" json:"comment"`                      //评论开关
	Recommend    string    `form:"recommend" json:"recommend"`                  //推荐开关
	Description  string    `gorm:"type:text" form:"description" json:"description"`
	CreatTime    string    `form:"creatTime"  json:"creat_time,omitempty"`   //创建时间
	UpdateTime   string    `form:"updateTime"  json:"update_time,omitempty"` //更新时间
	Comments     []Comment `form:"comments" json:"comments"`
	TypeId       int       `form:"typeId" json:"typeId"`
	Type         Type      `form:"type" gorm:"ForeignKey:TypeId"`
	Year         int       `form:"year" json:"year"`
	Month        int       `form:"month" json:"month"`
	Day          int       `form:"day" json:"day"`
}

```
#### 实现方法
我的思路是创建三个时间节点
year month day 
利用sql分组查询
##### Group By分组查询步骤
###### （1）先按照年份查询
###### （2）再按照年份遍历每个月份
并将所有保存在一个切片中
###### （3）按照月份遍历每个月的所有文章
保存在一个Map中，key是对应的月份，value是每个月份的所有文章
#### 自此归档功能实现


## 3.已知BUG
### 后台退出功能
后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧

开源地址
[github](https://github.com/likewl/blog "github")
[gitee](https://gitee.com/nculike/blog "gitee")', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1535821573,4166447487&fm=26&gp=0.jpg', `numb` = 20, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '本博客后端是用golang 的gin框架+gorm编写', `creat_time` = '2020-07-20 15:24:23', `update_time` = '2020-07-20 15:24:23', `type_id` = 4, `year` = 2020, `month` = 7, `day` = 20  WHERE `blogs`.`id` = 4  
[36;31m[1 rows affected or returned ][0m 
<p>今天本博客评论功能发布</p>

<h1>自今天起，本博客基本功能已经完成</h1>

<h2>发布V1.0版本并开源</h2>

<h2>博客语言说明</h2>

<h4>本博客后端是用golang 的gin框架+gorm编写</h4>

<p>前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的</p>

<h4>博客效果参考本站</h4>

<p>#一、博客简介</p>

<h2>1.博客目录</h2>

<pre><code>blog
├────controller
├────└───admin
|   |   ├──adminblog.go
|   |   ├───adminController.go
|   |   ├──adminTag.go
|   |   ├──adminType.go
|   |   └──adminUser.go
|   └──page
|       ├──404.go
|       ├───about.go
|       ├──archives.go
|       ├──blog.go
|       ├──comment.go
|       ├──pagesController.go
|       ├──researchController.go
|       └──tagsController.go
├── dao
│   ├──blogs.go
│   ├──comment.go
│   ├──sql.go
│   ├──tags.go
│   ├──types.go
│   └──user.go
├── logic
│   └── user.go
├── middlerware
│   ├──function.go
│   ├──getImg.go
│   ├──getTime.go
│   ├──markdown.go
│   ├──select.go
│   └──session.go
├── model
│   ├──blog.go
│   ├──commnent.go
│   ├──tag.go
│   ├──type.go
│   └──user/go
├── static
│   └──静态文件（头像、图片、logo、css、js等）
├── templates
│   └──html模板文件
├── go.mod（依赖）
└── main.go
</code></pre>

<h2>2.相关功能实现简介</h2>

<h3>1、评论及回复功能</h3>

<p>comment的结构体属性如下</p>

<pre><code class="language-go">package model

type Comment struct {
    Id     int //评论id
    BlogId int //博文id
    ReCommentId    int    //父评论id
    CommentName string //评论人姓名
    ReCommentName  string //父评论人姓名
    CommentEmail   string
    Img            string
    CommentContent string `gorm:&#34;type:text&#34; form:&#34;CommentContent&#34; json:&#34;CommentContent&#34;` //评论内容
    CommentTime    string ` json:&#34;comment_time,omitempty&#34;`
    Parent         *Comment
    Comments       []Comment
}
</code></pre>

<h4>实现方法</h4>

<h5>1先通过查找父评论为-1的顶级评论</h5>

<p>父评论Id为-1说明他不是任何评论的子评论</p>

<h5>2在html上遍历所有的顶级评论</h5>

<p>在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论</p>

<h6>（1）递归存储每个顶级评论的子评论</h6>

<p>这里我用一个切片来储存一个顶级评论的所有子评论</p>

<pre><code class="language-go">var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
    var comments []model.Comment
    DB.Debug().Where(&#34;re_comment_id = -1 AND blog_id = ?&#34;, id).Find(&amp;comments)
    return &amp;comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
    if count != 0 {
        fmt.Println(&#34;if判断1&#34;)
        var comments []model.Comment
        DB.Debug().Where(&#34;re_comment_id = ?&#34;, id).Find(&amp;comments)
        count = len(comments)
        if count != 0 {
            fmt.Println(&#34;if判断2&#34;)
            for _, comment := range comments {
                fmt.Println(&#34;for判断1&#34;)
                Comments = append(Comments, comment)
                SelectCommentByComment(comment.Id, count)
            }
        }
    }
    fmt.Println(Comments)
    return &amp;Comments

}
</code></pre>

<p>ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来</p>

<h6>（2）出现问题的原因</h6>

<p>因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量</p>

<h6>（3）解决问题</h6>

<pre><code class="language-go">func ClearComments() bool {
    var comments []model.Comment
    Comments = comments
    return true
}

</code></pre>

<p>这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现</p>

<h4>这里我还加了一个小小的随机头像功能</h4>

<pre><code class="language-go">if  CommentName == user.Name &amp;&amp; CommentEmail == user.UserEmail {
        fmt.Println(&#34;进入了1&#34;)
        comment.Img =user.UserImg
        //找相同评论人
    }else if CommentName == one.CommentName &amp;&amp; CommentEmail == one.CommentEmail {
        fmt.Println(&#34;进入了2&#34;)
        comment.Img =one.Img
        //随机选头像
    }else{
        fmt.Println(&#34;进入了3&#34;)
        comment.Img =middleware.GetImg()
    }
</code></pre>

<h5>123分别代表三种不同的用户群体</h5>

<p>1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
<img src="/static/images/%e5%a4%b4%e5%83%8f1.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f2.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f3.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f4.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f5.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f6.png" alt=""/></p>

<h3>2、归档功能</h3>

<h4>blog的结构体属性如下</h4>

<pre><code class="language-go">package model

type Blog struct {
    Id           int
    Title        string    `form:&#34;title&#34; json:&#34;title&#34;`                          //标题
    Content      string    `gorm:&#34;type:longtext&#34; form:&#34;content&#34; json:&#34;content&#34;` //内容
    Image        string    `gorm:&#34;type:text&#34; form:&#34;image&#34; json:&#34;image&#34;`         //首图
    Numb         int       `form:&#34;numb&#34; json:&#34;numb&#34;`                            //次数
    Flag         string    `form:&#34;flag&#34; json:&#34;flag&#34;`                            //原创或者转载
    Appreciation string    `form:&#34;appreciation&#34; json:&#34;appreciation&#34;`            //打赏开关
    ShareInfo    string    `form:&#34;shareInfo&#34; json:&#34;shareInfo&#34;`                  //版权开关
    Comment      string    `form:&#34;comment&#34; json:&#34;comment&#34;`                      //评论开关
    Recommend    string    `form:&#34;recommend&#34; json:&#34;recommend&#34;`                  //推荐开关
    Description  string    `gorm:&#34;type:text&#34; form:&#34;description&#34; json:&#34;description&#34;`
    CreatTime    string    `form:&#34;creatTime&#34;  json:&#34;creat_time,omitempty&#34;`   //创建时间
    UpdateTime   string    `form:&#34;updateTime&#34;  json:&#34;update_time,omitempty&#34;` //更新时间
    Comments     []Comment `form:&#34;comments&#34; json:&#34;comments&#34;`
    TypeId       int       `form:&#34;typeId&#34; json:&#34;typeId&#34;`
    Type         Type      `form:&#34;type&#34; gorm:&#34;ForeignKey:TypeId&#34;`
    Year         int       `form:&#34;year&#34; json:&#34;year&#34;`
    Month        int       `form:&#34;month&#34; json:&#34;month&#34;`
    Day          int       `form:&#34;day&#34; json:&#34;day&#34;`
}

</code></pre>

<h4>实现方法</h4>

<p>我的思路是创建三个时间节点
year month day
利用sql分组查询</p>

<h5>Group By分组查询步骤</h5>

<h6>（1）先按照年份查询</h6>

<h6>（2）再按照年份遍历每个月份</h6>

<p>并将所有保存在一个切片中</p>

<h6>（3）按照月份遍历每个月的所有文章</h6>

<p>保存在一个Map中，key是对应的月份，value是每个月份的所有文章</p>

<h4>自此归档功能实现</h4>

<h2>3.已知BUG</h2>

<h3>后台退出功能</h3>

<p>后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧</p>

<p>开源地址
<a href="https://github.com/likewl/blog" title="github" rel="nofollow">github</a>
<a href="https://gitee.com/nculike/blog" title="gitee" rel="nofollow">gitee</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:09:09][0m  [36;1m[0.29ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-21 00:09:16][0m  [36;1m[0.36ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 4)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-21 00:09:16][0m  [36;1m[0.43ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=4  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-21 00:09:16][0m  [36;1m[0.43ms][0m  UPDATE `blogs` SET `title` = '本博客开源公告', `content` = '今天本博客评论功能发布
# 自今天起，本博客基本功能已经完成
## 发布V1.0版本并开源
## 博客语言说明
#### 本博客后端是用golang 的gin框架+gorm编写
前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的
#### 博客效果参考本站
#一、博客简介
## 1.博客目录

    blog
    ├────controller
	├────└───admin
	|	|	├──adminblog.go
	|	|	├───adminController.go
	|	|	├──adminTag.go
	|	|	├──adminType.go
	|	|	└──adminUser.go
	|	└──page
	|		├──404.go
	|		├───about.go
	|		├──archives.go
	|		├──blog.go
	|		├──comment.go
	|		├──pagesController.go
	|		├──researchController.go
	|		└──tagsController.go
    ├── dao
	│	├──blogs.go
	│	├──comment.go
	│	├──sql.go
	│	├──tags.go
	│	├──types.go
	│	└──user.go
    ├── logic
    │   └── user.go
    ├── middlerware
	│	├──function.go
	│	├──getImg.go
	│	├──getTime.go
	│	├──markdown.go
	│	├──select.go
	│	└──session.go
    ├── model
	│	├──blog.go
	│	├──commnent.go
	│	├──tag.go
	│	├──type.go
	│	└──user/go
    ├── static
	│	└──静态文件（头像、图片、logo、css、js等）
    ├── templates
	│	└──html模板文件
    ├── go.mod（依赖）
    └── main.go
    

## 2.相关功能实现简介
### 1、评论及回复功能
comment的结构体属性如下
```go
package model

type Comment struct {
	Id     int //评论id
	BlogId int //博文id
	ReCommentId    int    //父评论id
	CommentName string //评论人姓名
	ReCommentName  string //父评论人姓名
	CommentEmail   string
	Img            string
	CommentContent string `gorm:"type:text" form:"CommentContent" json:"CommentContent"` //评论内容
	CommentTime    string ` json:"comment_time,omitempty"`
	Parent         *Comment
	Comments       []Comment
}
```
#### 实现方法
##### 1先通过查找父评论为-1的顶级评论
父评论Id为-1说明他不是任何评论的子评论
##### 2在html上遍历所有的顶级评论
在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论
###### （1）递归存储每个顶级评论的子评论
这里我用一个切片来储存一个顶级评论的所有子评论
```go
var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
	var comments []model.Comment
	DB.Debug().Where("re_comment_id = -1 AND blog_id = ?", id).Find(&comments)
	return &comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
	if count != 0 {
		fmt.Println("if判断1")
		var comments []model.Comment
		DB.Debug().Where("re_comment_id = ?", id).Find(&comments)
		count = len(comments)
		if count != 0 {
			fmt.Println("if判断2")
			for _, comment := range comments {
				fmt.Println("for判断1")
				Comments = append(Comments, comment)
				SelectCommentByComment(comment.Id, count)
			}
		}
	}
	fmt.Println(Comments)
	return &Comments

}
```
ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来
###### （2）出现问题的原因
因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量
###### （3）解决问题
```go
func ClearComments() bool {
	var comments []model.Comment
	Comments = comments
	return true
}

```
这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现
#### 这里我还加了一个小小的随机头像功能
```go
if  CommentName == user.Name && CommentEmail == user.UserEmail {
		fmt.Println("进入了1")
		comment.Img =user.UserImg
		//找相同评论人
	}else if CommentName == one.CommentName && CommentEmail == one.CommentEmail {
		fmt.Println("进入了2")
		comment.Img =one.Img
		//随机选头像
	}else{
		fmt.Println("进入了3")
		comment.Img =middleware.GetImg()
	}
```
##### 123分别代表三种不同的用户群体
1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
![](/static/images/%e5%a4%b4%e5%83%8f1.png)![](/static/images/%e5%a4%b4%e5%83%8f2.png)![](/static/images/%e5%a4%b4%e5%83%8f3.png)![](/static/images/%e5%a4%b4%e5%83%8f4.png)![](/static/images/%e5%a4%b4%e5%83%8f5.png)![](/static/images/%e5%a4%b4%e5%83%8f6.png)
### 2、归档功能
#### blog的结构体属性如下
```go
package model

type Blog struct {
	Id           int
	Title        string    `form:"title" json:"title"`                          //标题
	Content      string    `gorm:"type:longtext" form:"content" json:"content"` //内容
	Image        string    `gorm:"type:text" form:"image" json:"image"`         //首图
	Numb         int       `form:"numb" json:"numb"`                            //次数
	Flag         string    `form:"flag" json:"flag"`                            //原创或者转载
	Appreciation string    `form:"appreciation" json:"appreciation"`            //打赏开关
	ShareInfo    string    `form:"shareInfo" json:"shareInfo"`                  //版权开关
	Comment      string    `form:"comment" json:"comment"`                      //评论开关
	Recommend    string    `form:"recommend" json:"recommend"`                  //推荐开关
	Description  string    `gorm:"type:text" form:"description" json:"description"`
	CreatTime    string    `form:"creatTime"  json:"creat_time,omitempty"`   //创建时间
	UpdateTime   string    `form:"updateTime"  json:"update_time,omitempty"` //更新时间
	Comments     []Comment `form:"comments" json:"comments"`
	TypeId       int       `form:"typeId" json:"typeId"`
	Type         Type      `form:"type" gorm:"ForeignKey:TypeId"`
	Year         int       `form:"year" json:"year"`
	Month        int       `form:"month" json:"month"`
	Day          int       `form:"day" json:"day"`
}

```
#### 实现方法
我的思路是创建三个时间节点
year month day 
利用sql分组查询
##### Group By分组查询步骤
###### （1）先按照年份查询
###### （2）再按照年份遍历每个月份
并将所有保存在一个切片中
###### （3）按照月份遍历每个月的所有文章
保存在一个Map中，key是对应的月份，value是每个月份的所有文章
#### 自此归档功能实现


## 3.已知BUG
### 后台退出功能
后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧

开源地址
[github](https://github.com/likewl/blog "github")
[gitee](https://gitee.com/nculike/blog "gitee")', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1535821573,4166447487&fm=26&gp=0.jpg', `numb` = 21, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '本博客后端是用golang 的gin框架+gorm编写', `creat_time` = '2020-07-20 15:24:23', `update_time` = '2020-07-20 15:24:23', `type_id` = 4, `year` = 2020, `month` = 7, `day` = 20  WHERE `blogs`.`id` = 4  
[36;31m[1 rows affected or returned ][0m 
<p>今天本博客评论功能发布</p>

<h1>自今天起，本博客基本功能已经完成</h1>

<h2>发布V1.0版本并开源</h2>

<h2>博客语言说明</h2>

<h4>本博客后端是用golang 的gin框架+gorm编写</h4>

<p>前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的</p>

<h4>博客效果参考本站</h4>

<p>#一、博客简介</p>

<h2>1.博客目录</h2>

<pre><code>blog
├────controller
├────└───admin
|   |   ├──adminblog.go
|   |   ├───adminController.go
|   |   ├──adminTag.go
|   |   ├──adminType.go
|   |   └──adminUser.go
|   └──page
|       ├──404.go
|       ├───about.go
|       ├──archives.go
|       ├──blog.go
|       ├──comment.go
|       ├──pagesController.go
|       ├──researchController.go
|       └──tagsController.go
├── dao
│   ├──blogs.go
│   ├──comment.go
│   ├──sql.go
│   ├──tags.go
│   ├──types.go
│   └──user.go
├── logic
│   └── user.go
├── middlerware
│   ├──function.go
│   ├──getImg.go
│   ├──getTime.go
│   ├──markdown.go
│   ├──select.go
│   └──session.go
├── model
│   ├──blog.go
│   ├──commnent.go
│   ├──tag.go
│   ├──type.go
│   └──user/go
├── static
│   └──静态文件（头像、图片、logo、css、js等）
├── templates
│   └──html模板文件
├── go.mod（依赖）
└── main.go
</code></pre>

<h2>2.相关功能实现简介</h2>

<h3>1、评论及回复功能</h3>

<p>comment的结构体属性如下</p>

<pre><code class="language-go">package model

type Comment struct {
    Id     int //评论id
    BlogId int //博文id
    ReCommentId    int    //父评论id
    CommentName string //评论人姓名
    ReCommentName  string //父评论人姓名
    CommentEmail   string
    Img            string
    CommentContent string `gorm:&#34;type:text&#34; form:&#34;CommentContent&#34; json:&#34;CommentContent&#34;` //评论内容
    CommentTime    string ` json:&#34;comment_time,omitempty&#34;`
    Parent         *Comment
    Comments       []Comment
}
</code></pre>

<h4>实现方法</h4>

<h5>1先通过查找父评论为-1的顶级评论</h5>

<p>父评论Id为-1说明他不是任何评论的子评论</p>

<h5>2在html上遍历所有的顶级评论</h5>

<p>在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论</p>

<h6>（1）递归存储每个顶级评论的子评论</h6>

<p>这里我用一个切片来储存一个顶级评论的所有子评论</p>

<pre><code class="language-go">var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
    var comments []model.Comment
    DB.Debug().Where(&#34;re_comment_id = -1 AND blog_id = ?&#34;, id).Find(&amp;comments)
    return &amp;comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
    if count != 0 {
        fmt.Println(&#34;if判断1&#34;)
        var comments []model.Comment
        DB.Debug().Where(&#34;re_comment_id = ?&#34;, id).Find(&amp;comments)
        count = len(comments)
        if count != 0 {
            fmt.Println(&#34;if判断2&#34;)
            for _, comment := range comments {
                fmt.Println(&#34;for判断1&#34;)
                Comments = append(Comments, comment)
                SelectCommentByComment(comment.Id, count)
            }
        }
    }
    fmt.Println(Comments)
    return &amp;Comments

}
</code></pre>

<p>ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来</p>

<h6>（2）出现问题的原因</h6>

<p>因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量</p>

<h6>（3）解决问题</h6>

<pre><code class="language-go">func ClearComments() bool {
    var comments []model.Comment
    Comments = comments
    return true
}

</code></pre>

<p>这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现</p>

<h4>这里我还加了一个小小的随机头像功能</h4>

<pre><code class="language-go">if  CommentName == user.Name &amp;&amp; CommentEmail == user.UserEmail {
        fmt.Println(&#34;进入了1&#34;)
        comment.Img =user.UserImg
        //找相同评论人
    }else if CommentName == one.CommentName &amp;&amp; CommentEmail == one.CommentEmail {
        fmt.Println(&#34;进入了2&#34;)
        comment.Img =one.Img
        //随机选头像
    }else{
        fmt.Println(&#34;进入了3&#34;)
        comment.Img =middleware.GetImg()
    }
</code></pre>

<h5>123分别代表三种不同的用户群体</h5>

<p>1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
<img src="/static/images/%e5%a4%b4%e5%83%8f1.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f2.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f3.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f4.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f5.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f6.png" alt=""/></p>

<h3>2、归档功能</h3>

<h4>blog的结构体属性如下</h4>

<pre><code class="language-go">package model

type Blog struct {
    Id           int
    Title        string    `form:&#34;title&#34; json:&#34;title&#34;`                          //标题
    Content      string    `gorm:&#34;type:longtext&#34; form:&#34;content&#34; json:&#34;content&#34;` //内容
    Image        string    `gorm:&#34;type:text&#34; form:&#34;image&#34; json:&#34;image&#34;`         //首图
    Numb         int       `form:&#34;numb&#34; json:&#34;numb&#34;`                            //次数
    Flag         string    `form:&#34;flag&#34; json:&#34;flag&#34;`                            //原创或者转载
    Appreciation string    `form:&#34;appreciation&#34; json:&#34;appreciation&#34;`            //打赏开关
    ShareInfo    string    `form:&#34;shareInfo&#34; json:&#34;shareInfo&#34;`                  //版权开关
    Comment      string    `form:&#34;comment&#34; json:&#34;comment&#34;`                      //评论开关
    Recommend    string    `form:&#34;recommend&#34; json:&#34;recommend&#34;`                  //推荐开关
    Description  string    `gorm:&#34;type:text&#34; form:&#34;description&#34; json:&#34;description&#34;`
    CreatTime    string    `form:&#34;creatTime&#34;  json:&#34;creat_time,omitempty&#34;`   //创建时间
    UpdateTime   string    `form:&#34;updateTime&#34;  json:&#34;update_time,omitempty&#34;` //更新时间
    Comments     []Comment `form:&#34;comments&#34; json:&#34;comments&#34;`
    TypeId       int       `form:&#34;typeId&#34; json:&#34;typeId&#34;`
    Type         Type      `form:&#34;type&#34; gorm:&#34;ForeignKey:TypeId&#34;`
    Year         int       `form:&#34;year&#34; json:&#34;year&#34;`
    Month        int       `form:&#34;month&#34; json:&#34;month&#34;`
    Day          int       `form:&#34;day&#34; json:&#34;day&#34;`
}

</code></pre>

<h4>实现方法</h4>

<p>我的思路是创建三个时间节点
year month day
利用sql分组查询</p>

<h5>Group By分组查询步骤</h5>

<h6>（1）先按照年份查询</h6>

<h6>（2）再按照年份遍历每个月份</h6>

<p>并将所有保存在一个切片中</p>

<h6>（3）按照月份遍历每个月的所有文章</h6>

<p>保存在一个Map中，key是对应的月份，value是每个月份的所有文章</p>

<h4>自此归档功能实现</h4>

<h2>3.已知BUG</h2>

<h3>后台退出功能</h3>

<p>后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧</p>

<p>开源地址
<a href="https://github.com/likewl/blog" title="github" rel="nofollow">github</a>
<a href="https://gitee.com/nculike/blog" title="gitee" rel="nofollow">gitee</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:09:16][0m  [36;1m[0.27ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:09:21][0m  [36;1m[0.60ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 00:09:21][0m  [36;1m[1.36ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 00:09:21][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 00:09:21][0m  [36;1m[0.33ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 00:09:21][0m  [36;1m[0.25ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 00:09:21][0m  [36;1m[0.35ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-21 00:09:22][0m  [36;1m[0.37ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 4)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-21 00:09:22][0m  [36;1m[0.49ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=4  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-21 00:09:22][0m  [36;1m[0.46ms][0m  UPDATE `blogs` SET `title` = '本博客开源公告', `content` = '今天本博客评论功能发布
# 自今天起，本博客基本功能已经完成
## 发布V1.0版本并开源
## 博客语言说明
#### 本博客后端是用golang 的gin框架+gorm编写
前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的
#### 博客效果参考本站
#一、博客简介
## 1.博客目录

    blog
    ├────controller
	├────└───admin
	|	|	├──adminblog.go
	|	|	├───adminController.go
	|	|	├──adminTag.go
	|	|	├──adminType.go
	|	|	└──adminUser.go
	|	└──page
	|		├──404.go
	|		├───about.go
	|		├──archives.go
	|		├──blog.go
	|		├──comment.go
	|		├──pagesController.go
	|		├──researchController.go
	|		└──tagsController.go
    ├── dao
	│	├──blogs.go
	│	├──comment.go
	│	├──sql.go
	│	├──tags.go
	│	├──types.go
	│	└──user.go
    ├── logic
    │   └── user.go
    ├── middlerware
	│	├──function.go
	│	├──getImg.go
	│	├──getTime.go
	│	├──markdown.go
	│	├──select.go
	│	└──session.go
    ├── model
	│	├──blog.go
	│	├──commnent.go
	│	├──tag.go
	│	├──type.go
	│	└──user/go
    ├── static
	│	└──静态文件（头像、图片、logo、css、js等）
    ├── templates
	│	└──html模板文件
    ├── go.mod（依赖）
    └── main.go
    

## 2.相关功能实现简介
### 1、评论及回复功能
comment的结构体属性如下
```go
package model

type Comment struct {
	Id     int //评论id
	BlogId int //博文id
	ReCommentId    int    //父评论id
	CommentName string //评论人姓名
	ReCommentName  string //父评论人姓名
	CommentEmail   string
	Img            string
	CommentContent string `gorm:"type:text" form:"CommentContent" json:"CommentContent"` //评论内容
	CommentTime    string ` json:"comment_time,omitempty"`
	Parent         *Comment
	Comments       []Comment
}
```
#### 实现方法
##### 1先通过查找父评论为-1的顶级评论
父评论Id为-1说明他不是任何评论的子评论
##### 2在html上遍历所有的顶级评论
在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论
###### （1）递归存储每个顶级评论的子评论
这里我用一个切片来储存一个顶级评论的所有子评论
```go
var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
	var comments []model.Comment
	DB.Debug().Where("re_comment_id = -1 AND blog_id = ?", id).Find(&comments)
	return &comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
	if count != 0 {
		fmt.Println("if判断1")
		var comments []model.Comment
		DB.Debug().Where("re_comment_id = ?", id).Find(&comments)
		count = len(comments)
		if count != 0 {
			fmt.Println("if判断2")
			for _, comment := range comments {
				fmt.Println("for判断1")
				Comments = append(Comments, comment)
				SelectCommentByComment(comment.Id, count)
			}
		}
	}
	fmt.Println(Comments)
	return &Comments

}
```
ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来
###### （2）出现问题的原因
因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量
###### （3）解决问题
```go
func ClearComments() bool {
	var comments []model.Comment
	Comments = comments
	return true
}

```
这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现
#### 这里我还加了一个小小的随机头像功能
```go
if  CommentName == user.Name && CommentEmail == user.UserEmail {
		fmt.Println("进入了1")
		comment.Img =user.UserImg
		//找相同评论人
	}else if CommentName == one.CommentName && CommentEmail == one.CommentEmail {
		fmt.Println("进入了2")
		comment.Img =one.Img
		//随机选头像
	}else{
		fmt.Println("进入了3")
		comment.Img =middleware.GetImg()
	}
```
##### 123分别代表三种不同的用户群体
1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
![](/static/images/%e5%a4%b4%e5%83%8f1.png)![](/static/images/%e5%a4%b4%e5%83%8f2.png)![](/static/images/%e5%a4%b4%e5%83%8f3.png)![](/static/images/%e5%a4%b4%e5%83%8f4.png)![](/static/images/%e5%a4%b4%e5%83%8f5.png)![](/static/images/%e5%a4%b4%e5%83%8f6.png)
### 2、归档功能
#### blog的结构体属性如下
```go
package model

type Blog struct {
	Id           int
	Title        string    `form:"title" json:"title"`                          //标题
	Content      string    `gorm:"type:longtext" form:"content" json:"content"` //内容
	Image        string    `gorm:"type:text" form:"image" json:"image"`         //首图
	Numb         int       `form:"numb" json:"numb"`                            //次数
	Flag         string    `form:"flag" json:"flag"`                            //原创或者转载
	Appreciation string    `form:"appreciation" json:"appreciation"`            //打赏开关
	ShareInfo    string    `form:"shareInfo" json:"shareInfo"`                  //版权开关
	Comment      string    `form:"comment" json:"comment"`                      //评论开关
	Recommend    string    `form:"recommend" json:"recommend"`                  //推荐开关
	Description  string    `gorm:"type:text" form:"description" json:"description"`
	CreatTime    string    `form:"creatTime"  json:"creat_time,omitempty"`   //创建时间
	UpdateTime   string    `form:"updateTime"  json:"update_time,omitempty"` //更新时间
	Comments     []Comment `form:"comments" json:"comments"`
	TypeId       int       `form:"typeId" json:"typeId"`
	Type         Type      `form:"type" gorm:"ForeignKey:TypeId"`
	Year         int       `form:"year" json:"year"`
	Month        int       `form:"month" json:"month"`
	Day          int       `form:"day" json:"day"`
}

```
#### 实现方法
我的思路是创建三个时间节点
year month day 
利用sql分组查询
##### Group By分组查询步骤
###### （1）先按照年份查询
###### （2）再按照年份遍历每个月份
并将所有保存在一个切片中
###### （3）按照月份遍历每个月的所有文章
保存在一个Map中，key是对应的月份，value是每个月份的所有文章
#### 自此归档功能实现


## 3.已知BUG
### 后台退出功能
后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧

开源地址
[github](https://github.com/likewl/blog "github")
[gitee](https://gitee.com/nculike/blog "gitee")', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1535821573,4166447487&fm=26&gp=0.jpg', `numb` = 22, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '本博客后端是用golang 的gin框架+gorm编写', `creat_time` = '2020-07-20 15:24:23', `update_time` = '2020-07-20 15:24:23', `type_id` = 4, `year` = 2020, `month` = 7, `day` = 20  WHERE `blogs`.`id` = 4  
[36;31m[1 rows affected or returned ][0m 
<p>今天本博客评论功能发布</p>

<h1>自今天起，本博客基本功能已经完成</h1>

<h2>发布V1.0版本并开源</h2>

<h2>博客语言说明</h2>

<h4>本博客后端是用golang 的gin框架+gorm编写</h4>

<p>前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的</p>

<h4>博客效果参考本站</h4>

<p>#一、博客简介</p>

<h2>1.博客目录</h2>

<pre><code>blog
├────controller
├────└───admin
|   |   ├──adminblog.go
|   |   ├───adminController.go
|   |   ├──adminTag.go
|   |   ├──adminType.go
|   |   └──adminUser.go
|   └──page
|       ├──404.go
|       ├───about.go
|       ├──archives.go
|       ├──blog.go
|       ├──comment.go
|       ├──pagesController.go
|       ├──researchController.go
|       └──tagsController.go
├── dao
│   ├──blogs.go
│   ├──comment.go
│   ├──sql.go
│   ├──tags.go
│   ├──types.go
│   └──user.go
├── logic
│   └── user.go
├── middlerware
│   ├──function.go
│   ├──getImg.go
│   ├──getTime.go
│   ├──markdown.go
│   ├──select.go
│   └──session.go
├── model
│   ├──blog.go
│   ├──commnent.go
│   ├──tag.go
│   ├──type.go
│   └──user/go
├── static
│   └──静态文件（头像、图片、logo、css、js等）
├── templates
│   └──html模板文件
├── go.mod（依赖）
└── main.go
</code></pre>

<h2>2.相关功能实现简介</h2>

<h3>1、评论及回复功能</h3>

<p>comment的结构体属性如下</p>

<pre><code class="language-go">package model

type Comment struct {
    Id     int //评论id
    BlogId int //博文id
    ReCommentId    int    //父评论id
    CommentName string //评论人姓名
    ReCommentName  string //父评论人姓名
    CommentEmail   string
    Img            string
    CommentContent string `gorm:&#34;type:text&#34; form:&#34;CommentContent&#34; json:&#34;CommentContent&#34;` //评论内容
    CommentTime    string ` json:&#34;comment_time,omitempty&#34;`
    Parent         *Comment
    Comments       []Comment
}
</code></pre>

<h4>实现方法</h4>

<h5>1先通过查找父评论为-1的顶级评论</h5>

<p>父评论Id为-1说明他不是任何评论的子评论</p>

<h5>2在html上遍历所有的顶级评论</h5>

<p>在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论</p>

<h6>（1）递归存储每个顶级评论的子评论</h6>

<p>这里我用一个切片来储存一个顶级评论的所有子评论</p>

<pre><code class="language-go">var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
    var comments []model.Comment
    DB.Debug().Where(&#34;re_comment_id = -1 AND blog_id = ?&#34;, id).Find(&amp;comments)
    return &amp;comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
    if count != 0 {
        fmt.Println(&#34;if判断1&#34;)
        var comments []model.Comment
        DB.Debug().Where(&#34;re_comment_id = ?&#34;, id).Find(&amp;comments)
        count = len(comments)
        if count != 0 {
            fmt.Println(&#34;if判断2&#34;)
            for _, comment := range comments {
                fmt.Println(&#34;for判断1&#34;)
                Comments = append(Comments, comment)
                SelectCommentByComment(comment.Id, count)
            }
        }
    }
    fmt.Println(Comments)
    return &amp;Comments

}
</code></pre>

<p>ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来</p>

<h6>（2）出现问题的原因</h6>

<p>因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量</p>

<h6>（3）解决问题</h6>

<pre><code class="language-go">func ClearComments() bool {
    var comments []model.Comment
    Comments = comments
    return true
}

</code></pre>

<p>这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现</p>

<h4>这里我还加了一个小小的随机头像功能</h4>

<pre><code class="language-go">if  CommentName == user.Name &amp;&amp; CommentEmail == user.UserEmail {
        fmt.Println(&#34;进入了1&#34;)
        comment.Img =user.UserImg
        //找相同评论人
    }else if CommentName == one.CommentName &amp;&amp; CommentEmail == one.CommentEmail {
        fmt.Println(&#34;进入了2&#34;)
        comment.Img =one.Img
        //随机选头像
    }else{
        fmt.Println(&#34;进入了3&#34;)
        comment.Img =middleware.GetImg()
    }
</code></pre>

<h5>123分别代表三种不同的用户群体</h5>

<p>1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
<img src="/static/images/%e5%a4%b4%e5%83%8f1.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f2.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f3.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f4.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f5.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f6.png" alt=""/></p>

<h3>2、归档功能</h3>

<h4>blog的结构体属性如下</h4>

<pre><code class="language-go">package model

type Blog struct {
    Id           int
    Title        string    `form:&#34;title&#34; json:&#34;title&#34;`                          //标题
    Content      string    `gorm:&#34;type:longtext&#34; form:&#34;content&#34; json:&#34;content&#34;` //内容
    Image        string    `gorm:&#34;type:text&#34; form:&#34;image&#34; json:&#34;image&#34;`         //首图
    Numb         int       `form:&#34;numb&#34; json:&#34;numb&#34;`                            //次数
    Flag         string    `form:&#34;flag&#34; json:&#34;flag&#34;`                            //原创或者转载
    Appreciation string    `form:&#34;appreciation&#34; json:&#34;appreciation&#34;`            //打赏开关
    ShareInfo    string    `form:&#34;shareInfo&#34; json:&#34;shareInfo&#34;`                  //版权开关
    Comment      string    `form:&#34;comment&#34; json:&#34;comment&#34;`                      //评论开关
    Recommend    string    `form:&#34;recommend&#34; json:&#34;recommend&#34;`                  //推荐开关
    Description  string    `gorm:&#34;type:text&#34; form:&#34;description&#34; json:&#34;description&#34;`
    CreatTime    string    `form:&#34;creatTime&#34;  json:&#34;creat_time,omitempty&#34;`   //创建时间
    UpdateTime   string    `form:&#34;updateTime&#34;  json:&#34;update_time,omitempty&#34;` //更新时间
    Comments     []Comment `form:&#34;comments&#34; json:&#34;comments&#34;`
    TypeId       int       `form:&#34;typeId&#34; json:&#34;typeId&#34;`
    Type         Type      `form:&#34;type&#34; gorm:&#34;ForeignKey:TypeId&#34;`
    Year         int       `form:&#34;year&#34; json:&#34;year&#34;`
    Month        int       `form:&#34;month&#34; json:&#34;month&#34;`
    Day          int       `form:&#34;day&#34; json:&#34;day&#34;`
}

</code></pre>

<h4>实现方法</h4>

<p>我的思路是创建三个时间节点
year month day
利用sql分组查询</p>

<h5>Group By分组查询步骤</h5>

<h6>（1）先按照年份查询</h6>

<h6>（2）再按照年份遍历每个月份</h6>

<p>并将所有保存在一个切片中</p>

<h6>（3）按照月份遍历每个月的所有文章</h6>

<p>保存在一个Map中，key是对应的月份，value是每个月份的所有文章</p>

<h4>自此归档功能实现</h4>

<h2>3.已知BUG</h2>

<h3>后台退出功能</h3>

<p>后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧</p>

<p>开源地址
<a href="https://github.com/likewl/blog" title="github" rel="nofollow">github</a>
<a href="https://gitee.com/nculike/blog" title="gitee" rel="nofollow">gitee</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:09:22][0m  [36;1m[0.27ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-21 00:09:28][0m  [36;1m[0.39ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 4)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-21 00:09:28][0m  [36;1m[0.45ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=4  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-21 00:09:28][0m  [36;1m[0.50ms][0m  UPDATE `blogs` SET `title` = '本博客开源公告', `content` = '今天本博客评论功能发布
# 自今天起，本博客基本功能已经完成
## 发布V1.0版本并开源
## 博客语言说明
#### 本博客后端是用golang 的gin框架+gorm编写
前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的
#### 博客效果参考本站
#一、博客简介
## 1.博客目录

    blog
    ├────controller
	├────└───admin
	|	|	├──adminblog.go
	|	|	├───adminController.go
	|	|	├──adminTag.go
	|	|	├──adminType.go
	|	|	└──adminUser.go
	|	└──page
	|		├──404.go
	|		├───about.go
	|		├──archives.go
	|		├──blog.go
	|		├──comment.go
	|		├──pagesController.go
	|		├──researchController.go
	|		└──tagsController.go
    ├── dao
	│	├──blogs.go
	│	├──comment.go
	│	├──sql.go
	│	├──tags.go
	│	├──types.go
	│	└──user.go
    ├── logic
    │   └── user.go
    ├── middlerware
	│	├──function.go
	│	├──getImg.go
	│	├──getTime.go
	│	├──markdown.go
	│	├──select.go
	│	└──session.go
    ├── model
	│	├──blog.go
	│	├──commnent.go
	│	├──tag.go
	│	├──type.go
	│	└──user/go
    ├── static
	│	└──静态文件（头像、图片、logo、css、js等）
    ├── templates
	│	└──html模板文件
    ├── go.mod（依赖）
    └── main.go
    

## 2.相关功能实现简介
### 1、评论及回复功能
comment的结构体属性如下
```go
package model

type Comment struct {
	Id     int //评论id
	BlogId int //博文id
	ReCommentId    int    //父评论id
	CommentName string //评论人姓名
	ReCommentName  string //父评论人姓名
	CommentEmail   string
	Img            string
	CommentContent string `gorm:"type:text" form:"CommentContent" json:"CommentContent"` //评论内容
	CommentTime    string ` json:"comment_time,omitempty"`
	Parent         *Comment
	Comments       []Comment
}
```
#### 实现方法
##### 1先通过查找父评论为-1的顶级评论
父评论Id为-1说明他不是任何评论的子评论
##### 2在html上遍历所有的顶级评论
在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论
###### （1）递归存储每个顶级评论的子评论
这里我用一个切片来储存一个顶级评论的所有子评论
```go
var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
	var comments []model.Comment
	DB.Debug().Where("re_comment_id = -1 AND blog_id = ?", id).Find(&comments)
	return &comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
	if count != 0 {
		fmt.Println("if判断1")
		var comments []model.Comment
		DB.Debug().Where("re_comment_id = ?", id).Find(&comments)
		count = len(comments)
		if count != 0 {
			fmt.Println("if判断2")
			for _, comment := range comments {
				fmt.Println("for判断1")
				Comments = append(Comments, comment)
				SelectCommentByComment(comment.Id, count)
			}
		}
	}
	fmt.Println(Comments)
	return &Comments

}
```
ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来
###### （2）出现问题的原因
因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量
###### （3）解决问题
```go
func ClearComments() bool {
	var comments []model.Comment
	Comments = comments
	return true
}

```
这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现
#### 这里我还加了一个小小的随机头像功能
```go
if  CommentName == user.Name && CommentEmail == user.UserEmail {
		fmt.Println("进入了1")
		comment.Img =user.UserImg
		//找相同评论人
	}else if CommentName == one.CommentName && CommentEmail == one.CommentEmail {
		fmt.Println("进入了2")
		comment.Img =one.Img
		//随机选头像
	}else{
		fmt.Println("进入了3")
		comment.Img =middleware.GetImg()
	}
```
##### 123分别代表三种不同的用户群体
1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
![](/static/images/%e5%a4%b4%e5%83%8f1.png)![](/static/images/%e5%a4%b4%e5%83%8f2.png)![](/static/images/%e5%a4%b4%e5%83%8f3.png)![](/static/images/%e5%a4%b4%e5%83%8f4.png)![](/static/images/%e5%a4%b4%e5%83%8f5.png)![](/static/images/%e5%a4%b4%e5%83%8f6.png)
### 2、归档功能
#### blog的结构体属性如下
```go
package model

type Blog struct {
	Id           int
	Title        string    `form:"title" json:"title"`                          //标题
	Content      string    `gorm:"type:longtext" form:"content" json:"content"` //内容
	Image        string    `gorm:"type:text" form:"image" json:"image"`         //首图
	Numb         int       `form:"numb" json:"numb"`                            //次数
	Flag         string    `form:"flag" json:"flag"`                            //原创或者转载
	Appreciation string    `form:"appreciation" json:"appreciation"`            //打赏开关
	ShareInfo    string    `form:"shareInfo" json:"shareInfo"`                  //版权开关
	Comment      string    `form:"comment" json:"comment"`                      //评论开关
	Recommend    string    `form:"recommend" json:"recommend"`                  //推荐开关
	Description  string    `gorm:"type:text" form:"description" json:"description"`
	CreatTime    string    `form:"creatTime"  json:"creat_time,omitempty"`   //创建时间
	UpdateTime   string    `form:"updateTime"  json:"update_time,omitempty"` //更新时间
	Comments     []Comment `form:"comments" json:"comments"`
	TypeId       int       `form:"typeId" json:"typeId"`
	Type         Type      `form:"type" gorm:"ForeignKey:TypeId"`
	Year         int       `form:"year" json:"year"`
	Month        int       `form:"month" json:"month"`
	Day          int       `form:"day" json:"day"`
}

```
#### 实现方法
我的思路是创建三个时间节点
year month day 
利用sql分组查询
##### Group By分组查询步骤
###### （1）先按照年份查询
###### （2）再按照年份遍历每个月份
并将所有保存在一个切片中
###### （3）按照月份遍历每个月的所有文章
保存在一个Map中，key是对应的月份，value是每个月份的所有文章
#### 自此归档功能实现


## 3.已知BUG
### 后台退出功能
后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧

开源地址
[github](https://github.com/likewl/blog "github")
[gitee](https://gitee.com/nculike/blog "gitee")', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1535821573,4166447487&fm=26&gp=0.jpg', `numb` = 23, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '本博客后端是用golang 的gin框架+gorm编写', `creat_time` = '2020-07-20 15:24:23', `update_time` = '2020-07-20 15:24:23', `type_id` = 4, `year` = 2020, `month` = 7, `day` = 20  WHERE `blogs`.`id` = 4  
[36;31m[1 rows affected or returned ][0m 
<p>今天本博客评论功能发布</p>

<h1>自今天起，本博客基本功能已经完成</h1>

<h2>发布V1.0版本并开源</h2>

<h2>博客语言说明</h2>

<h4>本博客后端是用golang 的gin框架+gorm编写</h4>

<p>前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的</p>

<h4>博客效果参考本站</h4>

<p>#一、博客简介</p>

<h2>1.博客目录</h2>

<pre><code>blog
├────controller
├────└───admin
|   |   ├──adminblog.go
|   |   ├───adminController.go
|   |   ├──adminTag.go
|   |   ├──adminType.go
|   |   └──adminUser.go
|   └──page
|       ├──404.go
|       ├───about.go
|       ├──archives.go
|       ├──blog.go
|       ├──comment.go
|       ├──pagesController.go
|       ├──researchController.go
|       └──tagsController.go
├── dao
│   ├──blogs.go
│   ├──comment.go
│   ├──sql.go
│   ├──tags.go
│   ├──types.go
│   └──user.go
├── logic
│   └── user.go
├── middlerware
│   ├──function.go
│   ├──getImg.go
│   ├──getTime.go
│   ├──markdown.go
│   ├──select.go
│   └──session.go
├── model
│   ├──blog.go
│   ├──commnent.go
│   ├──tag.go
│   ├──type.go
│   └──user/go
├── static
│   └──静态文件（头像、图片、logo、css、js等）
├── templates
│   └──html模板文件
├── go.mod（依赖）
└── main.go
</code></pre>

<h2>2.相关功能实现简介</h2>

<h3>1、评论及回复功能</h3>

<p>comment的结构体属性如下</p>

<pre><code class="language-go">package model

type Comment struct {
    Id     int //评论id
    BlogId int //博文id
    ReCommentId    int    //父评论id
    CommentName string //评论人姓名
    ReCommentName  string //父评论人姓名
    CommentEmail   string
    Img            string
    CommentContent string `gorm:&#34;type:text&#34; form:&#34;CommentContent&#34; json:&#34;CommentContent&#34;` //评论内容
    CommentTime    string ` json:&#34;comment_time,omitempty&#34;`
    Parent         *Comment
    Comments       []Comment
}
</code></pre>

<h4>实现方法</h4>

<h5>1先通过查找父评论为-1的顶级评论</h5>

<p>父评论Id为-1说明他不是任何评论的子评论</p>

<h5>2在html上遍历所有的顶级评论</h5>

<p>在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论</p>

<h6>（1）递归存储每个顶级评论的子评论</h6>

<p>这里我用一个切片来储存一个顶级评论的所有子评论</p>

<pre><code class="language-go">var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
    var comments []model.Comment
    DB.Debug().Where(&#34;re_comment_id = -1 AND blog_id = ?&#34;, id).Find(&amp;comments)
    return &amp;comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
    if count != 0 {
        fmt.Println(&#34;if判断1&#34;)
        var comments []model.Comment
        DB.Debug().Where(&#34;re_comment_id = ?&#34;, id).Find(&amp;comments)
        count = len(comments)
        if count != 0 {
            fmt.Println(&#34;if判断2&#34;)
            for _, comment := range comments {
                fmt.Println(&#34;for判断1&#34;)
                Comments = append(Comments, comment)
                SelectCommentByComment(comment.Id, count)
            }
        }
    }
    fmt.Println(Comments)
    return &amp;Comments

}
</code></pre>

<p>ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来</p>

<h6>（2）出现问题的原因</h6>

<p>因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量</p>

<h6>（3）解决问题</h6>

<pre><code class="language-go">func ClearComments() bool {
    var comments []model.Comment
    Comments = comments
    return true
}

</code></pre>

<p>这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现</p>

<h4>这里我还加了一个小小的随机头像功能</h4>

<pre><code class="language-go">if  CommentName == user.Name &amp;&amp; CommentEmail == user.UserEmail {
        fmt.Println(&#34;进入了1&#34;)
        comment.Img =user.UserImg
        //找相同评论人
    }else if CommentName == one.CommentName &amp;&amp; CommentEmail == one.CommentEmail {
        fmt.Println(&#34;进入了2&#34;)
        comment.Img =one.Img
        //随机选头像
    }else{
        fmt.Println(&#34;进入了3&#34;)
        comment.Img =middleware.GetImg()
    }
</code></pre>

<h5>123分别代表三种不同的用户群体</h5>

<p>1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
<img src="/static/images/%e5%a4%b4%e5%83%8f1.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f2.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f3.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f4.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f5.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f6.png" alt=""/></p>

<h3>2、归档功能</h3>

<h4>blog的结构体属性如下</h4>

<pre><code class="language-go">package model

type Blog struct {
    Id           int
    Title        string    `form:&#34;title&#34; json:&#34;title&#34;`                          //标题
    Content      string    `gorm:&#34;type:longtext&#34; form:&#34;content&#34; json:&#34;content&#34;` //内容
    Image        string    `gorm:&#34;type:text&#34; form:&#34;image&#34; json:&#34;image&#34;`         //首图
    Numb         int       `form:&#34;numb&#34; json:&#34;numb&#34;`                            //次数
    Flag         string    `form:&#34;flag&#34; json:&#34;flag&#34;`                            //原创或者转载
    Appreciation string    `form:&#34;appreciation&#34; json:&#34;appreciation&#34;`            //打赏开关
    ShareInfo    string    `form:&#34;shareInfo&#34; json:&#34;shareInfo&#34;`                  //版权开关
    Comment      string    `form:&#34;comment&#34; json:&#34;comment&#34;`                      //评论开关
    Recommend    string    `form:&#34;recommend&#34; json:&#34;recommend&#34;`                  //推荐开关
    Description  string    `gorm:&#34;type:text&#34; form:&#34;description&#34; json:&#34;description&#34;`
    CreatTime    string    `form:&#34;creatTime&#34;  json:&#34;creat_time,omitempty&#34;`   //创建时间
    UpdateTime   string    `form:&#34;updateTime&#34;  json:&#34;update_time,omitempty&#34;` //更新时间
    Comments     []Comment `form:&#34;comments&#34; json:&#34;comments&#34;`
    TypeId       int       `form:&#34;typeId&#34; json:&#34;typeId&#34;`
    Type         Type      `form:&#34;type&#34; gorm:&#34;ForeignKey:TypeId&#34;`
    Year         int       `form:&#34;year&#34; json:&#34;year&#34;`
    Month        int       `form:&#34;month&#34; json:&#34;month&#34;`
    Day          int       `form:&#34;day&#34; json:&#34;day&#34;`
}

</code></pre>

<h4>实现方法</h4>

<p>我的思路是创建三个时间节点
year month day
利用sql分组查询</p>

<h5>Group By分组查询步骤</h5>

<h6>（1）先按照年份查询</h6>

<h6>（2）再按照年份遍历每个月份</h6>

<p>并将所有保存在一个切片中</p>

<h6>（3）按照月份遍历每个月的所有文章</h6>

<p>保存在一个Map中，key是对应的月份，value是每个月份的所有文章</p>

<h4>自此归档功能实现</h4>

<h2>3.已知BUG</h2>

<h3>后台退出功能</h3>

<p>后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧</p>

<p>开源地址
<a href="https://github.com/likewl/blog" title="github" rel="nofollow">github</a>
<a href="https://gitee.com/nculike/blog" title="gitee" rel="nofollow">gitee</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:09:28][0m  [36;1m[0.27ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-21 00:09:33][0m  [36;1m[0.38ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 4)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-21 00:09:33][0m  [36;1m[0.50ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=4  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-21 00:09:33][0m  [36;1m[0.48ms][0m  UPDATE `blogs` SET `title` = '本博客开源公告', `content` = '今天本博客评论功能发布
# 自今天起，本博客基本功能已经完成
## 发布V1.0版本并开源
## 博客语言说明
#### 本博客后端是用golang 的gin框架+gorm编写
前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的
#### 博客效果参考本站
#一、博客简介
## 1.博客目录

    blog
    ├────controller
	├────└───admin
	|	|	├──adminblog.go
	|	|	├───adminController.go
	|	|	├──adminTag.go
	|	|	├──adminType.go
	|	|	└──adminUser.go
	|	└──page
	|		├──404.go
	|		├───about.go
	|		├──archives.go
	|		├──blog.go
	|		├──comment.go
	|		├──pagesController.go
	|		├──researchController.go
	|		└──tagsController.go
    ├── dao
	│	├──blogs.go
	│	├──comment.go
	│	├──sql.go
	│	├──tags.go
	│	├──types.go
	│	└──user.go
    ├── logic
    │   └── user.go
    ├── middlerware
	│	├──function.go
	│	├──getImg.go
	│	├──getTime.go
	│	├──markdown.go
	│	├──select.go
	│	└──session.go
    ├── model
	│	├──blog.go
	│	├──commnent.go
	│	├──tag.go
	│	├──type.go
	│	└──user/go
    ├── static
	│	└──静态文件（头像、图片、logo、css、js等）
    ├── templates
	│	└──html模板文件
    ├── go.mod（依赖）
    └── main.go
    

## 2.相关功能实现简介
### 1、评论及回复功能
comment的结构体属性如下
```go
package model

type Comment struct {
	Id     int //评论id
	BlogId int //博文id
	ReCommentId    int    //父评论id
	CommentName string //评论人姓名
	ReCommentName  string //父评论人姓名
	CommentEmail   string
	Img            string
	CommentContent string `gorm:"type:text" form:"CommentContent" json:"CommentContent"` //评论内容
	CommentTime    string ` json:"comment_time,omitempty"`
	Parent         *Comment
	Comments       []Comment
}
```
#### 实现方法
##### 1先通过查找父评论为-1的顶级评论
父评论Id为-1说明他不是任何评论的子评论
##### 2在html上遍历所有的顶级评论
在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论
###### （1）递归存储每个顶级评论的子评论
这里我用一个切片来储存一个顶级评论的所有子评论
```go
var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
	var comments []model.Comment
	DB.Debug().Where("re_comment_id = -1 AND blog_id = ?", id).Find(&comments)
	return &comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
	if count != 0 {
		fmt.Println("if判断1")
		var comments []model.Comment
		DB.Debug().Where("re_comment_id = ?", id).Find(&comments)
		count = len(comments)
		if count != 0 {
			fmt.Println("if判断2")
			for _, comment := range comments {
				fmt.Println("for判断1")
				Comments = append(Comments, comment)
				SelectCommentByComment(comment.Id, count)
			}
		}
	}
	fmt.Println(Comments)
	return &Comments

}
```
ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来
###### （2）出现问题的原因
因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量
###### （3）解决问题
```go
func ClearComments() bool {
	var comments []model.Comment
	Comments = comments
	return true
}

```
这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现
#### 这里我还加了一个小小的随机头像功能
```go
if  CommentName == user.Name && CommentEmail == user.UserEmail {
		fmt.Println("进入了1")
		comment.Img =user.UserImg
		//找相同评论人
	}else if CommentName == one.CommentName && CommentEmail == one.CommentEmail {
		fmt.Println("进入了2")
		comment.Img =one.Img
		//随机选头像
	}else{
		fmt.Println("进入了3")
		comment.Img =middleware.GetImg()
	}
```
##### 123分别代表三种不同的用户群体
1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
![](/static/images/%e5%a4%b4%e5%83%8f1.png)![](/static/images/%e5%a4%b4%e5%83%8f2.png)![](/static/images/%e5%a4%b4%e5%83%8f3.png)![](/static/images/%e5%a4%b4%e5%83%8f4.png)![](/static/images/%e5%a4%b4%e5%83%8f5.png)![](/static/images/%e5%a4%b4%e5%83%8f6.png)
### 2、归档功能
#### blog的结构体属性如下
```go
package model

type Blog struct {
	Id           int
	Title        string    `form:"title" json:"title"`                          //标题
	Content      string    `gorm:"type:longtext" form:"content" json:"content"` //内容
	Image        string    `gorm:"type:text" form:"image" json:"image"`         //首图
	Numb         int       `form:"numb" json:"numb"`                            //次数
	Flag         string    `form:"flag" json:"flag"`                            //原创或者转载
	Appreciation string    `form:"appreciation" json:"appreciation"`            //打赏开关
	ShareInfo    string    `form:"shareInfo" json:"shareInfo"`                  //版权开关
	Comment      string    `form:"comment" json:"comment"`                      //评论开关
	Recommend    string    `form:"recommend" json:"recommend"`                  //推荐开关
	Description  string    `gorm:"type:text" form:"description" json:"description"`
	CreatTime    string    `form:"creatTime"  json:"creat_time,omitempty"`   //创建时间
	UpdateTime   string    `form:"updateTime"  json:"update_time,omitempty"` //更新时间
	Comments     []Comment `form:"comments" json:"comments"`
	TypeId       int       `form:"typeId" json:"typeId"`
	Type         Type      `form:"type" gorm:"ForeignKey:TypeId"`
	Year         int       `form:"year" json:"year"`
	Month        int       `form:"month" json:"month"`
	Day          int       `form:"day" json:"day"`
}

```
#### 实现方法
我的思路是创建三个时间节点
year month day 
利用sql分组查询
##### Group By分组查询步骤
###### （1）先按照年份查询
###### （2）再按照年份遍历每个月份
并将所有保存在一个切片中
###### （3）按照月份遍历每个月的所有文章
保存在一个Map中，key是对应的月份，value是每个月份的所有文章
#### 自此归档功能实现


## 3.已知BUG
### 后台退出功能
后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧

开源地址
[github](https://github.com/likewl/blog "github")
[gitee](https://gitee.com/nculike/blog "gitee")', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1535821573,4166447487&fm=26&gp=0.jpg', `numb` = 24, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '本博客后端是用golang 的gin框架+gorm编写', `creat_time` = '2020-07-20 15:24:23', `update_time` = '2020-07-20 15:24:23', `type_id` = 4, `year` = 2020, `month` = 7, `day` = 20  WHERE `blogs`.`id` = 4  
[36;31m[1 rows affected or returned ][0m 
<p>今天本博客评论功能发布</p>

<h1>自今天起，本博客基本功能已经完成</h1>

<h2>发布V1.0版本并开源</h2>

<h2>博客语言说明</h2>

<h4>本博客后端是用golang 的gin框架+gorm编写</h4>

<p>前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的</p>

<h4>博客效果参考本站</h4>

<p>#一、博客简介</p>

<h2>1.博客目录</h2>

<pre><code>blog
├────controller
├────└───admin
|   |   ├──adminblog.go
|   |   ├───adminController.go
|   |   ├──adminTag.go
|   |   ├──adminType.go
|   |   └──adminUser.go
|   └──page
|       ├──404.go
|       ├───about.go
|       ├──archives.go
|       ├──blog.go
|       ├──comment.go
|       ├──pagesController.go
|       ├──researchController.go
|       └──tagsController.go
├── dao
│   ├──blogs.go
│   ├──comment.go
│   ├──sql.go
│   ├──tags.go
│   ├──types.go
│   └──user.go
├── logic
│   └── user.go
├── middlerware
│   ├──function.go
│   ├──getImg.go
│   ├──getTime.go
│   ├──markdown.go
│   ├──select.go
│   └──session.go
├── model
│   ├──blog.go
│   ├──commnent.go
│   ├──tag.go
│   ├──type.go
│   └──user/go
├── static
│   └──静态文件（头像、图片、logo、css、js等）
├── templates
│   └──html模板文件
├── go.mod（依赖）
└── main.go
</code></pre>

<h2>2.相关功能实现简介</h2>

<h3>1、评论及回复功能</h3>

<p>comment的结构体属性如下</p>

<pre><code class="language-go">package model

type Comment struct {
    Id     int //评论id
    BlogId int //博文id
    ReCommentId    int    //父评论id
    CommentName string //评论人姓名
    ReCommentName  string //父评论人姓名
    CommentEmail   string
    Img            string
    CommentContent string `gorm:&#34;type:text&#34; form:&#34;CommentContent&#34; json:&#34;CommentContent&#34;` //评论内容
    CommentTime    string ` json:&#34;comment_time,omitempty&#34;`
    Parent         *Comment
    Comments       []Comment
}
</code></pre>

<h4>实现方法</h4>

<h5>1先通过查找父评论为-1的顶级评论</h5>

<p>父评论Id为-1说明他不是任何评论的子评论</p>

<h5>2在html上遍历所有的顶级评论</h5>

<p>在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论</p>

<h6>（1）递归存储每个顶级评论的子评论</h6>

<p>这里我用一个切片来储存一个顶级评论的所有子评论</p>

<pre><code class="language-go">var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
    var comments []model.Comment
    DB.Debug().Where(&#34;re_comment_id = -1 AND blog_id = ?&#34;, id).Find(&amp;comments)
    return &amp;comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
    if count != 0 {
        fmt.Println(&#34;if判断1&#34;)
        var comments []model.Comment
        DB.Debug().Where(&#34;re_comment_id = ?&#34;, id).Find(&amp;comments)
        count = len(comments)
        if count != 0 {
            fmt.Println(&#34;if判断2&#34;)
            for _, comment := range comments {
                fmt.Println(&#34;for判断1&#34;)
                Comments = append(Comments, comment)
                SelectCommentByComment(comment.Id, count)
            }
        }
    }
    fmt.Println(Comments)
    return &amp;Comments

}
</code></pre>

<p>ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来</p>

<h6>（2）出现问题的原因</h6>

<p>因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量</p>

<h6>（3）解决问题</h6>

<pre><code class="language-go">func ClearComments() bool {
    var comments []model.Comment
    Comments = comments
    return true
}

</code></pre>

<p>这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现</p>

<h4>这里我还加了一个小小的随机头像功能</h4>

<pre><code class="language-go">if  CommentName == user.Name &amp;&amp; CommentEmail == user.UserEmail {
        fmt.Println(&#34;进入了1&#34;)
        comment.Img =user.UserImg
        //找相同评论人
    }else if CommentName == one.CommentName &amp;&amp; CommentEmail == one.CommentEmail {
        fmt.Println(&#34;进入了2&#34;)
        comment.Img =one.Img
        //随机选头像
    }else{
        fmt.Println(&#34;进入了3&#34;)
        comment.Img =middleware.GetImg()
    }
</code></pre>

<h5>123分别代表三种不同的用户群体</h5>

<p>1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
<img src="/static/images/%e5%a4%b4%e5%83%8f1.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f2.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f3.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f4.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f5.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f6.png" alt=""/></p>

<h3>2、归档功能</h3>

<h4>blog的结构体属性如下</h4>

<pre><code class="language-go">package model

type Blog struct {
    Id           int
    Title        string    `form:&#34;title&#34; json:&#34;title&#34;`                          //标题
    Content      string    `gorm:&#34;type:longtext&#34; form:&#34;content&#34; json:&#34;content&#34;` //内容
    Image        string    `gorm:&#34;type:text&#34; form:&#34;image&#34; json:&#34;image&#34;`         //首图
    Numb         int       `form:&#34;numb&#34; json:&#34;numb&#34;`                            //次数
    Flag         string    `form:&#34;flag&#34; json:&#34;flag&#34;`                            //原创或者转载
    Appreciation string    `form:&#34;appreciation&#34; json:&#34;appreciation&#34;`            //打赏开关
    ShareInfo    string    `form:&#34;shareInfo&#34; json:&#34;shareInfo&#34;`                  //版权开关
    Comment      string    `form:&#34;comment&#34; json:&#34;comment&#34;`                      //评论开关
    Recommend    string    `form:&#34;recommend&#34; json:&#34;recommend&#34;`                  //推荐开关
    Description  string    `gorm:&#34;type:text&#34; form:&#34;description&#34; json:&#34;description&#34;`
    CreatTime    string    `form:&#34;creatTime&#34;  json:&#34;creat_time,omitempty&#34;`   //创建时间
    UpdateTime   string    `form:&#34;updateTime&#34;  json:&#34;update_time,omitempty&#34;` //更新时间
    Comments     []Comment `form:&#34;comments&#34; json:&#34;comments&#34;`
    TypeId       int       `form:&#34;typeId&#34; json:&#34;typeId&#34;`
    Type         Type      `form:&#34;type&#34; gorm:&#34;ForeignKey:TypeId&#34;`
    Year         int       `form:&#34;year&#34; json:&#34;year&#34;`
    Month        int       `form:&#34;month&#34; json:&#34;month&#34;`
    Day          int       `form:&#34;day&#34; json:&#34;day&#34;`
}

</code></pre>

<h4>实现方法</h4>

<p>我的思路是创建三个时间节点
year month day
利用sql分组查询</p>

<h5>Group By分组查询步骤</h5>

<h6>（1）先按照年份查询</h6>

<h6>（2）再按照年份遍历每个月份</h6>

<p>并将所有保存在一个切片中</p>

<h6>（3）按照月份遍历每个月的所有文章</h6>

<p>保存在一个Map中，key是对应的月份，value是每个月份的所有文章</p>

<h4>自此归档功能实现</h4>

<h2>3.已知BUG</h2>

<h3>后台退出功能</h3>

<p>后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧</p>

<p>开源地址
<a href="https://github.com/likewl/blog" title="github" rel="nofollow">github</a>
<a href="https://gitee.com/nculike/blog" title="gitee" rel="nofollow">gitee</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:09:33][0m  [36;1m[0.27ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-21 00:09:37][0m  [36;1m[0.37ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 4)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-21 00:09:37][0m  [36;1m[0.46ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=4  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-21 00:09:37][0m  [36;1m[0.45ms][0m  UPDATE `blogs` SET `title` = '本博客开源公告', `content` = '今天本博客评论功能发布
# 自今天起，本博客基本功能已经完成
## 发布V1.0版本并开源
## 博客语言说明
#### 本博客后端是用golang 的gin框架+gorm编写
前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的
#### 博客效果参考本站
#一、博客简介
## 1.博客目录

    blog
    ├────controller
	├────└───admin
	|	|	├──adminblog.go
	|	|	├───adminController.go
	|	|	├──adminTag.go
	|	|	├──adminType.go
	|	|	└──adminUser.go
	|	└──page
	|		├──404.go
	|		├───about.go
	|		├──archives.go
	|		├──blog.go
	|		├──comment.go
	|		├──pagesController.go
	|		├──researchController.go
	|		└──tagsController.go
    ├── dao
	│	├──blogs.go
	│	├──comment.go
	│	├──sql.go
	│	├──tags.go
	│	├──types.go
	│	└──user.go
    ├── logic
    │   └── user.go
    ├── middlerware
	│	├──function.go
	│	├──getImg.go
	│	├──getTime.go
	│	├──markdown.go
	│	├──select.go
	│	└──session.go
    ├── model
	│	├──blog.go
	│	├──commnent.go
	│	├──tag.go
	│	├──type.go
	│	└──user/go
    ├── static
	│	└──静态文件（头像、图片、logo、css、js等）
    ├── templates
	│	└──html模板文件
    ├── go.mod（依赖）
    └── main.go
    

## 2.相关功能实现简介
### 1、评论及回复功能
comment的结构体属性如下
```go
package model

type Comment struct {
	Id     int //评论id
	BlogId int //博文id
	ReCommentId    int    //父评论id
	CommentName string //评论人姓名
	ReCommentName  string //父评论人姓名
	CommentEmail   string
	Img            string
	CommentContent string `gorm:"type:text" form:"CommentContent" json:"CommentContent"` //评论内容
	CommentTime    string ` json:"comment_time,omitempty"`
	Parent         *Comment
	Comments       []Comment
}
```
#### 实现方法
##### 1先通过查找父评论为-1的顶级评论
父评论Id为-1说明他不是任何评论的子评论
##### 2在html上遍历所有的顶级评论
在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论
###### （1）递归存储每个顶级评论的子评论
这里我用一个切片来储存一个顶级评论的所有子评论
```go
var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
	var comments []model.Comment
	DB.Debug().Where("re_comment_id = -1 AND blog_id = ?", id).Find(&comments)
	return &comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
	if count != 0 {
		fmt.Println("if判断1")
		var comments []model.Comment
		DB.Debug().Where("re_comment_id = ?", id).Find(&comments)
		count = len(comments)
		if count != 0 {
			fmt.Println("if判断2")
			for _, comment := range comments {
				fmt.Println("for判断1")
				Comments = append(Comments, comment)
				SelectCommentByComment(comment.Id, count)
			}
		}
	}
	fmt.Println(Comments)
	return &Comments

}
```
ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来
###### （2）出现问题的原因
因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量
###### （3）解决问题
```go
func ClearComments() bool {
	var comments []model.Comment
	Comments = comments
	return true
}

```
这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现
#### 这里我还加了一个小小的随机头像功能
```go
if  CommentName == user.Name && CommentEmail == user.UserEmail {
		fmt.Println("进入了1")
		comment.Img =user.UserImg
		//找相同评论人
	}else if CommentName == one.CommentName && CommentEmail == one.CommentEmail {
		fmt.Println("进入了2")
		comment.Img =one.Img
		//随机选头像
	}else{
		fmt.Println("进入了3")
		comment.Img =middleware.GetImg()
	}
```
##### 123分别代表三种不同的用户群体
1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
![](/static/images/%e5%a4%b4%e5%83%8f1.png)![](/static/images/%e5%a4%b4%e5%83%8f2.png)![](/static/images/%e5%a4%b4%e5%83%8f3.png)![](/static/images/%e5%a4%b4%e5%83%8f4.png)![](/static/images/%e5%a4%b4%e5%83%8f5.png)![](/static/images/%e5%a4%b4%e5%83%8f6.png)
### 2、归档功能
#### blog的结构体属性如下
```go
package model

type Blog struct {
	Id           int
	Title        string    `form:"title" json:"title"`                          //标题
	Content      string    `gorm:"type:longtext" form:"content" json:"content"` //内容
	Image        string    `gorm:"type:text" form:"image" json:"image"`         //首图
	Numb         int       `form:"numb" json:"numb"`                            //次数
	Flag         string    `form:"flag" json:"flag"`                            //原创或者转载
	Appreciation string    `form:"appreciation" json:"appreciation"`            //打赏开关
	ShareInfo    string    `form:"shareInfo" json:"shareInfo"`                  //版权开关
	Comment      string    `form:"comment" json:"comment"`                      //评论开关
	Recommend    string    `form:"recommend" json:"recommend"`                  //推荐开关
	Description  string    `gorm:"type:text" form:"description" json:"description"`
	CreatTime    string    `form:"creatTime"  json:"creat_time,omitempty"`   //创建时间
	UpdateTime   string    `form:"updateTime"  json:"update_time,omitempty"` //更新时间
	Comments     []Comment `form:"comments" json:"comments"`
	TypeId       int       `form:"typeId" json:"typeId"`
	Type         Type      `form:"type" gorm:"ForeignKey:TypeId"`
	Year         int       `form:"year" json:"year"`
	Month        int       `form:"month" json:"month"`
	Day          int       `form:"day" json:"day"`
}

```
#### 实现方法
我的思路是创建三个时间节点
year month day 
利用sql分组查询
##### Group By分组查询步骤
###### （1）先按照年份查询
###### （2）再按照年份遍历每个月份
并将所有保存在一个切片中
###### （3）按照月份遍历每个月的所有文章
保存在一个Map中，key是对应的月份，value是每个月份的所有文章
#### 自此归档功能实现


## 3.已知BUG
### 后台退出功能
后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧

开源地址
[github](https://github.com/likewl/blog "github")
[gitee](https://gitee.com/nculike/blog "gitee")', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1535821573,4166447487&fm=26&gp=0.jpg', `numb` = 25, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '本博客后端是用golang 的gin框架+gorm编写', `creat_time` = '2020-07-20 15:24:23', `update_time` = '2020-07-20 15:24:23', `type_id` = 4, `year` = 2020, `month` = 7, `day` = 20  WHERE `blogs`.`id` = 4  
[36;31m[1 rows affected or returned ][0m 
<p>今天本博客评论功能发布</p>

<h1>自今天起，本博客基本功能已经完成</h1>

<h2>发布V1.0版本并开源</h2>

<h2>博客语言说明</h2>

<h4>本博客后端是用golang 的gin框架+gorm编写</h4>

<p>前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的</p>

<h4>博客效果参考本站</h4>

<p>#一、博客简介</p>

<h2>1.博客目录</h2>

<pre><code>blog
├────controller
├────└───admin
|   |   ├──adminblog.go
|   |   ├───adminController.go
|   |   ├──adminTag.go
|   |   ├──adminType.go
|   |   └──adminUser.go
|   └──page
|       ├──404.go
|       ├───about.go
|       ├──archives.go
|       ├──blog.go
|       ├──comment.go
|       ├──pagesController.go
|       ├──researchController.go
|       └──tagsController.go
├── dao
│   ├──blogs.go
│   ├──comment.go
│   ├──sql.go
│   ├──tags.go
│   ├──types.go
│   └──user.go
├── logic
│   └── user.go
├── middlerware
│   ├──function.go
│   ├──getImg.go
│   ├──getTime.go
│   ├──markdown.go
│   ├──select.go
│   └──session.go
├── model
│   ├──blog.go
│   ├──commnent.go
│   ├──tag.go
│   ├──type.go
│   └──user/go
├── static
│   └──静态文件（头像、图片、logo、css、js等）
├── templates
│   └──html模板文件
├── go.mod（依赖）
└── main.go
</code></pre>

<h2>2.相关功能实现简介</h2>

<h3>1、评论及回复功能</h3>

<p>comment的结构体属性如下</p>

<pre><code class="language-go">package model

type Comment struct {
    Id     int //评论id
    BlogId int //博文id
    ReCommentId    int    //父评论id
    CommentName string //评论人姓名
    ReCommentName  string //父评论人姓名
    CommentEmail   string
    Img            string
    CommentContent string `gorm:&#34;type:text&#34; form:&#34;CommentContent&#34; json:&#34;CommentContent&#34;` //评论内容
    CommentTime    string ` json:&#34;comment_time,omitempty&#34;`
    Parent         *Comment
    Comments       []Comment
}
</code></pre>

<h4>实现方法</h4>

<h5>1先通过查找父评论为-1的顶级评论</h5>

<p>父评论Id为-1说明他不是任何评论的子评论</p>

<h5>2在html上遍历所有的顶级评论</h5>

<p>在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论</p>

<h6>（1）递归存储每个顶级评论的子评论</h6>

<p>这里我用一个切片来储存一个顶级评论的所有子评论</p>

<pre><code class="language-go">var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
    var comments []model.Comment
    DB.Debug().Where(&#34;re_comment_id = -1 AND blog_id = ?&#34;, id).Find(&amp;comments)
    return &amp;comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
    if count != 0 {
        fmt.Println(&#34;if判断1&#34;)
        var comments []model.Comment
        DB.Debug().Where(&#34;re_comment_id = ?&#34;, id).Find(&amp;comments)
        count = len(comments)
        if count != 0 {
            fmt.Println(&#34;if判断2&#34;)
            for _, comment := range comments {
                fmt.Println(&#34;for判断1&#34;)
                Comments = append(Comments, comment)
                SelectCommentByComment(comment.Id, count)
            }
        }
    }
    fmt.Println(Comments)
    return &amp;Comments

}
</code></pre>

<p>ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来</p>

<h6>（2）出现问题的原因</h6>

<p>因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量</p>

<h6>（3）解决问题</h6>

<pre><code class="language-go">func ClearComments() bool {
    var comments []model.Comment
    Comments = comments
    return true
}

</code></pre>

<p>这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现</p>

<h4>这里我还加了一个小小的随机头像功能</h4>

<pre><code class="language-go">if  CommentName == user.Name &amp;&amp; CommentEmail == user.UserEmail {
        fmt.Println(&#34;进入了1&#34;)
        comment.Img =user.UserImg
        //找相同评论人
    }else if CommentName == one.CommentName &amp;&amp; CommentEmail == one.CommentEmail {
        fmt.Println(&#34;进入了2&#34;)
        comment.Img =one.Img
        //随机选头像
    }else{
        fmt.Println(&#34;进入了3&#34;)
        comment.Img =middleware.GetImg()
    }
</code></pre>

<h5>123分别代表三种不同的用户群体</h5>

<p>1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
<img src="/static/images/%e5%a4%b4%e5%83%8f1.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f2.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f3.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f4.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f5.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f6.png" alt=""/></p>

<h3>2、归档功能</h3>

<h4>blog的结构体属性如下</h4>

<pre><code class="language-go">package model

type Blog struct {
    Id           int
    Title        string    `form:&#34;title&#34; json:&#34;title&#34;`                          //标题
    Content      string    `gorm:&#34;type:longtext&#34; form:&#34;content&#34; json:&#34;content&#34;` //内容
    Image        string    `gorm:&#34;type:text&#34; form:&#34;image&#34; json:&#34;image&#34;`         //首图
    Numb         int       `form:&#34;numb&#34; json:&#34;numb&#34;`                            //次数
    Flag         string    `form:&#34;flag&#34; json:&#34;flag&#34;`                            //原创或者转载
    Appreciation string    `form:&#34;appreciation&#34; json:&#34;appreciation&#34;`            //打赏开关
    ShareInfo    string    `form:&#34;shareInfo&#34; json:&#34;shareInfo&#34;`                  //版权开关
    Comment      string    `form:&#34;comment&#34; json:&#34;comment&#34;`                      //评论开关
    Recommend    string    `form:&#34;recommend&#34; json:&#34;recommend&#34;`                  //推荐开关
    Description  string    `gorm:&#34;type:text&#34; form:&#34;description&#34; json:&#34;description&#34;`
    CreatTime    string    `form:&#34;creatTime&#34;  json:&#34;creat_time,omitempty&#34;`   //创建时间
    UpdateTime   string    `form:&#34;updateTime&#34;  json:&#34;update_time,omitempty&#34;` //更新时间
    Comments     []Comment `form:&#34;comments&#34; json:&#34;comments&#34;`
    TypeId       int       `form:&#34;typeId&#34; json:&#34;typeId&#34;`
    Type         Type      `form:&#34;type&#34; gorm:&#34;ForeignKey:TypeId&#34;`
    Year         int       `form:&#34;year&#34; json:&#34;year&#34;`
    Month        int       `form:&#34;month&#34; json:&#34;month&#34;`
    Day          int       `form:&#34;day&#34; json:&#34;day&#34;`
}

</code></pre>

<h4>实现方法</h4>

<p>我的思路是创建三个时间节点
year month day
利用sql分组查询</p>

<h5>Group By分组查询步骤</h5>

<h6>（1）先按照年份查询</h6>

<h6>（2）再按照年份遍历每个月份</h6>

<p>并将所有保存在一个切片中</p>

<h6>（3）按照月份遍历每个月的所有文章</h6>

<p>保存在一个Map中，key是对应的月份，value是每个月份的所有文章</p>

<h4>自此归档功能实现</h4>

<h2>3.已知BUG</h2>

<h3>后台退出功能</h3>

<p>后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧</p>

<p>开源地址
<a href="https://github.com/likewl/blog" title="github" rel="nofollow">github</a>
<a href="https://gitee.com/nculike/blog" title="gitee" rel="nofollow">gitee</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:09:37][0m  [36;1m[0.27ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-21 00:09:43][0m  [36;1m[0.35ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 4)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-21 00:09:43][0m  [36;1m[0.46ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=4  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-21 00:09:43][0m  [36;1m[0.43ms][0m  UPDATE `blogs` SET `title` = '本博客开源公告', `content` = '今天本博客评论功能发布
# 自今天起，本博客基本功能已经完成
## 发布V1.0版本并开源
## 博客语言说明
#### 本博客后端是用golang 的gin框架+gorm编写
前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的
#### 博客效果参考本站
#一、博客简介
## 1.博客目录

    blog
    ├────controller
	├────└───admin
	|	|	├──adminblog.go
	|	|	├───adminController.go
	|	|	├──adminTag.go
	|	|	├──adminType.go
	|	|	└──adminUser.go
	|	└──page
	|		├──404.go
	|		├───about.go
	|		├──archives.go
	|		├──blog.go
	|		├──comment.go
	|		├──pagesController.go
	|		├──researchController.go
	|		└──tagsController.go
    ├── dao
	│	├──blogs.go
	│	├──comment.go
	│	├──sql.go
	│	├──tags.go
	│	├──types.go
	│	└──user.go
    ├── logic
    │   └── user.go
    ├── middlerware
	│	├──function.go
	│	├──getImg.go
	│	├──getTime.go
	│	├──markdown.go
	│	├──select.go
	│	└──session.go
    ├── model
	│	├──blog.go
	│	├──commnent.go
	│	├──tag.go
	│	├──type.go
	│	└──user/go
    ├── static
	│	└──静态文件（头像、图片、logo、css、js等）
    ├── templates
	│	└──html模板文件
    ├── go.mod（依赖）
    └── main.go
    

## 2.相关功能实现简介
### 1、评论及回复功能
comment的结构体属性如下
```go
package model

type Comment struct {
	Id     int //评论id
	BlogId int //博文id
	ReCommentId    int    //父评论id
	CommentName string //评论人姓名
	ReCommentName  string //父评论人姓名
	CommentEmail   string
	Img            string
	CommentContent string `gorm:"type:text" form:"CommentContent" json:"CommentContent"` //评论内容
	CommentTime    string ` json:"comment_time,omitempty"`
	Parent         *Comment
	Comments       []Comment
}
```
#### 实现方法
##### 1先通过查找父评论为-1的顶级评论
父评论Id为-1说明他不是任何评论的子评论
##### 2在html上遍历所有的顶级评论
在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论
###### （1）递归存储每个顶级评论的子评论
这里我用一个切片来储存一个顶级评论的所有子评论
```go
var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
	var comments []model.Comment
	DB.Debug().Where("re_comment_id = -1 AND blog_id = ?", id).Find(&comments)
	return &comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
	if count != 0 {
		fmt.Println("if判断1")
		var comments []model.Comment
		DB.Debug().Where("re_comment_id = ?", id).Find(&comments)
		count = len(comments)
		if count != 0 {
			fmt.Println("if判断2")
			for _, comment := range comments {
				fmt.Println("for判断1")
				Comments = append(Comments, comment)
				SelectCommentByComment(comment.Id, count)
			}
		}
	}
	fmt.Println(Comments)
	return &Comments

}
```
ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来
###### （2）出现问题的原因
因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量
###### （3）解决问题
```go
func ClearComments() bool {
	var comments []model.Comment
	Comments = comments
	return true
}

```
这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现
#### 这里我还加了一个小小的随机头像功能
```go
if  CommentName == user.Name && CommentEmail == user.UserEmail {
		fmt.Println("进入了1")
		comment.Img =user.UserImg
		//找相同评论人
	}else if CommentName == one.CommentName && CommentEmail == one.CommentEmail {
		fmt.Println("进入了2")
		comment.Img =one.Img
		//随机选头像
	}else{
		fmt.Println("进入了3")
		comment.Img =middleware.GetImg()
	}
```
##### 123分别代表三种不同的用户群体
1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
![](/static/images/%e5%a4%b4%e5%83%8f1.png)![](/static/images/%e5%a4%b4%e5%83%8f2.png)![](/static/images/%e5%a4%b4%e5%83%8f3.png)![](/static/images/%e5%a4%b4%e5%83%8f4.png)![](/static/images/%e5%a4%b4%e5%83%8f5.png)![](/static/images/%e5%a4%b4%e5%83%8f6.png)
### 2、归档功能
#### blog的结构体属性如下
```go
package model

type Blog struct {
	Id           int
	Title        string    `form:"title" json:"title"`                          //标题
	Content      string    `gorm:"type:longtext" form:"content" json:"content"` //内容
	Image        string    `gorm:"type:text" form:"image" json:"image"`         //首图
	Numb         int       `form:"numb" json:"numb"`                            //次数
	Flag         string    `form:"flag" json:"flag"`                            //原创或者转载
	Appreciation string    `form:"appreciation" json:"appreciation"`            //打赏开关
	ShareInfo    string    `form:"shareInfo" json:"shareInfo"`                  //版权开关
	Comment      string    `form:"comment" json:"comment"`                      //评论开关
	Recommend    string    `form:"recommend" json:"recommend"`                  //推荐开关
	Description  string    `gorm:"type:text" form:"description" json:"description"`
	CreatTime    string    `form:"creatTime"  json:"creat_time,omitempty"`   //创建时间
	UpdateTime   string    `form:"updateTime"  json:"update_time,omitempty"` //更新时间
	Comments     []Comment `form:"comments" json:"comments"`
	TypeId       int       `form:"typeId" json:"typeId"`
	Type         Type      `form:"type" gorm:"ForeignKey:TypeId"`
	Year         int       `form:"year" json:"year"`
	Month        int       `form:"month" json:"month"`
	Day          int       `form:"day" json:"day"`
}

```
#### 实现方法
我的思路是创建三个时间节点
year month day 
利用sql分组查询
##### Group By分组查询步骤
###### （1）先按照年份查询
###### （2）再按照年份遍历每个月份
并将所有保存在一个切片中
###### （3）按照月份遍历每个月的所有文章
保存在一个Map中，key是对应的月份，value是每个月份的所有文章
#### 自此归档功能实现


## 3.已知BUG
### 后台退出功能
后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧

开源地址
[github](https://github.com/likewl/blog "github")
[gitee](https://gitee.com/nculike/blog "gitee")', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1535821573,4166447487&fm=26&gp=0.jpg', `numb` = 26, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '本博客后端是用golang 的gin框架+gorm编写', `creat_time` = '2020-07-20 15:24:23', `update_time` = '2020-07-20 15:24:23', `type_id` = 4, `year` = 2020, `month` = 7, `day` = 20  WHERE `blogs`.`id` = 4  
[36;31m[1 rows affected or returned ][0m 
<p>今天本博客评论功能发布</p>

<h1>自今天起，本博客基本功能已经完成</h1>

<h2>发布V1.0版本并开源</h2>

<h2>博客语言说明</h2>

<h4>本博客后端是用golang 的gin框架+gorm编写</h4>

<p>前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的</p>

<h4>博客效果参考本站</h4>

<p>#一、博客简介</p>

<h2>1.博客目录</h2>

<pre><code>blog
├────controller
├────└───admin
|   |   ├──adminblog.go
|   |   ├───adminController.go
|   |   ├──adminTag.go
|   |   ├──adminType.go
|   |   └──adminUser.go
|   └──page
|       ├──404.go
|       ├───about.go
|       ├──archives.go
|       ├──blog.go
|       ├──comment.go
|       ├──pagesController.go
|       ├──researchController.go
|       └──tagsController.go
├── dao
│   ├──blogs.go
│   ├──comment.go
│   ├──sql.go
│   ├──tags.go
│   ├──types.go
│   └──user.go
├── logic
│   └── user.go
├── middlerware
│   ├──function.go
│   ├──getImg.go
│   ├──getTime.go
│   ├──markdown.go
│   ├──select.go
│   └──session.go
├── model
│   ├──blog.go
│   ├──commnent.go
│   ├──tag.go
│   ├──type.go
│   └──user/go
├── static
│   └──静态文件（头像、图片、logo、css、js等）
├── templates
│   └──html模板文件
├── go.mod（依赖）
└── main.go
</code></pre>

<h2>2.相关功能实现简介</h2>

<h3>1、评论及回复功能</h3>

<p>comment的结构体属性如下</p>

<pre><code class="language-go">package model

type Comment struct {
    Id     int //评论id
    BlogId int //博文id
    ReCommentId    int    //父评论id
    CommentName string //评论人姓名
    ReCommentName  string //父评论人姓名
    CommentEmail   string
    Img            string
    CommentContent string `gorm:&#34;type:text&#34; form:&#34;CommentContent&#34; json:&#34;CommentContent&#34;` //评论内容
    CommentTime    string ` json:&#34;comment_time,omitempty&#34;`
    Parent         *Comment
    Comments       []Comment
}
</code></pre>

<h4>实现方法</h4>

<h5>1先通过查找父评论为-1的顶级评论</h5>

<p>父评论Id为-1说明他不是任何评论的子评论</p>

<h5>2在html上遍历所有的顶级评论</h5>

<p>在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论</p>

<h6>（1）递归存储每个顶级评论的子评论</h6>

<p>这里我用一个切片来储存一个顶级评论的所有子评论</p>

<pre><code class="language-go">var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
    var comments []model.Comment
    DB.Debug().Where(&#34;re_comment_id = -1 AND blog_id = ?&#34;, id).Find(&amp;comments)
    return &amp;comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
    if count != 0 {
        fmt.Println(&#34;if判断1&#34;)
        var comments []model.Comment
        DB.Debug().Where(&#34;re_comment_id = ?&#34;, id).Find(&amp;comments)
        count = len(comments)
        if count != 0 {
            fmt.Println(&#34;if判断2&#34;)
            for _, comment := range comments {
                fmt.Println(&#34;for判断1&#34;)
                Comments = append(Comments, comment)
                SelectCommentByComment(comment.Id, count)
            }
        }
    }
    fmt.Println(Comments)
    return &amp;Comments

}
</code></pre>

<p>ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来</p>

<h6>（2）出现问题的原因</h6>

<p>因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量</p>

<h6>（3）解决问题</h6>

<pre><code class="language-go">func ClearComments() bool {
    var comments []model.Comment
    Comments = comments
    return true
}

</code></pre>

<p>这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现</p>

<h4>这里我还加了一个小小的随机头像功能</h4>

<pre><code class="language-go">if  CommentName == user.Name &amp;&amp; CommentEmail == user.UserEmail {
        fmt.Println(&#34;进入了1&#34;)
        comment.Img =user.UserImg
        //找相同评论人
    }else if CommentName == one.CommentName &amp;&amp; CommentEmail == one.CommentEmail {
        fmt.Println(&#34;进入了2&#34;)
        comment.Img =one.Img
        //随机选头像
    }else{
        fmt.Println(&#34;进入了3&#34;)
        comment.Img =middleware.GetImg()
    }
</code></pre>

<h5>123分别代表三种不同的用户群体</h5>

<p>1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
<img src="/static/images/%e5%a4%b4%e5%83%8f1.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f2.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f3.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f4.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f5.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f6.png" alt=""/></p>

<h3>2、归档功能</h3>

<h4>blog的结构体属性如下</h4>

<pre><code class="language-go">package model

type Blog struct {
    Id           int
    Title        string    `form:&#34;title&#34; json:&#34;title&#34;`                          //标题
    Content      string    `gorm:&#34;type:longtext&#34; form:&#34;content&#34; json:&#34;content&#34;` //内容
    Image        string    `gorm:&#34;type:text&#34; form:&#34;image&#34; json:&#34;image&#34;`         //首图
    Numb         int       `form:&#34;numb&#34; json:&#34;numb&#34;`                            //次数
    Flag         string    `form:&#34;flag&#34; json:&#34;flag&#34;`                            //原创或者转载
    Appreciation string    `form:&#34;appreciation&#34; json:&#34;appreciation&#34;`            //打赏开关
    ShareInfo    string    `form:&#34;shareInfo&#34; json:&#34;shareInfo&#34;`                  //版权开关
    Comment      string    `form:&#34;comment&#34; json:&#34;comment&#34;`                      //评论开关
    Recommend    string    `form:&#34;recommend&#34; json:&#34;recommend&#34;`                  //推荐开关
    Description  string    `gorm:&#34;type:text&#34; form:&#34;description&#34; json:&#34;description&#34;`
    CreatTime    string    `form:&#34;creatTime&#34;  json:&#34;creat_time,omitempty&#34;`   //创建时间
    UpdateTime   string    `form:&#34;updateTime&#34;  json:&#34;update_time,omitempty&#34;` //更新时间
    Comments     []Comment `form:&#34;comments&#34; json:&#34;comments&#34;`
    TypeId       int       `form:&#34;typeId&#34; json:&#34;typeId&#34;`
    Type         Type      `form:&#34;type&#34; gorm:&#34;ForeignKey:TypeId&#34;`
    Year         int       `form:&#34;year&#34; json:&#34;year&#34;`
    Month        int       `form:&#34;month&#34; json:&#34;month&#34;`
    Day          int       `form:&#34;day&#34; json:&#34;day&#34;`
}

</code></pre>

<h4>实现方法</h4>

<p>我的思路是创建三个时间节点
year month day
利用sql分组查询</p>

<h5>Group By分组查询步骤</h5>

<h6>（1）先按照年份查询</h6>

<h6>（2）再按照年份遍历每个月份</h6>

<p>并将所有保存在一个切片中</p>

<h6>（3）按照月份遍历每个月的所有文章</h6>

<p>保存在一个Map中，key是对应的月份，value是每个月份的所有文章</p>

<h4>自此归档功能实现</h4>

<h2>3.已知BUG</h2>

<h3>后台退出功能</h3>

<p>后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧</p>

<p>开源地址
<a href="https://github.com/likewl/blog" title="github" rel="nofollow">github</a>
<a href="https://gitee.com/nculike/blog" title="gitee" rel="nofollow">gitee</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:09:43][0m  [36;1m[0.29ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-21 00:09:46][0m  [36;1m[0.40ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 4)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-21 00:09:46][0m  [36;1m[0.44ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=4  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-21 00:09:46][0m  [36;1m[0.45ms][0m  UPDATE `blogs` SET `title` = '本博客开源公告', `content` = '今天本博客评论功能发布
# 自今天起，本博客基本功能已经完成
## 发布V1.0版本并开源
## 博客语言说明
#### 本博客后端是用golang 的gin框架+gorm编写
前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的
#### 博客效果参考本站
#一、博客简介
## 1.博客目录

    blog
    ├────controller
	├────└───admin
	|	|	├──adminblog.go
	|	|	├───adminController.go
	|	|	├──adminTag.go
	|	|	├──adminType.go
	|	|	└──adminUser.go
	|	└──page
	|		├──404.go
	|		├───about.go
	|		├──archives.go
	|		├──blog.go
	|		├──comment.go
	|		├──pagesController.go
	|		├──researchController.go
	|		└──tagsController.go
    ├── dao
	│	├──blogs.go
	│	├──comment.go
	│	├──sql.go
	│	├──tags.go
	│	├──types.go
	│	└──user.go
    ├── logic
    │   └── user.go
    ├── middlerware
	│	├──function.go
	│	├──getImg.go
	│	├──getTime.go
	│	├──markdown.go
	│	├──select.go
	│	└──session.go
    ├── model
	│	├──blog.go
	│	├──commnent.go
	│	├──tag.go
	│	├──type.go
	│	└──user/go
    ├── static
	│	└──静态文件（头像、图片、logo、css、js等）
    ├── templates
	│	└──html模板文件
    ├── go.mod（依赖）
    └── main.go
    

## 2.相关功能实现简介
### 1、评论及回复功能
comment的结构体属性如下
```go
package model

type Comment struct {
	Id     int //评论id
	BlogId int //博文id
	ReCommentId    int    //父评论id
	CommentName string //评论人姓名
	ReCommentName  string //父评论人姓名
	CommentEmail   string
	Img            string
	CommentContent string `gorm:"type:text" form:"CommentContent" json:"CommentContent"` //评论内容
	CommentTime    string ` json:"comment_time,omitempty"`
	Parent         *Comment
	Comments       []Comment
}
```
#### 实现方法
##### 1先通过查找父评论为-1的顶级评论
父评论Id为-1说明他不是任何评论的子评论
##### 2在html上遍历所有的顶级评论
在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论
###### （1）递归存储每个顶级评论的子评论
这里我用一个切片来储存一个顶级评论的所有子评论
```go
var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
	var comments []model.Comment
	DB.Debug().Where("re_comment_id = -1 AND blog_id = ?", id).Find(&comments)
	return &comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
	if count != 0 {
		fmt.Println("if判断1")
		var comments []model.Comment
		DB.Debug().Where("re_comment_id = ?", id).Find(&comments)
		count = len(comments)
		if count != 0 {
			fmt.Println("if判断2")
			for _, comment := range comments {
				fmt.Println("for判断1")
				Comments = append(Comments, comment)
				SelectCommentByComment(comment.Id, count)
			}
		}
	}
	fmt.Println(Comments)
	return &Comments

}
```
ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来
###### （2）出现问题的原因
因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量
###### （3）解决问题
```go
func ClearComments() bool {
	var comments []model.Comment
	Comments = comments
	return true
}

```
这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现
#### 这里我还加了一个小小的随机头像功能
```go
if  CommentName == user.Name && CommentEmail == user.UserEmail {
		fmt.Println("进入了1")
		comment.Img =user.UserImg
		//找相同评论人
	}else if CommentName == one.CommentName && CommentEmail == one.CommentEmail {
		fmt.Println("进入了2")
		comment.Img =one.Img
		//随机选头像
	}else{
		fmt.Println("进入了3")
		comment.Img =middleware.GetImg()
	}
```
##### 123分别代表三种不同的用户群体
1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
![](/static/images/%e5%a4%b4%e5%83%8f1.png)![](/static/images/%e5%a4%b4%e5%83%8f2.png)![](/static/images/%e5%a4%b4%e5%83%8f3.png)![](/static/images/%e5%a4%b4%e5%83%8f4.png)![](/static/images/%e5%a4%b4%e5%83%8f5.png)![](/static/images/%e5%a4%b4%e5%83%8f6.png)
### 2、归档功能
#### blog的结构体属性如下
```go
package model

type Blog struct {
	Id           int
	Title        string    `form:"title" json:"title"`                          //标题
	Content      string    `gorm:"type:longtext" form:"content" json:"content"` //内容
	Image        string    `gorm:"type:text" form:"image" json:"image"`         //首图
	Numb         int       `form:"numb" json:"numb"`                            //次数
	Flag         string    `form:"flag" json:"flag"`                            //原创或者转载
	Appreciation string    `form:"appreciation" json:"appreciation"`            //打赏开关
	ShareInfo    string    `form:"shareInfo" json:"shareInfo"`                  //版权开关
	Comment      string    `form:"comment" json:"comment"`                      //评论开关
	Recommend    string    `form:"recommend" json:"recommend"`                  //推荐开关
	Description  string    `gorm:"type:text" form:"description" json:"description"`
	CreatTime    string    `form:"creatTime"  json:"creat_time,omitempty"`   //创建时间
	UpdateTime   string    `form:"updateTime"  json:"update_time,omitempty"` //更新时间
	Comments     []Comment `form:"comments" json:"comments"`
	TypeId       int       `form:"typeId" json:"typeId"`
	Type         Type      `form:"type" gorm:"ForeignKey:TypeId"`
	Year         int       `form:"year" json:"year"`
	Month        int       `form:"month" json:"month"`
	Day          int       `form:"day" json:"day"`
}

```
#### 实现方法
我的思路是创建三个时间节点
year month day 
利用sql分组查询
##### Group By分组查询步骤
###### （1）先按照年份查询
###### （2）再按照年份遍历每个月份
并将所有保存在一个切片中
###### （3）按照月份遍历每个月的所有文章
保存在一个Map中，key是对应的月份，value是每个月份的所有文章
#### 自此归档功能实现


## 3.已知BUG
### 后台退出功能
后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧

开源地址
[github](https://github.com/likewl/blog "github")
[gitee](https://gitee.com/nculike/blog "gitee")', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1535821573,4166447487&fm=26&gp=0.jpg', `numb` = 27, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '本博客后端是用golang 的gin框架+gorm编写', `creat_time` = '2020-07-20 15:24:23', `update_time` = '2020-07-20 15:24:23', `type_id` = 4, `year` = 2020, `month` = 7, `day` = 20  WHERE `blogs`.`id` = 4  
[36;31m[1 rows affected or returned ][0m 
<p>今天本博客评论功能发布</p>

<h1>自今天起，本博客基本功能已经完成</h1>

<h2>发布V1.0版本并开源</h2>

<h2>博客语言说明</h2>

<h4>本博客后端是用golang 的gin框架+gorm编写</h4>

<p>前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的</p>

<h4>博客效果参考本站</h4>

<p>#一、博客简介</p>

<h2>1.博客目录</h2>

<pre><code>blog
├────controller
├────└───admin
|   |   ├──adminblog.go
|   |   ├───adminController.go
|   |   ├──adminTag.go
|   |   ├──adminType.go
|   |   └──adminUser.go
|   └──page
|       ├──404.go
|       ├───about.go
|       ├──archives.go
|       ├──blog.go
|       ├──comment.go
|       ├──pagesController.go
|       ├──researchController.go
|       └──tagsController.go
├── dao
│   ├──blogs.go
│   ├──comment.go
│   ├──sql.go
│   ├──tags.go
│   ├──types.go
│   └──user.go
├── logic
│   └── user.go
├── middlerware
│   ├──function.go
│   ├──getImg.go
│   ├──getTime.go
│   ├──markdown.go
│   ├──select.go
│   └──session.go
├── model
│   ├──blog.go
│   ├──commnent.go
│   ├──tag.go
│   ├──type.go
│   └──user/go
├── static
│   └──静态文件（头像、图片、logo、css、js等）
├── templates
│   └──html模板文件
├── go.mod（依赖）
└── main.go
</code></pre>

<h2>2.相关功能实现简介</h2>

<h3>1、评论及回复功能</h3>

<p>comment的结构体属性如下</p>

<pre><code class="language-go">package model

type Comment struct {
    Id     int //评论id
    BlogId int //博文id
    ReCommentId    int    //父评论id
    CommentName string //评论人姓名
    ReCommentName  string //父评论人姓名
    CommentEmail   string
    Img            string
    CommentContent string `gorm:&#34;type:text&#34; form:&#34;CommentContent&#34; json:&#34;CommentContent&#34;` //评论内容
    CommentTime    string ` json:&#34;comment_time,omitempty&#34;`
    Parent         *Comment
    Comments       []Comment
}
</code></pre>

<h4>实现方法</h4>

<h5>1先通过查找父评论为-1的顶级评论</h5>

<p>父评论Id为-1说明他不是任何评论的子评论</p>

<h5>2在html上遍历所有的顶级评论</h5>

<p>在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论</p>

<h6>（1）递归存储每个顶级评论的子评论</h6>

<p>这里我用一个切片来储存一个顶级评论的所有子评论</p>

<pre><code class="language-go">var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
    var comments []model.Comment
    DB.Debug().Where(&#34;re_comment_id = -1 AND blog_id = ?&#34;, id).Find(&amp;comments)
    return &amp;comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
    if count != 0 {
        fmt.Println(&#34;if判断1&#34;)
        var comments []model.Comment
        DB.Debug().Where(&#34;re_comment_id = ?&#34;, id).Find(&amp;comments)
        count = len(comments)
        if count != 0 {
            fmt.Println(&#34;if判断2&#34;)
            for _, comment := range comments {
                fmt.Println(&#34;for判断1&#34;)
                Comments = append(Comments, comment)
                SelectCommentByComment(comment.Id, count)
            }
        }
    }
    fmt.Println(Comments)
    return &amp;Comments

}
</code></pre>

<p>ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来</p>

<h6>（2）出现问题的原因</h6>

<p>因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量</p>

<h6>（3）解决问题</h6>

<pre><code class="language-go">func ClearComments() bool {
    var comments []model.Comment
    Comments = comments
    return true
}

</code></pre>

<p>这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现</p>

<h4>这里我还加了一个小小的随机头像功能</h4>

<pre><code class="language-go">if  CommentName == user.Name &amp;&amp; CommentEmail == user.UserEmail {
        fmt.Println(&#34;进入了1&#34;)
        comment.Img =user.UserImg
        //找相同评论人
    }else if CommentName == one.CommentName &amp;&amp; CommentEmail == one.CommentEmail {
        fmt.Println(&#34;进入了2&#34;)
        comment.Img =one.Img
        //随机选头像
    }else{
        fmt.Println(&#34;进入了3&#34;)
        comment.Img =middleware.GetImg()
    }
</code></pre>

<h5>123分别代表三种不同的用户群体</h5>

<p>1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
<img src="/static/images/%e5%a4%b4%e5%83%8f1.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f2.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f3.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f4.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f5.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f6.png" alt=""/></p>

<h3>2、归档功能</h3>

<h4>blog的结构体属性如下</h4>

<pre><code class="language-go">package model

type Blog struct {
    Id           int
    Title        string    `form:&#34;title&#34; json:&#34;title&#34;`                          //标题
    Content      string    `gorm:&#34;type:longtext&#34; form:&#34;content&#34; json:&#34;content&#34;` //内容
    Image        string    `gorm:&#34;type:text&#34; form:&#34;image&#34; json:&#34;image&#34;`         //首图
    Numb         int       `form:&#34;numb&#34; json:&#34;numb&#34;`                            //次数
    Flag         string    `form:&#34;flag&#34; json:&#34;flag&#34;`                            //原创或者转载
    Appreciation string    `form:&#34;appreciation&#34; json:&#34;appreciation&#34;`            //打赏开关
    ShareInfo    string    `form:&#34;shareInfo&#34; json:&#34;shareInfo&#34;`                  //版权开关
    Comment      string    `form:&#34;comment&#34; json:&#34;comment&#34;`                      //评论开关
    Recommend    string    `form:&#34;recommend&#34; json:&#34;recommend&#34;`                  //推荐开关
    Description  string    `gorm:&#34;type:text&#34; form:&#34;description&#34; json:&#34;description&#34;`
    CreatTime    string    `form:&#34;creatTime&#34;  json:&#34;creat_time,omitempty&#34;`   //创建时间
    UpdateTime   string    `form:&#34;updateTime&#34;  json:&#34;update_time,omitempty&#34;` //更新时间
    Comments     []Comment `form:&#34;comments&#34; json:&#34;comments&#34;`
    TypeId       int       `form:&#34;typeId&#34; json:&#34;typeId&#34;`
    Type         Type      `form:&#34;type&#34; gorm:&#34;ForeignKey:TypeId&#34;`
    Year         int       `form:&#34;year&#34; json:&#34;year&#34;`
    Month        int       `form:&#34;month&#34; json:&#34;month&#34;`
    Day          int       `form:&#34;day&#34; json:&#34;day&#34;`
}

</code></pre>

<h4>实现方法</h4>

<p>我的思路是创建三个时间节点
year month day
利用sql分组查询</p>

<h5>Group By分组查询步骤</h5>

<h6>（1）先按照年份查询</h6>

<h6>（2）再按照年份遍历每个月份</h6>

<p>并将所有保存在一个切片中</p>

<h6>（3）按照月份遍历每个月的所有文章</h6>

<p>保存在一个Map中，key是对应的月份，value是每个月份的所有文章</p>

<h4>自此归档功能实现</h4>

<h2>3.已知BUG</h2>

<h3>后台退出功能</h3>

<p>后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧</p>

<p>开源地址
<a href="https://github.com/likewl/blog" title="github" rel="nofollow">github</a>
<a href="https://gitee.com/nculike/blog" title="gitee" rel="nofollow">gitee</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:09:46][0m  [36;1m[0.30ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-21 00:09:51][0m  [36;1m[0.60ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:09:51][0m  [36;1m[0.27ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 00:09:51][0m  [36;1m[0.78ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-21 00:09:51][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-21 00:09:53][0m  [36;1m[0.45ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 4)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-21 00:09:53][0m  [36;1m[0.51ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=4  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-21 00:09:53][0m  [36;1m[0.50ms][0m  UPDATE `blogs` SET `title` = '本博客开源公告', `content` = '今天本博客评论功能发布
# 自今天起，本博客基本功能已经完成
## 发布V1.0版本并开源
## 博客语言说明
#### 本博客后端是用golang 的gin框架+gorm编写
前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的
#### 博客效果参考本站
#一、博客简介
## 1.博客目录

    blog
    ├────controller
	├────└───admin
	|	|	├──adminblog.go
	|	|	├───adminController.go
	|	|	├──adminTag.go
	|	|	├──adminType.go
	|	|	└──adminUser.go
	|	└──page
	|		├──404.go
	|		├───about.go
	|		├──archives.go
	|		├──blog.go
	|		├──comment.go
	|		├──pagesController.go
	|		├──researchController.go
	|		└──tagsController.go
    ├── dao
	│	├──blogs.go
	│	├──comment.go
	│	├──sql.go
	│	├──tags.go
	│	├──types.go
	│	└──user.go
    ├── logic
    │   └── user.go
    ├── middlerware
	│	├──function.go
	│	├──getImg.go
	│	├──getTime.go
	│	├──markdown.go
	│	├──select.go
	│	└──session.go
    ├── model
	│	├──blog.go
	│	├──commnent.go
	│	├──tag.go
	│	├──type.go
	│	└──user/go
    ├── static
	│	└──静态文件（头像、图片、logo、css、js等）
    ├── templates
	│	└──html模板文件
    ├── go.mod（依赖）
    └── main.go
    

## 2.相关功能实现简介
### 1、评论及回复功能
comment的结构体属性如下
```go
package model

type Comment struct {
	Id     int //评论id
	BlogId int //博文id
	ReCommentId    int    //父评论id
	CommentName string //评论人姓名
	ReCommentName  string //父评论人姓名
	CommentEmail   string
	Img            string
	CommentContent string `gorm:"type:text" form:"CommentContent" json:"CommentContent"` //评论内容
	CommentTime    string ` json:"comment_time,omitempty"`
	Parent         *Comment
	Comments       []Comment
}
```
#### 实现方法
##### 1先通过查找父评论为-1的顶级评论
父评论Id为-1说明他不是任何评论的子评论
##### 2在html上遍历所有的顶级评论
在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论
###### （1）递归存储每个顶级评论的子评论
这里我用一个切片来储存一个顶级评论的所有子评论
```go
var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
	var comments []model.Comment
	DB.Debug().Where("re_comment_id = -1 AND blog_id = ?", id).Find(&comments)
	return &comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
	if count != 0 {
		fmt.Println("if判断1")
		var comments []model.Comment
		DB.Debug().Where("re_comment_id = ?", id).Find(&comments)
		count = len(comments)
		if count != 0 {
			fmt.Println("if判断2")
			for _, comment := range comments {
				fmt.Println("for判断1")
				Comments = append(Comments, comment)
				SelectCommentByComment(comment.Id, count)
			}
		}
	}
	fmt.Println(Comments)
	return &Comments

}
```
ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来
###### （2）出现问题的原因
因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量
###### （3）解决问题
```go
func ClearComments() bool {
	var comments []model.Comment
	Comments = comments
	return true
}

```
这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现
#### 这里我还加了一个小小的随机头像功能
```go
if  CommentName == user.Name && CommentEmail == user.UserEmail {
		fmt.Println("进入了1")
		comment.Img =user.UserImg
		//找相同评论人
	}else if CommentName == one.CommentName && CommentEmail == one.CommentEmail {
		fmt.Println("进入了2")
		comment.Img =one.Img
		//随机选头像
	}else{
		fmt.Println("进入了3")
		comment.Img =middleware.GetImg()
	}
```
##### 123分别代表三种不同的用户群体
1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
![](/static/images/%e5%a4%b4%e5%83%8f1.png)![](/static/images/%e5%a4%b4%e5%83%8f2.png)![](/static/images/%e5%a4%b4%e5%83%8f3.png)![](/static/images/%e5%a4%b4%e5%83%8f4.png)![](/static/images/%e5%a4%b4%e5%83%8f5.png)![](/static/images/%e5%a4%b4%e5%83%8f6.png)
### 2、归档功能
#### blog的结构体属性如下
```go
package model

type Blog struct {
	Id           int
	Title        string    `form:"title" json:"title"`                          //标题
	Content      string    `gorm:"type:longtext" form:"content" json:"content"` //内容
	Image        string    `gorm:"type:text" form:"image" json:"image"`         //首图
	Numb         int       `form:"numb" json:"numb"`                            //次数
	Flag         string    `form:"flag" json:"flag"`                            //原创或者转载
	Appreciation string    `form:"appreciation" json:"appreciation"`            //打赏开关
	ShareInfo    string    `form:"shareInfo" json:"shareInfo"`                  //版权开关
	Comment      string    `form:"comment" json:"comment"`                      //评论开关
	Recommend    string    `form:"recommend" json:"recommend"`                  //推荐开关
	Description  string    `gorm:"type:text" form:"description" json:"description"`
	CreatTime    string    `form:"creatTime"  json:"creat_time,omitempty"`   //创建时间
	UpdateTime   string    `form:"updateTime"  json:"update_time,omitempty"` //更新时间
	Comments     []Comment `form:"comments" json:"comments"`
	TypeId       int       `form:"typeId" json:"typeId"`
	Type         Type      `form:"type" gorm:"ForeignKey:TypeId"`
	Year         int       `form:"year" json:"year"`
	Month        int       `form:"month" json:"month"`
	Day          int       `form:"day" json:"day"`
}

```
#### 实现方法
我的思路是创建三个时间节点
year month day 
利用sql分组查询
##### Group By分组查询步骤
###### （1）先按照年份查询
###### （2）再按照年份遍历每个月份
并将所有保存在一个切片中
###### （3）按照月份遍历每个月的所有文章
保存在一个Map中，key是对应的月份，value是每个月份的所有文章
#### 自此归档功能实现


## 3.已知BUG
### 后台退出功能
后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧

开源地址
[github](https://github.com/likewl/blog "github")
[gitee](https://gitee.com/nculike/blog "gitee")', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1535821573,4166447487&fm=26&gp=0.jpg', `numb` = 28, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '本博客后端是用golang 的gin框架+gorm编写', `creat_time` = '2020-07-20 15:24:23', `update_time` = '2020-07-20 15:24:23', `type_id` = 4, `year` = 2020, `month` = 7, `day` = 20  WHERE `blogs`.`id` = 4  
[36;31m[1 rows affected or returned ][0m 
<p>今天本博客评论功能发布</p>

<h1>自今天起，本博客基本功能已经完成</h1>

<h2>发布V1.0版本并开源</h2>

<h2>博客语言说明</h2>

<h4>本博客后端是用golang 的gin框架+gorm编写</h4>

<p>前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的</p>

<h4>博客效果参考本站</h4>

<p>#一、博客简介</p>

<h2>1.博客目录</h2>

<pre><code>blog
├────controller
├────└───admin
|   |   ├──adminblog.go
|   |   ├───adminController.go
|   |   ├──adminTag.go
|   |   ├──adminType.go
|   |   └──adminUser.go
|   └──page
|       ├──404.go
|       ├───about.go
|       ├──archives.go
|       ├──blog.go
|       ├──comment.go
|       ├──pagesController.go
|       ├──researchController.go
|       └──tagsController.go
├── dao
│   ├──blogs.go
│   ├──comment.go
│   ├──sql.go
│   ├──tags.go
│   ├──types.go
│   └──user.go
├── logic
│   └── user.go
├── middlerware
│   ├──function.go
│   ├──getImg.go
│   ├──getTime.go
│   ├──markdown.go
│   ├──select.go
│   └──session.go
├── model
│   ├──blog.go
│   ├──commnent.go
│   ├──tag.go
│   ├──type.go
│   └──user/go
├── static
│   └──静态文件（头像、图片、logo、css、js等）
├── templates
│   └──html模板文件
├── go.mod（依赖）
└── main.go
</code></pre>

<h2>2.相关功能实现简介</h2>

<h3>1、评论及回复功能</h3>

<p>comment的结构体属性如下</p>

<pre><code class="language-go">package model

type Comment struct {
    Id     int //评论id
    BlogId int //博文id
    ReCommentId    int    //父评论id
    CommentName string //评论人姓名
    ReCommentName  string //父评论人姓名
    CommentEmail   string
    Img            string
    CommentContent string `gorm:&#34;type:text&#34; form:&#34;CommentContent&#34; json:&#34;CommentContent&#34;` //评论内容
    CommentTime    string ` json:&#34;comment_time,omitempty&#34;`
    Parent         *Comment
    Comments       []Comment
}
</code></pre>

<h4>实现方法</h4>

<h5>1先通过查找父评论为-1的顶级评论</h5>

<p>父评论Id为-1说明他不是任何评论的子评论</p>

<h5>2在html上遍历所有的顶级评论</h5>

<p>在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论</p>

<h6>（1）递归存储每个顶级评论的子评论</h6>

<p>这里我用一个切片来储存一个顶级评论的所有子评论</p>

<pre><code class="language-go">var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
    var comments []model.Comment
    DB.Debug().Where(&#34;re_comment_id = -1 AND blog_id = ?&#34;, id).Find(&amp;comments)
    return &amp;comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
    if count != 0 {
        fmt.Println(&#34;if判断1&#34;)
        var comments []model.Comment
        DB.Debug().Where(&#34;re_comment_id = ?&#34;, id).Find(&amp;comments)
        count = len(comments)
        if count != 0 {
            fmt.Println(&#34;if判断2&#34;)
            for _, comment := range comments {
                fmt.Println(&#34;for判断1&#34;)
                Comments = append(Comments, comment)
                SelectCommentByComment(comment.Id, count)
            }
        }
    }
    fmt.Println(Comments)
    return &amp;Comments

}
</code></pre>

<p>ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来</p>

<h6>（2）出现问题的原因</h6>

<p>因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量</p>

<h6>（3）解决问题</h6>

<pre><code class="language-go">func ClearComments() bool {
    var comments []model.Comment
    Comments = comments
    return true
}

</code></pre>

<p>这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现</p>

<h4>这里我还加了一个小小的随机头像功能</h4>

<pre><code class="language-go">if  CommentName == user.Name &amp;&amp; CommentEmail == user.UserEmail {
        fmt.Println(&#34;进入了1&#34;)
        comment.Img =user.UserImg
        //找相同评论人
    }else if CommentName == one.CommentName &amp;&amp; CommentEmail == one.CommentEmail {
        fmt.Println(&#34;进入了2&#34;)
        comment.Img =one.Img
        //随机选头像
    }else{
        fmt.Println(&#34;进入了3&#34;)
        comment.Img =middleware.GetImg()
    }
</code></pre>

<h5>123分别代表三种不同的用户群体</h5>

<p>1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
<img src="/static/images/%e5%a4%b4%e5%83%8f1.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f2.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f3.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f4.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f5.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f6.png" alt=""/></p>

<h3>2、归档功能</h3>

<h4>blog的结构体属性如下</h4>

<pre><code class="language-go">package model

type Blog struct {
    Id           int
    Title        string    `form:&#34;title&#34; json:&#34;title&#34;`                          //标题
    Content      string    `gorm:&#34;type:longtext&#34; form:&#34;content&#34; json:&#34;content&#34;` //内容
    Image        string    `gorm:&#34;type:text&#34; form:&#34;image&#34; json:&#34;image&#34;`         //首图
    Numb         int       `form:&#34;numb&#34; json:&#34;numb&#34;`                            //次数
    Flag         string    `form:&#34;flag&#34; json:&#34;flag&#34;`                            //原创或者转载
    Appreciation string    `form:&#34;appreciation&#34; json:&#34;appreciation&#34;`            //打赏开关
    ShareInfo    string    `form:&#34;shareInfo&#34; json:&#34;shareInfo&#34;`                  //版权开关
    Comment      string    `form:&#34;comment&#34; json:&#34;comment&#34;`                      //评论开关
    Recommend    string    `form:&#34;recommend&#34; json:&#34;recommend&#34;`                  //推荐开关
    Description  string    `gorm:&#34;type:text&#34; form:&#34;description&#34; json:&#34;description&#34;`
    CreatTime    string    `form:&#34;creatTime&#34;  json:&#34;creat_time,omitempty&#34;`   //创建时间
    UpdateTime   string    `form:&#34;updateTime&#34;  json:&#34;update_time,omitempty&#34;` //更新时间
    Comments     []Comment `form:&#34;comments&#34; json:&#34;comments&#34;`
    TypeId       int       `form:&#34;typeId&#34; json:&#34;typeId&#34;`
    Type         Type      `form:&#34;type&#34; gorm:&#34;ForeignKey:TypeId&#34;`
    Year         int       `form:&#34;year&#34; json:&#34;year&#34;`
    Month        int       `form:&#34;month&#34; json:&#34;month&#34;`
    Day          int       `form:&#34;day&#34; json:&#34;day&#34;`
}

</code></pre>

<h4>实现方法</h4>

<p>我的思路是创建三个时间节点
year month day
利用sql分组查询</p>

<h5>Group By分组查询步骤</h5>

<h6>（1）先按照年份查询</h6>

<h6>（2）再按照年份遍历每个月份</h6>

<p>并将所有保存在一个切片中</p>

<h6>（3）按照月份遍历每个月的所有文章</h6>

<p>保存在一个Map中，key是对应的月份，value是每个月份的所有文章</p>

<h4>自此归档功能实现</h4>

<h2>3.已知BUG</h2>

<h3>后台退出功能</h3>

<p>后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧</p>

<p>开源地址
<a href="https://github.com/likewl/blog" title="github" rel="nofollow">github</a>
<a href="https://gitee.com/nculike/blog" title="gitee" rel="nofollow">gitee</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:09:53][0m  [36;1m[0.27ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:09:59][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 00:09:59][0m  [36;1m[0.77ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 00:09:59][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 00:09:59][0m  [36;1m[0.31ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 00:09:59][0m  [36;1m[0.27ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 00:09:59][0m  [36;1m[0.32ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-21 00:10:01][0m  [36;1m[0.39ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 2)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-21 00:10:01][0m  [36;1m[0.55ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=2  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-21 00:10:01][0m  [36;1m[0.42ms][0m  UPDATE `blogs` SET `title` = '解决Linux关闭终端后运行的程序自动停止', `content` = '# 问题发现
  昨天博客发布，操作完关闭终端就睡了
  然而今天醒来突然发现终端不能访问了
  查看发现原来博客项目进程被杀死了
# 解决办法
    go build main.go
执行完后

    nohup ./main &
让程序在后台运行就可了


[========]
# ps:这个方法并不完美，因为我也是刚刚接触还不知道怎么切回来', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3696516981,3671280793&fm=26&gp=0.jpg', `numb` = 14, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '昨天博客发布，操作完关闭终端就睡了，然而今天醒来突然发现终端不能访问了，查看发现原来博客项目进程被杀死了', `creat_time` = '2020-07-19 19:05:36', `update_time` = '2020-07-19 19:05:36', `type_id` = 2, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 3  
[36;31m[1 rows affected or returned ][0m 
<h1>问题发现</h1>

<p>昨天博客发布，操作完关闭终端就睡了
  然而今天醒来突然发现终端不能访问了
  查看发现原来博客项目进程被杀死了</p>

<h1>解决办法</h1>

<pre><code>go build main.go
</code></pre>

<p>执行完后</p>

<pre><code>nohup ./main &amp;
</code></pre>

<p>让程序在后台运行就可了</p>

<p>[========]</p>

<h1>ps:这个方法并不完美，因为我也是刚刚接触还不知道怎么切回来</h1>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:10:01][0m  [36;1m[0.56ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:10:05][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-21 00:10:12][0m  [36;1m[0.36ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 2)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-21 00:10:12][0m  [36;1m[0.44ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=2  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-21 00:10:12][0m  [36;1m[0.40ms][0m  UPDATE `blogs` SET `title` = '解决Linux关闭终端后运行的程序自动停止', `content` = '# 问题发现
  昨天博客发布，操作完关闭终端就睡了
  然而今天醒来突然发现终端不能访问了
  查看发现原来博客项目进程被杀死了
# 解决办法
    go build main.go
执行完后

    nohup ./main &
让程序在后台运行就可了


[========]
# ps:这个方法并不完美，因为我也是刚刚接触还不知道怎么切回来', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3696516981,3671280793&fm=26&gp=0.jpg', `numb` = 15, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '昨天博客发布，操作完关闭终端就睡了，然而今天醒来突然发现终端不能访问了，查看发现原来博客项目进程被杀死了', `creat_time` = '2020-07-19 19:05:36', `update_time` = '2020-07-19 19:05:36', `type_id` = 2, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 3  
[36;31m[1 rows affected or returned ][0m 
<h1>问题发现</h1>

<p>昨天博客发布，操作完关闭终端就睡了
  然而今天醒来突然发现终端不能访问了
  查看发现原来博客项目进程被杀死了</p>

<h1>解决办法</h1>

<pre><code>go build main.go
</code></pre>

<p>执行完后</p>

<pre><code>nohup ./main &amp;
</code></pre>

<p>让程序在后台运行就可了</p>

<p>[========]</p>

<h1>ps:这个方法并不完美，因为我也是刚刚接触还不知道怎么切回来</h1>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:10:12][0m  [36;1m[0.29ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:10:19][0m  [36;1m[0.58ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 00:10:19][0m  [36;1m[0.71ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 00:10:19][0m  [36;1m[0.23ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 00:10:19][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 00:10:19][0m  [36;1m[0.25ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 00:10:19][0m  [36;1m[0.32ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-21 00:10:20][0m  [36;1m[0.48ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 3)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-21 00:10:20][0m  [36;1m[0.48ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=3  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-21 00:10:20][0m  [36;1m[0.43ms][0m  UPDATE `blogs` SET `title` = 'mysql5.7 查询数据，group by 报错：Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 't.id' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by？', `content` = '在做归档功能时用到了分组查询
结果出现了这样的错误
```
Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 't.id' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by

```
查询才知道
mysql 5.7 加入的新特性，only_full_group_by，它只允许你的查询字段是包括在 group by 里面的字段，这种模式导致无法我们无法得到想要的字段值，我们可以禁用掉 only_full_group_by：
### 第一步：
```
select @@GLOBAL.sql_mode;
```
得到现有的 sql_mode, 如下：
```
ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION

```
### 第二步：
```
set global sql_mode ='STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION';

set session sql_mode= 'STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION';
```
去除 ONLY_FULL_GROUP_BY，重新设置，就 ok 了。', `image` = 'https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2507389442,2201469096&fm=26&gp=0.jpg', `numb` = 21, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '在做归档功能时用到了分组查询，结果出现了这样的错误，原来是mysql57的新功能
', `creat_time` = '2020-07-19 18:58:22', `update_time` = '2020-07-19 18:59:30', `type_id` = 3, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 2  
[36;31m[1 rows affected or returned ][0m 
<p>在做归档功能时用到了分组查询
结果出现了这样的错误</p>

<pre><code>Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column &#39;t.id&#39; which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by

</code></pre>

<p>查询才知道
mysql 5.7 加入的新特性，only_full_group_by，它只允许你的查询字段是包括在 group by 里面的字段，这种模式导致无法我们无法得到想要的字段值，我们可以禁用掉 only_full_group_by：</p>

<h3>第一步：</h3>

<pre><code>select @@GLOBAL.sql_mode;
</code></pre>

<p>得到现有的 sql_mode, 如下：</p>

<pre><code>ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION

</code></pre>

<h3>第二步：</h3>

<pre><code>set global sql_mode =&#39;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&#39;;

set session sql_mode= &#39;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&#39;;
</code></pre>

<p>去除 ONLY_FULL_GROUP_BY，重新设置，就 ok 了。</p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:10:20][0m  [36;1m[0.25ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:10:21][0m  [36;1m[0.70ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 00:10:21][0m  [36;1m[0.22ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:137)[0m 
[33m[2020-07-21 00:10:21][0m  [36;1m[0.72ms][0m   SELECT * FROM `blogs` GROUP BY YEAR DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:150)[0m 
[33m[2020-07-21 00:10:21][0m  [36;1m[0.68ms][0m   SELECT * FROM `blogs` where year = 2020 GROUP BY month DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:162)[0m 
[33m[2020-07-21 00:10:21][0m  [36;1m[0.61ms][0m   SELECT * FROM `blogs` where year = 2020 and month = 7 ORDER BY `id` DESC  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 00:10:21][0m  [36;1m[2.42ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=4  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 00:10:21][0m  [36;1m[0.37ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=3  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 00:10:21][0m  [36;1m[0.37ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=2  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 00:10:21][0m  [36;1m[0.35ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-21 00:10:22][0m  [36;1m[0.56ms][0m  SELECT * FROM `tags`    
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:10:22][0m  [36;1m[0.24ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 00:10:22][0m  [36;1m[0.71ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:31)[0m 
[33m[2020-07-21 00:10:22][0m  [36;1m[0.17ms][0m  SELECT count(*) FROM `tags`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-21 00:10:23][0m  [36;1m[0.55ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:10:23][0m  [36;1m[0.28ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 00:10:23][0m  [36;1m[0.73ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-21 00:10:23][0m  [36;1m[0.22ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:10:24][0m  [36;1m[0.53ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 00:10:24][0m  [36;1m[0.71ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 00:10:24][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 00:10:24][0m  [36;1m[0.32ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 00:10:24][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 00:10:24][0m  [36;1m[0.31ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-21 00:10:26][0m  [36;1m[0.39ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 3)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-21 00:10:26][0m  [36;1m[0.43ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=3  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-21 00:10:26][0m  [36;1m[0.38ms][0m  UPDATE `blogs` SET `title` = 'mysql5.7 查询数据，group by 报错：Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 't.id' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by？', `content` = '在做归档功能时用到了分组查询
结果出现了这样的错误
```
Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 't.id' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by

```
查询才知道
mysql 5.7 加入的新特性，only_full_group_by，它只允许你的查询字段是包括在 group by 里面的字段，这种模式导致无法我们无法得到想要的字段值，我们可以禁用掉 only_full_group_by：
### 第一步：
```
select @@GLOBAL.sql_mode;
```
得到现有的 sql_mode, 如下：
```
ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION

```
### 第二步：
```
set global sql_mode ='STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION';

set session sql_mode= 'STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION';
```
去除 ONLY_FULL_GROUP_BY，重新设置，就 ok 了。', `image` = 'https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2507389442,2201469096&fm=26&gp=0.jpg', `numb` = 22, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '在做归档功能时用到了分组查询，结果出现了这样的错误，原来是mysql57的新功能
', `creat_time` = '2020-07-19 18:58:22', `update_time` = '2020-07-19 18:59:30', `type_id` = 3, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 2  
[36;31m[1 rows affected or returned ][0m 
<p>在做归档功能时用到了分组查询
结果出现了这样的错误</p>

<pre><code>Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column &#39;t.id&#39; which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by

</code></pre>

<p>查询才知道
mysql 5.7 加入的新特性，only_full_group_by，它只允许你的查询字段是包括在 group by 里面的字段，这种模式导致无法我们无法得到想要的字段值，我们可以禁用掉 only_full_group_by：</p>

<h3>第一步：</h3>

<pre><code>select @@GLOBAL.sql_mode;
</code></pre>

<p>得到现有的 sql_mode, 如下：</p>

<pre><code>ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION

</code></pre>

<h3>第二步：</h3>

<pre><code>set global sql_mode =&#39;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&#39;;

set session sql_mode= &#39;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&#39;;
</code></pre>

<p>去除 ONLY_FULL_GROUP_BY，重新设置，就 ok 了。</p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:10:26][0m  [36;1m[0.28ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:10:27][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 00:10:27][0m  [36;1m[0.75ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 00:10:27][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 00:10:27][0m  [36;1m[0.33ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 00:10:27][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 00:10:27][0m  [36;1m[0.33ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-21 00:10:31][0m  [36;1m[0.57ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:10:31][0m  [36;1m[0.26ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 00:10:31][0m  [36;1m[0.85ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-21 00:10:31][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-21 00:10:32][0m  [36;1m[0.60ms][0m  SELECT * FROM `tags`    
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:10:32][0m  [36;1m[0.29ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 00:10:32][0m  [36;1m[0.66ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:31)[0m 
[33m[2020-07-21 00:10:32][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `tags`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:10:33][0m  [36;1m[0.57ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 00:10:33][0m  [36;1m[0.76ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 00:10:33][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 00:10:33][0m  [36;1m[0.31ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 00:10:33][0m  [36;1m[0.28ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 00:10:33][0m  [36;1m[0.33ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:10:34][0m  [36;1m[0.57ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:10:35][0m  [36;1m[0.49ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 00:10:35][0m  [36;1m[0.22ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:137)[0m 
[33m[2020-07-21 00:10:35][0m  [36;1m[0.59ms][0m   SELECT * FROM `blogs` GROUP BY YEAR DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:150)[0m 
[33m[2020-07-21 00:10:35][0m  [36;1m[0.65ms][0m   SELECT * FROM `blogs` where year = 2020 GROUP BY month DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:162)[0m 
[33m[2020-07-21 00:10:35][0m  [36;1m[0.60ms][0m   SELECT * FROM `blogs` where year = 2020 and month = 7 ORDER BY `id` DESC  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 00:10:35][0m  [36;1m[0.37ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=4  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 00:10:35][0m  [36;1m[0.34ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=3  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 00:10:35][0m  [36;1m[0.33ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=2  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 00:10:35][0m  [36;1m[0.32ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:12:22][0m  [36;1m[0.60ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:12:33][0m  [36;1m[0.99ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 00:12:33][0m  [36;1m[1.94ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:137)[0m 
[33m[2020-07-21 00:12:33][0m  [36;1m[0.64ms][0m   SELECT * FROM `blogs` GROUP BY YEAR DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:150)[0m 
[33m[2020-07-21 00:12:33][0m  [36;1m[0.74ms][0m   SELECT * FROM `blogs` where year = 2020 GROUP BY month DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:162)[0m 
[33m[2020-07-21 00:12:33][0m  [36;1m[0.68ms][0m   SELECT * FROM `blogs` where year = 2020 and month = 7 ORDER BY `id` DESC  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 00:12:33][0m  [36;1m[0.42ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=4  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 00:12:33][0m  [36;1m[0.42ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=3  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 00:12:33][0m  [36;1m[0.35ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=2  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 00:12:33][0m  [36;1m[0.35ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:12:35][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 00:12:35][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:137)[0m 
[33m[2020-07-21 00:12:35][0m  [36;1m[0.62ms][0m   SELECT * FROM `blogs` GROUP BY YEAR DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:150)[0m 
[33m[2020-07-21 00:12:35][0m  [36;1m[0.67ms][0m   SELECT * FROM `blogs` where year = 2020 GROUP BY month DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:162)[0m 
[33m[2020-07-21 00:12:35][0m  [36;1m[0.59ms][0m   SELECT * FROM `blogs` where year = 2020 and month = 7 ORDER BY `id` DESC  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 00:12:35][0m  [36;1m[0.42ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=4  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 00:12:35][0m  [36;1m[0.36ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=3  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 00:12:35][0m  [36;1m[0.35ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=2  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 00:12:35][0m  [36;1m[0.33ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-21 00:12:36][0m  [36;1m[0.57ms][0m  SELECT * FROM `tags`    
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:12:36][0m  [36;1m[0.35ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 00:12:36][0m  [36;1m[0.76ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:31)[0m 
[33m[2020-07-21 00:12:36][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `tags`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-21 00:12:36][0m  [36;1m[0.59ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:12:36][0m  [36;1m[0.28ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 00:12:36][0m  [36;1m[0.71ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-21 00:12:36][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:12:37][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 00:12:37][0m  [36;1m[0.70ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 00:12:37][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 00:12:37][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 00:12:37][0m  [36;1m[0.25ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 00:12:37][0m  [36;1m[0.32ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-21 00:12:38][0m  [36;1m[0.36ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 4)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-21 00:12:38][0m  [36;1m[0.45ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=4  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-21 00:12:38][0m  [36;1m[0.44ms][0m  UPDATE `blogs` SET `title` = '本博客开源公告', `content` = '今天本博客评论功能发布
# 自今天起，本博客基本功能已经完成
## 发布V1.0版本并开源
## 博客语言说明
#### 本博客后端是用golang 的gin框架+gorm编写
前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的
#### 博客效果参考本站
#一、博客简介
## 1.博客目录

    blog
    ├────controller
	├────└───admin
	|	|	├──adminblog.go
	|	|	├───adminController.go
	|	|	├──adminTag.go
	|	|	├──adminType.go
	|	|	└──adminUser.go
	|	└──page
	|		├──404.go
	|		├───about.go
	|		├──archives.go
	|		├──blog.go
	|		├──comment.go
	|		├──pagesController.go
	|		├──researchController.go
	|		└──tagsController.go
    ├── dao
	│	├──blogs.go
	│	├──comment.go
	│	├──sql.go
	│	├──tags.go
	│	├──types.go
	│	└──user.go
    ├── logic
    │   └── user.go
    ├── middlerware
	│	├──function.go
	│	├──getImg.go
	│	├──getTime.go
	│	├──markdown.go
	│	├──select.go
	│	└──session.go
    ├── model
	│	├──blog.go
	│	├──commnent.go
	│	├──tag.go
	│	├──type.go
	│	└──user/go
    ├── static
	│	└──静态文件（头像、图片、logo、css、js等）
    ├── templates
	│	└──html模板文件
    ├── go.mod（依赖）
    └── main.go
    

## 2.相关功能实现简介
### 1、评论及回复功能
comment的结构体属性如下
```go
package model

type Comment struct {
	Id     int //评论id
	BlogId int //博文id
	ReCommentId    int    //父评论id
	CommentName string //评论人姓名
	ReCommentName  string //父评论人姓名
	CommentEmail   string
	Img            string
	CommentContent string `gorm:"type:text" form:"CommentContent" json:"CommentContent"` //评论内容
	CommentTime    string ` json:"comment_time,omitempty"`
	Parent         *Comment
	Comments       []Comment
}
```
#### 实现方法
##### 1先通过查找父评论为-1的顶级评论
父评论Id为-1说明他不是任何评论的子评论
##### 2在html上遍历所有的顶级评论
在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论
###### （1）递归存储每个顶级评论的子评论
这里我用一个切片来储存一个顶级评论的所有子评论
```go
var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
	var comments []model.Comment
	DB.Debug().Where("re_comment_id = -1 AND blog_id = ?", id).Find(&comments)
	return &comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
	if count != 0 {
		fmt.Println("if判断1")
		var comments []model.Comment
		DB.Debug().Where("re_comment_id = ?", id).Find(&comments)
		count = len(comments)
		if count != 0 {
			fmt.Println("if判断2")
			for _, comment := range comments {
				fmt.Println("for判断1")
				Comments = append(Comments, comment)
				SelectCommentByComment(comment.Id, count)
			}
		}
	}
	fmt.Println(Comments)
	return &Comments

}
```
ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来
###### （2）出现问题的原因
因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量
###### （3）解决问题
```go
func ClearComments() bool {
	var comments []model.Comment
	Comments = comments
	return true
}

```
这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现
#### 这里我还加了一个小小的随机头像功能
```go
if  CommentName == user.Name && CommentEmail == user.UserEmail {
		fmt.Println("进入了1")
		comment.Img =user.UserImg
		//找相同评论人
	}else if CommentName == one.CommentName && CommentEmail == one.CommentEmail {
		fmt.Println("进入了2")
		comment.Img =one.Img
		//随机选头像
	}else{
		fmt.Println("进入了3")
		comment.Img =middleware.GetImg()
	}
```
##### 123分别代表三种不同的用户群体
1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
![](/static/images/%e5%a4%b4%e5%83%8f1.png)![](/static/images/%e5%a4%b4%e5%83%8f2.png)![](/static/images/%e5%a4%b4%e5%83%8f3.png)![](/static/images/%e5%a4%b4%e5%83%8f4.png)![](/static/images/%e5%a4%b4%e5%83%8f5.png)![](/static/images/%e5%a4%b4%e5%83%8f6.png)
### 2、归档功能
#### blog的结构体属性如下
```go
package model

type Blog struct {
	Id           int
	Title        string    `form:"title" json:"title"`                          //标题
	Content      string    `gorm:"type:longtext" form:"content" json:"content"` //内容
	Image        string    `gorm:"type:text" form:"image" json:"image"`         //首图
	Numb         int       `form:"numb" json:"numb"`                            //次数
	Flag         string    `form:"flag" json:"flag"`                            //原创或者转载
	Appreciation string    `form:"appreciation" json:"appreciation"`            //打赏开关
	ShareInfo    string    `form:"shareInfo" json:"shareInfo"`                  //版权开关
	Comment      string    `form:"comment" json:"comment"`                      //评论开关
	Recommend    string    `form:"recommend" json:"recommend"`                  //推荐开关
	Description  string    `gorm:"type:text" form:"description" json:"description"`
	CreatTime    string    `form:"creatTime"  json:"creat_time,omitempty"`   //创建时间
	UpdateTime   string    `form:"updateTime"  json:"update_time,omitempty"` //更新时间
	Comments     []Comment `form:"comments" json:"comments"`
	TypeId       int       `form:"typeId" json:"typeId"`
	Type         Type      `form:"type" gorm:"ForeignKey:TypeId"`
	Year         int       `form:"year" json:"year"`
	Month        int       `form:"month" json:"month"`
	Day          int       `form:"day" json:"day"`
}

```
#### 实现方法
我的思路是创建三个时间节点
year month day 
利用sql分组查询
##### Group By分组查询步骤
###### （1）先按照年份查询
###### （2）再按照年份遍历每个月份
并将所有保存在一个切片中
###### （3）按照月份遍历每个月的所有文章
保存在一个Map中，key是对应的月份，value是每个月份的所有文章
#### 自此归档功能实现


## 3.已知BUG
### 后台退出功能
后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧

开源地址
[github](https://github.com/likewl/blog "github")
[gitee](https://gitee.com/nculike/blog "gitee")', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1535821573,4166447487&fm=26&gp=0.jpg', `numb` = 29, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '本博客后端是用golang 的gin框架+gorm编写', `creat_time` = '2020-07-20 15:24:23', `update_time` = '2020-07-20 15:24:23', `type_id` = 4, `year` = 2020, `month` = 7, `day` = 20  WHERE `blogs`.`id` = 4  
[36;31m[1 rows affected or returned ][0m 
<p>今天本博客评论功能发布</p>

<h1>自今天起，本博客基本功能已经完成</h1>

<h2>发布V1.0版本并开源</h2>

<h2>博客语言说明</h2>

<h4>本博客后端是用golang 的gin框架+gorm编写</h4>

<p>前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的</p>

<h4>博客效果参考本站</h4>

<p>#一、博客简介</p>

<h2>1.博客目录</h2>

<pre><code>blog
├────controller
├────└───admin
|   |   ├──adminblog.go
|   |   ├───adminController.go
|   |   ├──adminTag.go
|   |   ├──adminType.go
|   |   └──adminUser.go
|   └──page
|       ├──404.go
|       ├───about.go
|       ├──archives.go
|       ├──blog.go
|       ├──comment.go
|       ├──pagesController.go
|       ├──researchController.go
|       └──tagsController.go
├── dao
│   ├──blogs.go
│   ├──comment.go
│   ├──sql.go
│   ├──tags.go
│   ├──types.go
│   └──user.go
├── logic
│   └── user.go
├── middlerware
│   ├──function.go
│   ├──getImg.go
│   ├──getTime.go
│   ├──markdown.go
│   ├──select.go
│   └──session.go
├── model
│   ├──blog.go
│   ├──commnent.go
│   ├──tag.go
│   ├──type.go
│   └──user/go
├── static
│   └──静态文件（头像、图片、logo、css、js等）
├── templates
│   └──html模板文件
├── go.mod（依赖）
└── main.go
</code></pre>

<h2>2.相关功能实现简介</h2>

<h3>1、评论及回复功能</h3>

<p>comment的结构体属性如下</p>

<pre><code class="language-go">package model

type Comment struct {
    Id     int //评论id
    BlogId int //博文id
    ReCommentId    int    //父评论id
    CommentName string //评论人姓名
    ReCommentName  string //父评论人姓名
    CommentEmail   string
    Img            string
    CommentContent string `gorm:&#34;type:text&#34; form:&#34;CommentContent&#34; json:&#34;CommentContent&#34;` //评论内容
    CommentTime    string ` json:&#34;comment_time,omitempty&#34;`
    Parent         *Comment
    Comments       []Comment
}
</code></pre>

<h4>实现方法</h4>

<h5>1先通过查找父评论为-1的顶级评论</h5>

<p>父评论Id为-1说明他不是任何评论的子评论</p>

<h5>2在html上遍历所有的顶级评论</h5>

<p>在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论</p>

<h6>（1）递归存储每个顶级评论的子评论</h6>

<p>这里我用一个切片来储存一个顶级评论的所有子评论</p>

<pre><code class="language-go">var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
    var comments []model.Comment
    DB.Debug().Where(&#34;re_comment_id = -1 AND blog_id = ?&#34;, id).Find(&amp;comments)
    return &amp;comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
    if count != 0 {
        fmt.Println(&#34;if判断1&#34;)
        var comments []model.Comment
        DB.Debug().Where(&#34;re_comment_id = ?&#34;, id).Find(&amp;comments)
        count = len(comments)
        if count != 0 {
            fmt.Println(&#34;if判断2&#34;)
            for _, comment := range comments {
                fmt.Println(&#34;for判断1&#34;)
                Comments = append(Comments, comment)
                SelectCommentByComment(comment.Id, count)
            }
        }
    }
    fmt.Println(Comments)
    return &amp;Comments

}
</code></pre>

<p>ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来</p>

<h6>（2）出现问题的原因</h6>

<p>因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量</p>

<h6>（3）解决问题</h6>

<pre><code class="language-go">func ClearComments() bool {
    var comments []model.Comment
    Comments = comments
    return true
}

</code></pre>

<p>这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现</p>

<h4>这里我还加了一个小小的随机头像功能</h4>

<pre><code class="language-go">if  CommentName == user.Name &amp;&amp; CommentEmail == user.UserEmail {
        fmt.Println(&#34;进入了1&#34;)
        comment.Img =user.UserImg
        //找相同评论人
    }else if CommentName == one.CommentName &amp;&amp; CommentEmail == one.CommentEmail {
        fmt.Println(&#34;进入了2&#34;)
        comment.Img =one.Img
        //随机选头像
    }else{
        fmt.Println(&#34;进入了3&#34;)
        comment.Img =middleware.GetImg()
    }
</code></pre>

<h5>123分别代表三种不同的用户群体</h5>

<p>1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
<img src="/static/images/%e5%a4%b4%e5%83%8f1.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f2.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f3.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f4.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f5.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f6.png" alt=""/></p>

<h3>2、归档功能</h3>

<h4>blog的结构体属性如下</h4>

<pre><code class="language-go">package model

type Blog struct {
    Id           int
    Title        string    `form:&#34;title&#34; json:&#34;title&#34;`                          //标题
    Content      string    `gorm:&#34;type:longtext&#34; form:&#34;content&#34; json:&#34;content&#34;` //内容
    Image        string    `gorm:&#34;type:text&#34; form:&#34;image&#34; json:&#34;image&#34;`         //首图
    Numb         int       `form:&#34;numb&#34; json:&#34;numb&#34;`                            //次数
    Flag         string    `form:&#34;flag&#34; json:&#34;flag&#34;`                            //原创或者转载
    Appreciation string    `form:&#34;appreciation&#34; json:&#34;appreciation&#34;`            //打赏开关
    ShareInfo    string    `form:&#34;shareInfo&#34; json:&#34;shareInfo&#34;`                  //版权开关
    Comment      string    `form:&#34;comment&#34; json:&#34;comment&#34;`                      //评论开关
    Recommend    string    `form:&#34;recommend&#34; json:&#34;recommend&#34;`                  //推荐开关
    Description  string    `gorm:&#34;type:text&#34; form:&#34;description&#34; json:&#34;description&#34;`
    CreatTime    string    `form:&#34;creatTime&#34;  json:&#34;creat_time,omitempty&#34;`   //创建时间
    UpdateTime   string    `form:&#34;updateTime&#34;  json:&#34;update_time,omitempty&#34;` //更新时间
    Comments     []Comment `form:&#34;comments&#34; json:&#34;comments&#34;`
    TypeId       int       `form:&#34;typeId&#34; json:&#34;typeId&#34;`
    Type         Type      `form:&#34;type&#34; gorm:&#34;ForeignKey:TypeId&#34;`
    Year         int       `form:&#34;year&#34; json:&#34;year&#34;`
    Month        int       `form:&#34;month&#34; json:&#34;month&#34;`
    Day          int       `form:&#34;day&#34; json:&#34;day&#34;`
}

</code></pre>

<h4>实现方法</h4>

<p>我的思路是创建三个时间节点
year month day
利用sql分组查询</p>

<h5>Group By分组查询步骤</h5>

<h6>（1）先按照年份查询</h6>

<h6>（2）再按照年份遍历每个月份</h6>

<p>并将所有保存在一个切片中</p>

<h6>（3）按照月份遍历每个月的所有文章</h6>

<p>保存在一个Map中，key是对应的月份，value是每个月份的所有文章</p>

<h4>自此归档功能实现</h4>

<h2>3.已知BUG</h2>

<h3>后台退出功能</h3>

<p>后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧</p>

<p>开源地址
<a href="https://github.com/likewl/blog" title="github" rel="nofollow">github</a>
<a href="https://gitee.com/nculike/blog" title="gitee" rel="nofollow">gitee</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:12:38][0m  [36;1m[0.29ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-21 00:12:43][0m  [36;1m[0.44ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 4)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-21 00:12:43][0m  [36;1m[0.49ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=4  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-21 00:12:43][0m  [36;1m[0.56ms][0m  UPDATE `blogs` SET `title` = '本博客开源公告', `content` = '今天本博客评论功能发布
# 自今天起，本博客基本功能已经完成
## 发布V1.0版本并开源
## 博客语言说明
#### 本博客后端是用golang 的gin框架+gorm编写
前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的
#### 博客效果参考本站
#一、博客简介
## 1.博客目录

    blog
    ├────controller
	├────└───admin
	|	|	├──adminblog.go
	|	|	├───adminController.go
	|	|	├──adminTag.go
	|	|	├──adminType.go
	|	|	└──adminUser.go
	|	└──page
	|		├──404.go
	|		├───about.go
	|		├──archives.go
	|		├──blog.go
	|		├──comment.go
	|		├──pagesController.go
	|		├──researchController.go
	|		└──tagsController.go
    ├── dao
	│	├──blogs.go
	│	├──comment.go
	│	├──sql.go
	│	├──tags.go
	│	├──types.go
	│	└──user.go
    ├── logic
    │   └── user.go
    ├── middlerware
	│	├──function.go
	│	├──getImg.go
	│	├──getTime.go
	│	├──markdown.go
	│	├──select.go
	│	└──session.go
    ├── model
	│	├──blog.go
	│	├──commnent.go
	│	├──tag.go
	│	├──type.go
	│	└──user/go
    ├── static
	│	└──静态文件（头像、图片、logo、css、js等）
    ├── templates
	│	└──html模板文件
    ├── go.mod（依赖）
    └── main.go
    

## 2.相关功能实现简介
### 1、评论及回复功能
comment的结构体属性如下
```go
package model

type Comment struct {
	Id     int //评论id
	BlogId int //博文id
	ReCommentId    int    //父评论id
	CommentName string //评论人姓名
	ReCommentName  string //父评论人姓名
	CommentEmail   string
	Img            string
	CommentContent string `gorm:"type:text" form:"CommentContent" json:"CommentContent"` //评论内容
	CommentTime    string ` json:"comment_time,omitempty"`
	Parent         *Comment
	Comments       []Comment
}
```
#### 实现方法
##### 1先通过查找父评论为-1的顶级评论
父评论Id为-1说明他不是任何评论的子评论
##### 2在html上遍历所有的顶级评论
在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论
###### （1）递归存储每个顶级评论的子评论
这里我用一个切片来储存一个顶级评论的所有子评论
```go
var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
	var comments []model.Comment
	DB.Debug().Where("re_comment_id = -1 AND blog_id = ?", id).Find(&comments)
	return &comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
	if count != 0 {
		fmt.Println("if判断1")
		var comments []model.Comment
		DB.Debug().Where("re_comment_id = ?", id).Find(&comments)
		count = len(comments)
		if count != 0 {
			fmt.Println("if判断2")
			for _, comment := range comments {
				fmt.Println("for判断1")
				Comments = append(Comments, comment)
				SelectCommentByComment(comment.Id, count)
			}
		}
	}
	fmt.Println(Comments)
	return &Comments

}
```
ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来
###### （2）出现问题的原因
因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量
###### （3）解决问题
```go
func ClearComments() bool {
	var comments []model.Comment
	Comments = comments
	return true
}

```
这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现
#### 这里我还加了一个小小的随机头像功能
```go
if  CommentName == user.Name && CommentEmail == user.UserEmail {
		fmt.Println("进入了1")
		comment.Img =user.UserImg
		//找相同评论人
	}else if CommentName == one.CommentName && CommentEmail == one.CommentEmail {
		fmt.Println("进入了2")
		comment.Img =one.Img
		//随机选头像
	}else{
		fmt.Println("进入了3")
		comment.Img =middleware.GetImg()
	}
```
##### 123分别代表三种不同的用户群体
1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
![](/static/images/%e5%a4%b4%e5%83%8f1.png)![](/static/images/%e5%a4%b4%e5%83%8f2.png)![](/static/images/%e5%a4%b4%e5%83%8f3.png)![](/static/images/%e5%a4%b4%e5%83%8f4.png)![](/static/images/%e5%a4%b4%e5%83%8f5.png)![](/static/images/%e5%a4%b4%e5%83%8f6.png)
### 2、归档功能
#### blog的结构体属性如下
```go
package model

type Blog struct {
	Id           int
	Title        string    `form:"title" json:"title"`                          //标题
	Content      string    `gorm:"type:longtext" form:"content" json:"content"` //内容
	Image        string    `gorm:"type:text" form:"image" json:"image"`         //首图
	Numb         int       `form:"numb" json:"numb"`                            //次数
	Flag         string    `form:"flag" json:"flag"`                            //原创或者转载
	Appreciation string    `form:"appreciation" json:"appreciation"`            //打赏开关
	ShareInfo    string    `form:"shareInfo" json:"shareInfo"`                  //版权开关
	Comment      string    `form:"comment" json:"comment"`                      //评论开关
	Recommend    string    `form:"recommend" json:"recommend"`                  //推荐开关
	Description  string    `gorm:"type:text" form:"description" json:"description"`
	CreatTime    string    `form:"creatTime"  json:"creat_time,omitempty"`   //创建时间
	UpdateTime   string    `form:"updateTime"  json:"update_time,omitempty"` //更新时间
	Comments     []Comment `form:"comments" json:"comments"`
	TypeId       int       `form:"typeId" json:"typeId"`
	Type         Type      `form:"type" gorm:"ForeignKey:TypeId"`
	Year         int       `form:"year" json:"year"`
	Month        int       `form:"month" json:"month"`
	Day          int       `form:"day" json:"day"`
}

```
#### 实现方法
我的思路是创建三个时间节点
year month day 
利用sql分组查询
##### Group By分组查询步骤
###### （1）先按照年份查询
###### （2）再按照年份遍历每个月份
并将所有保存在一个切片中
###### （3）按照月份遍历每个月的所有文章
保存在一个Map中，key是对应的月份，value是每个月份的所有文章
#### 自此归档功能实现


## 3.已知BUG
### 后台退出功能
后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧

开源地址
[github](https://github.com/likewl/blog "github")
[gitee](https://gitee.com/nculike/blog "gitee")', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1535821573,4166447487&fm=26&gp=0.jpg', `numb` = 30, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '本博客后端是用golang 的gin框架+gorm编写', `creat_time` = '2020-07-20 15:24:23', `update_time` = '2020-07-20 15:24:23', `type_id` = 4, `year` = 2020, `month` = 7, `day` = 20  WHERE `blogs`.`id` = 4  
[36;31m[1 rows affected or returned ][0m 
<p>今天本博客评论功能发布</p>

<h1>自今天起，本博客基本功能已经完成</h1>

<h2>发布V1.0版本并开源</h2>

<h2>博客语言说明</h2>

<h4>本博客后端是用golang 的gin框架+gorm编写</h4>

<p>前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的</p>

<h4>博客效果参考本站</h4>

<p>#一、博客简介</p>

<h2>1.博客目录</h2>

<pre><code>blog
├────controller
├────└───admin
|   |   ├──adminblog.go
|   |   ├───adminController.go
|   |   ├──adminTag.go
|   |   ├──adminType.go
|   |   └──adminUser.go
|   └──page
|       ├──404.go
|       ├───about.go
|       ├──archives.go
|       ├──blog.go
|       ├──comment.go
|       ├──pagesController.go
|       ├──researchController.go
|       └──tagsController.go
├── dao
│   ├──blogs.go
│   ├──comment.go
│   ├──sql.go
│   ├──tags.go
│   ├──types.go
│   └──user.go
├── logic
│   └── user.go
├── middlerware
│   ├──function.go
│   ├──getImg.go
│   ├──getTime.go
│   ├──markdown.go
│   ├──select.go
│   └──session.go
├── model
│   ├──blog.go
│   ├──commnent.go
│   ├──tag.go
│   ├──type.go
│   └──user/go
├── static
│   └──静态文件（头像、图片、logo、css、js等）
├── templates
│   └──html模板文件
├── go.mod（依赖）
└── main.go
</code></pre>

<h2>2.相关功能实现简介</h2>

<h3>1、评论及回复功能</h3>

<p>comment的结构体属性如下</p>

<pre><code class="language-go">package model

type Comment struct {
    Id     int //评论id
    BlogId int //博文id
    ReCommentId    int    //父评论id
    CommentName string //评论人姓名
    ReCommentName  string //父评论人姓名
    CommentEmail   string
    Img            string
    CommentContent string `gorm:&#34;type:text&#34; form:&#34;CommentContent&#34; json:&#34;CommentContent&#34;` //评论内容
    CommentTime    string ` json:&#34;comment_time,omitempty&#34;`
    Parent         *Comment
    Comments       []Comment
}
</code></pre>

<h4>实现方法</h4>

<h5>1先通过查找父评论为-1的顶级评论</h5>

<p>父评论Id为-1说明他不是任何评论的子评论</p>

<h5>2在html上遍历所有的顶级评论</h5>

<p>在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论</p>

<h6>（1）递归存储每个顶级评论的子评论</h6>

<p>这里我用一个切片来储存一个顶级评论的所有子评论</p>

<pre><code class="language-go">var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
    var comments []model.Comment
    DB.Debug().Where(&#34;re_comment_id = -1 AND blog_id = ?&#34;, id).Find(&amp;comments)
    return &amp;comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
    if count != 0 {
        fmt.Println(&#34;if判断1&#34;)
        var comments []model.Comment
        DB.Debug().Where(&#34;re_comment_id = ?&#34;, id).Find(&amp;comments)
        count = len(comments)
        if count != 0 {
            fmt.Println(&#34;if判断2&#34;)
            for _, comment := range comments {
                fmt.Println(&#34;for判断1&#34;)
                Comments = append(Comments, comment)
                SelectCommentByComment(comment.Id, count)
            }
        }
    }
    fmt.Println(Comments)
    return &amp;Comments

}
</code></pre>

<p>ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来</p>

<h6>（2）出现问题的原因</h6>

<p>因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量</p>

<h6>（3）解决问题</h6>

<pre><code class="language-go">func ClearComments() bool {
    var comments []model.Comment
    Comments = comments
    return true
}

</code></pre>

<p>这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现</p>

<h4>这里我还加了一个小小的随机头像功能</h4>

<pre><code class="language-go">if  CommentName == user.Name &amp;&amp; CommentEmail == user.UserEmail {
        fmt.Println(&#34;进入了1&#34;)
        comment.Img =user.UserImg
        //找相同评论人
    }else if CommentName == one.CommentName &amp;&amp; CommentEmail == one.CommentEmail {
        fmt.Println(&#34;进入了2&#34;)
        comment.Img =one.Img
        //随机选头像
    }else{
        fmt.Println(&#34;进入了3&#34;)
        comment.Img =middleware.GetImg()
    }
</code></pre>

<h5>123分别代表三种不同的用户群体</h5>

<p>1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
<img src="/static/images/%e5%a4%b4%e5%83%8f1.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f2.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f3.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f4.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f5.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f6.png" alt=""/></p>

<h3>2、归档功能</h3>

<h4>blog的结构体属性如下</h4>

<pre><code class="language-go">package model

type Blog struct {
    Id           int
    Title        string    `form:&#34;title&#34; json:&#34;title&#34;`                          //标题
    Content      string    `gorm:&#34;type:longtext&#34; form:&#34;content&#34; json:&#34;content&#34;` //内容
    Image        string    `gorm:&#34;type:text&#34; form:&#34;image&#34; json:&#34;image&#34;`         //首图
    Numb         int       `form:&#34;numb&#34; json:&#34;numb&#34;`                            //次数
    Flag         string    `form:&#34;flag&#34; json:&#34;flag&#34;`                            //原创或者转载
    Appreciation string    `form:&#34;appreciation&#34; json:&#34;appreciation&#34;`            //打赏开关
    ShareInfo    string    `form:&#34;shareInfo&#34; json:&#34;shareInfo&#34;`                  //版权开关
    Comment      string    `form:&#34;comment&#34; json:&#34;comment&#34;`                      //评论开关
    Recommend    string    `form:&#34;recommend&#34; json:&#34;recommend&#34;`                  //推荐开关
    Description  string    `gorm:&#34;type:text&#34; form:&#34;description&#34; json:&#34;description&#34;`
    CreatTime    string    `form:&#34;creatTime&#34;  json:&#34;creat_time,omitempty&#34;`   //创建时间
    UpdateTime   string    `form:&#34;updateTime&#34;  json:&#34;update_time,omitempty&#34;` //更新时间
    Comments     []Comment `form:&#34;comments&#34; json:&#34;comments&#34;`
    TypeId       int       `form:&#34;typeId&#34; json:&#34;typeId&#34;`
    Type         Type      `form:&#34;type&#34; gorm:&#34;ForeignKey:TypeId&#34;`
    Year         int       `form:&#34;year&#34; json:&#34;year&#34;`
    Month        int       `form:&#34;month&#34; json:&#34;month&#34;`
    Day          int       `form:&#34;day&#34; json:&#34;day&#34;`
}

</code></pre>

<h4>实现方法</h4>

<p>我的思路是创建三个时间节点
year month day
利用sql分组查询</p>

<h5>Group By分组查询步骤</h5>

<h6>（1）先按照年份查询</h6>

<h6>（2）再按照年份遍历每个月份</h6>

<p>并将所有保存在一个切片中</p>

<h6>（3）按照月份遍历每个月的所有文章</h6>

<p>保存在一个Map中，key是对应的月份，value是每个月份的所有文章</p>

<h4>自此归档功能实现</h4>

<h2>3.已知BUG</h2>

<h3>后台退出功能</h3>

<p>后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧</p>

<p>开源地址
<a href="https://github.com/likewl/blog" title="github" rel="nofollow">github</a>
<a href="https://gitee.com/nculike/blog" title="gitee" rel="nofollow">gitee</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:12:43][0m  [36;1m[1.87ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:21:01][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 00:21:01][0m  [36;1m[0.71ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 00:21:01][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 00:21:01][0m  [36;1m[0.29ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 00:21:01][0m  [36;1m[0.30ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 00:21:01][0m  [36;1m[0.33ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-21 00:21:07][0m  [36;1m[0.50ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 1)  
[36;31m[2 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-21 00:21:07][0m  [36;1m[0.51ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=1  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-21 00:21:07][0m  [36;1m[0.52ms][0m  UPDATE `blogs` SET `title` = 'golang项目简单服务器部署到阿里云(linux)', `content` = '# 我个人比较推荐使用Xftp和Xshell 
# 重要是个人免费用
# 舒服又好用

# 1.下载安装go安装包：
	## （1）go语言下载地址：
	[Go语言中文网](https://studygolang.com/dl "Go语言中文网")
下载linux版本的安装包。

## （2）使用Xftp将安装包上传至指定的路径：

![](https://img-blog.csdnimg.cn/20190719142701389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
	这里上传到root目录下就行
	方便解压
## （3）解压并移到/usr/local/下：

进入指定目录，查看已有文件并且解压文件：

![](https://img-blog.csdnimg.cn/20190719143211340.png)
```
#在root目录输入ls查看目录文件
ls
#在root解压go包
tar -zxvf go的包名
```

解压完成后发现目录下多了一个go文件夹：
![](https://img-blog.csdnimg.cn/20190719143042938.png)
将文件夹移动到/usr/local/
![](https://img-blog.csdnimg.cn/20190719143137645.png)
# 2.配置环境变量：
## （1）进入目的目录查看go文件夹是否移动成功：
![](https://img-blog.csdnimg.cn/20190719143506382.png)
## （2）在usr下创建文件夹，用来存放自己的项目：
workspace
## （3）进入新建的目录workspace新建三个文件夹：
src
pkg
bin
### 说明：

	src 目录存放的是我们的go源代码，不同工程项目的代码以包名区分
	pkg 编译后生成的文件
	bin文件夹存放go install命名生成的可执行文件（这个文件夹会配置到环境变量中）
## （4）配置环境变量：

进入 /etc 修改profile文件：
![](https://img-blog.csdnimg.cn/20190719144319621.png)
```
#进入etc目录
cd /etc/
#配置 profile
vim profile
```
![](https://img-blog.csdnimg.cn/20190719145650864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
在此文件夹下加入上图的代码，代码如下：
```
// 设置go安装路径
export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin
 
// 设置工程目录
export GOPATH=/usr/workspace
export PATH=$PATH:$GOPATH/bin
```

## （5）刷新环境变量：
```
source /etc/profile
```
##  （6）查看go环境是否配置成功：
```
go version
```
## （7）查看详细配置：
```
go env
```
结果如下：  
![](https://img-blog.csdnimg.cn/20190719145255720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70) 
# 3.上传项目代码：
在刚刚创建的workspace下新创建的三个文件夹中，src 目录存放的是我们的go源代码
# 4运行
```go
go build main.go
//或者
go run main.go
```
最后执行 ./main 就行了。
如果想让项目在后台执行：执行 nohup ./main & ，这样就可以程序在后台运行了。

参考教程https://blog.csdn.net/qq_42410605/article/details/96479892', `image` = 'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3111860246,1925938903&fm=26&gp=0.jpg', `numb` = 43, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '简单又详细的教程', `creat_time` = '2020-07-19 18:32:31', `update_time` = '2020-07-20 13:11:56', `type_id` = 1, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 1  
[36;31m[1 rows affected or returned ][0m 
<h1>我个人比较推荐使用Xftp和Xshell</h1>

<h1>重要是个人免费用</h1>

<h1>舒服又好用</h1>

<h1>1.下载安装go安装包：</h1>

<pre><code>## （1）go语言下载地址：
[Go语言中文网](https://studygolang.com/dl &#34;Go语言中文网&#34;)
</code></pre>

<p>下载linux版本的安装包。</p>

<h2>（2）使用Xftp将安装包上传至指定的路径：</h2>

<p><img src="https://img-blog.csdnimg.cn/20190719142701389.png?x-oss-process=image%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1%2Csize_16%2Ccolor_FFFFFF%2Ct_70" alt=""/>
    这里上传到root目录下就行
    方便解压</p>

<h2>（3）解压并移到/usr/local/下：</h2>

<p>进入指定目录，查看已有文件并且解压文件：</p>

<p><img src="https://img-blog.csdnimg.cn/20190719143211340.png" alt=""/></p>

<pre><code>#在root目录输入ls查看目录文件
ls
#在root解压go包
tar -zxvf go的包名
</code></pre>

<p>解压完成后发现目录下多了一个go文件夹：
<img src="https://img-blog.csdnimg.cn/20190719143042938.png" alt=""/>
将文件夹移动到/usr/local/
<img src="https://img-blog.csdnimg.cn/20190719143137645.png" alt=""/></p>

<h1>2.配置环境变量：</h1>

<h2>（1）进入目的目录查看go文件夹是否移动成功：</h2>

<p><img src="https://img-blog.csdnimg.cn/20190719143506382.png" alt=""/></p>

<h2>（2）在usr下创建文件夹，用来存放自己的项目：</h2>

<p>workspace</p>

<h2>（3）进入新建的目录workspace新建三个文件夹：</h2>

<p>src
pkg
bin</p>

<h3>说明：</h3>

<pre><code>src 目录存放的是我们的go源代码，不同工程项目的代码以包名区分
pkg 编译后生成的文件
bin文件夹存放go install命名生成的可执行文件（这个文件夹会配置到环境变量中）
</code></pre>

<h2>（4）配置环境变量：</h2>

<p>进入 /etc 修改profile文件：
<img src="https://img-blog.csdnimg.cn/20190719144319621.png" alt=""/></p>

<pre><code>#进入etc目录
cd /etc/
#配置 profile
vim profile
</code></pre>

<p><img src="https://img-blog.csdnimg.cn/20190719145650864.png?x-oss-process=image%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1%2Csize_16%2Ccolor_FFFFFF%2Ct_70" alt=""/>
在此文件夹下加入上图的代码，代码如下：</p>

<pre><code>// 设置go安装路径
export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin
 
// 设置工程目录
export GOPATH=/usr/workspace
export PATH=$PATH:$GOPATH/bin
</code></pre>

<h2>（5）刷新环境变量：</h2>

<pre><code>source /etc/profile
</code></pre>

<h2> （6）查看go环境是否配置成功：</h2>

<pre><code>go version
</code></pre>

<h2>（7）查看详细配置：</h2>

<pre><code>go env
</code></pre>

<p>结果如下：  
<img src="https://img-blog.csdnimg.cn/20190719145255720.png?x-oss-process=image%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1%2Csize_16%2Ccolor_FFFFFF%2Ct_70" alt=""/> </p>

<h1>3.上传项目代码：</h1>

<p>在刚刚创建的workspace下新创建的三个文件夹中，src 目录存放的是我们的go源代码</p>

<h1>4运行</h1>

<pre><code class="language-go">go build main.go
//或者
go run main.go
</code></pre>

<p>最后执行 ./main 就行了。
如果想让项目在后台执行：执行 nohup ./main &amp; ，这样就可以程序在后台运行了。</p>

<p>参考教程<a href="https://blog.csdn.net/qq_42410605/article/details/96479892" rel="nofollow">https://blog.csdn.net/qq_42410605/article/details/96479892</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:21:07][0m  [36;1m[0.29ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-21 00:21:07][0m  [36;1m[0.38ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 1)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-21 00:21:07][0m  [36;1m[0.37ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 2)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-21 00:21:07][0m  [36;1m[0.30ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 4)  
[36;31m[0 rows affected or returned ][0m 
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-21 00:21:07][0m  [36;1m[0.35ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 3)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-21 00:21:07][0m  [36;1m[0.31ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 5)  
[36;31m[0 rows affected or returned ][0m 
[{5 1 3 like 狗科 535889315@qq.com /static/images/header.jpg ？？？ 2020-07-20 13:30:17 <nil> []}]
[{5 1 3 like 狗科 535889315@qq.com /static/images/header.jpg ？？？ 2020-07-20 13:30:17 <nil> []}]

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:21:17][0m  [36;1m[0.57ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 00:21:17][0m  [36;1m[0.74ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 00:21:17][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 00:21:17][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 00:21:17][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 00:21:17][0m  [36;1m[0.34ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-21 00:21:19][0m  [36;1m[0.40ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 4)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-21 00:21:19][0m  [36;1m[0.44ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=4  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-21 00:21:19][0m  [36;1m[0.49ms][0m  UPDATE `blogs` SET `title` = '本博客开源公告', `content` = '今天本博客评论功能发布
# 自今天起，本博客基本功能已经完成
## 发布V1.0版本并开源
## 博客语言说明
#### 本博客后端是用golang 的gin框架+gorm编写
前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的
#### 博客效果参考本站
#一、博客简介
## 1.博客目录

    blog
    ├────controller
	├────└───admin
	|	|	├──adminblog.go
	|	|	├───adminController.go
	|	|	├──adminTag.go
	|	|	├──adminType.go
	|	|	└──adminUser.go
	|	└──page
	|		├──404.go
	|		├───about.go
	|		├──archives.go
	|		├──blog.go
	|		├──comment.go
	|		├──pagesController.go
	|		├──researchController.go
	|		└──tagsController.go
    ├── dao
	│	├──blogs.go
	│	├──comment.go
	│	├──sql.go
	│	├──tags.go
	│	├──types.go
	│	└──user.go
    ├── logic
    │   └── user.go
    ├── middlerware
	│	├──function.go
	│	├──getImg.go
	│	├──getTime.go
	│	├──markdown.go
	│	├──select.go
	│	└──session.go
    ├── model
	│	├──blog.go
	│	├──commnent.go
	│	├──tag.go
	│	├──type.go
	│	└──user/go
    ├── static
	│	└──静态文件（头像、图片、logo、css、js等）
    ├── templates
	│	└──html模板文件
    ├── go.mod（依赖）
    └── main.go
    

## 2.相关功能实现简介
### 1、评论及回复功能
comment的结构体属性如下
```go
package model

type Comment struct {
	Id     int //评论id
	BlogId int //博文id
	ReCommentId    int    //父评论id
	CommentName string //评论人姓名
	ReCommentName  string //父评论人姓名
	CommentEmail   string
	Img            string
	CommentContent string `gorm:"type:text" form:"CommentContent" json:"CommentContent"` //评论内容
	CommentTime    string ` json:"comment_time,omitempty"`
	Parent         *Comment
	Comments       []Comment
}
```
#### 实现方法
##### 1先通过查找父评论为-1的顶级评论
父评论Id为-1说明他不是任何评论的子评论
##### 2在html上遍历所有的顶级评论
在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论
###### （1）递归存储每个顶级评论的子评论
这里我用一个切片来储存一个顶级评论的所有子评论
```go
var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
	var comments []model.Comment
	DB.Debug().Where("re_comment_id = -1 AND blog_id = ?", id).Find(&comments)
	return &comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
	if count != 0 {
		fmt.Println("if判断1")
		var comments []model.Comment
		DB.Debug().Where("re_comment_id = ?", id).Find(&comments)
		count = len(comments)
		if count != 0 {
			fmt.Println("if判断2")
			for _, comment := range comments {
				fmt.Println("for判断1")
				Comments = append(Comments, comment)
				SelectCommentByComment(comment.Id, count)
			}
		}
	}
	fmt.Println(Comments)
	return &Comments

}
```
ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来
###### （2）出现问题的原因
因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量
###### （3）解决问题
```go
func ClearComments() bool {
	var comments []model.Comment
	Comments = comments
	return true
}

```
这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现
#### 这里我还加了一个小小的随机头像功能
```go
if  CommentName == user.Name && CommentEmail == user.UserEmail {
		fmt.Println("进入了1")
		comment.Img =user.UserImg
		//找相同评论人
	}else if CommentName == one.CommentName && CommentEmail == one.CommentEmail {
		fmt.Println("进入了2")
		comment.Img =one.Img
		//随机选头像
	}else{
		fmt.Println("进入了3")
		comment.Img =middleware.GetImg()
	}
```
##### 123分别代表三种不同的用户群体
1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
![](/static/images/%e5%a4%b4%e5%83%8f1.png)![](/static/images/%e5%a4%b4%e5%83%8f2.png)![](/static/images/%e5%a4%b4%e5%83%8f3.png)![](/static/images/%e5%a4%b4%e5%83%8f4.png)![](/static/images/%e5%a4%b4%e5%83%8f5.png)![](/static/images/%e5%a4%b4%e5%83%8f6.png)
### 2、归档功能
#### blog的结构体属性如下
```go
package model

type Blog struct {
	Id           int
	Title        string    `form:"title" json:"title"`                          //标题
	Content      string    `gorm:"type:longtext" form:"content" json:"content"` //内容
	Image        string    `gorm:"type:text" form:"image" json:"image"`         //首图
	Numb         int       `form:"numb" json:"numb"`                            //次数
	Flag         string    `form:"flag" json:"flag"`                            //原创或者转载
	Appreciation string    `form:"appreciation" json:"appreciation"`            //打赏开关
	ShareInfo    string    `form:"shareInfo" json:"shareInfo"`                  //版权开关
	Comment      string    `form:"comment" json:"comment"`                      //评论开关
	Recommend    string    `form:"recommend" json:"recommend"`                  //推荐开关
	Description  string    `gorm:"type:text" form:"description" json:"description"`
	CreatTime    string    `form:"creatTime"  json:"creat_time,omitempty"`   //创建时间
	UpdateTime   string    `form:"updateTime"  json:"update_time,omitempty"` //更新时间
	Comments     []Comment `form:"comments" json:"comments"`
	TypeId       int       `form:"typeId" json:"typeId"`
	Type         Type      `form:"type" gorm:"ForeignKey:TypeId"`
	Year         int       `form:"year" json:"year"`
	Month        int       `form:"month" json:"month"`
	Day          int       `form:"day" json:"day"`
}

```
#### 实现方法
我的思路是创建三个时间节点
year month day 
利用sql分组查询
##### Group By分组查询步骤
###### （1）先按照年份查询
###### （2）再按照年份遍历每个月份
并将所有保存在一个切片中
###### （3）按照月份遍历每个月的所有文章
保存在一个Map中，key是对应的月份，value是每个月份的所有文章
#### 自此归档功能实现


## 3.已知BUG
### 后台退出功能
后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧

开源地址
[github](https://github.com/likewl/blog "github")
[gitee](https://gitee.com/nculike/blog "gitee")', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1535821573,4166447487&fm=26&gp=0.jpg', `numb` = 31, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '本博客后端是用golang 的gin框架+gorm编写', `creat_time` = '2020-07-20 15:24:23', `update_time` = '2020-07-20 15:24:23', `type_id` = 4, `year` = 2020, `month` = 7, `day` = 20  WHERE `blogs`.`id` = 4  
[36;31m[1 rows affected or returned ][0m 
<p>今天本博客评论功能发布</p>

<h1>自今天起，本博客基本功能已经完成</h1>

<h2>发布V1.0版本并开源</h2>

<h2>博客语言说明</h2>

<h4>本博客后端是用golang 的gin框架+gorm编写</h4>

<p>前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的</p>

<h4>博客效果参考本站</h4>

<p>#一、博客简介</p>

<h2>1.博客目录</h2>

<pre><code>blog
├────controller
├────└───admin
|   |   ├──adminblog.go
|   |   ├───adminController.go
|   |   ├──adminTag.go
|   |   ├──adminType.go
|   |   └──adminUser.go
|   └──page
|       ├──404.go
|       ├───about.go
|       ├──archives.go
|       ├──blog.go
|       ├──comment.go
|       ├──pagesController.go
|       ├──researchController.go
|       └──tagsController.go
├── dao
│   ├──blogs.go
│   ├──comment.go
│   ├──sql.go
│   ├──tags.go
│   ├──types.go
│   └──user.go
├── logic
│   └── user.go
├── middlerware
│   ├──function.go
│   ├──getImg.go
│   ├──getTime.go
│   ├──markdown.go
│   ├──select.go
│   └──session.go
├── model
│   ├──blog.go
│   ├──commnent.go
│   ├──tag.go
│   ├──type.go
│   └──user/go
├── static
│   └──静态文件（头像、图片、logo、css、js等）
├── templates
│   └──html模板文件
├── go.mod（依赖）
└── main.go
</code></pre>

<h2>2.相关功能实现简介</h2>

<h3>1、评论及回复功能</h3>

<p>comment的结构体属性如下</p>

<pre><code class="language-go">package model

type Comment struct {
    Id     int //评论id
    BlogId int //博文id
    ReCommentId    int    //父评论id
    CommentName string //评论人姓名
    ReCommentName  string //父评论人姓名
    CommentEmail   string
    Img            string
    CommentContent string `gorm:&#34;type:text&#34; form:&#34;CommentContent&#34; json:&#34;CommentContent&#34;` //评论内容
    CommentTime    string ` json:&#34;comment_time,omitempty&#34;`
    Parent         *Comment
    Comments       []Comment
}
</code></pre>

<h4>实现方法</h4>

<h5>1先通过查找父评论为-1的顶级评论</h5>

<p>父评论Id为-1说明他不是任何评论的子评论</p>

<h5>2在html上遍历所有的顶级评论</h5>

<p>在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论</p>

<h6>（1）递归存储每个顶级评论的子评论</h6>

<p>这里我用一个切片来储存一个顶级评论的所有子评论</p>

<pre><code class="language-go">var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
    var comments []model.Comment
    DB.Debug().Where(&#34;re_comment_id = -1 AND blog_id = ?&#34;, id).Find(&amp;comments)
    return &amp;comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
    if count != 0 {
        fmt.Println(&#34;if判断1&#34;)
        var comments []model.Comment
        DB.Debug().Where(&#34;re_comment_id = ?&#34;, id).Find(&amp;comments)
        count = len(comments)
        if count != 0 {
            fmt.Println(&#34;if判断2&#34;)
            for _, comment := range comments {
                fmt.Println(&#34;for判断1&#34;)
                Comments = append(Comments, comment)
                SelectCommentByComment(comment.Id, count)
            }
        }
    }
    fmt.Println(Comments)
    return &amp;Comments

}
</code></pre>

<p>ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来</p>

<h6>（2）出现问题的原因</h6>

<p>因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量</p>

<h6>（3）解决问题</h6>

<pre><code class="language-go">func ClearComments() bool {
    var comments []model.Comment
    Comments = comments
    return true
}

</code></pre>

<p>这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现</p>

<h4>这里我还加了一个小小的随机头像功能</h4>

<pre><code class="language-go">if  CommentName == user.Name &amp;&amp; CommentEmail == user.UserEmail {
        fmt.Println(&#34;进入了1&#34;)
        comment.Img =user.UserImg
        //找相同评论人
    }else if CommentName == one.CommentName &amp;&amp; CommentEmail == one.CommentEmail {
        fmt.Println(&#34;进入了2&#34;)
        comment.Img =one.Img
        //随机选头像
    }else{
        fmt.Println(&#34;进入了3&#34;)
        comment.Img =middleware.GetImg()
    }
</code></pre>

<h5>123分别代表三种不同的用户群体</h5>

<p>1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
<img src="/static/images/%e5%a4%b4%e5%83%8f1.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f2.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f3.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f4.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f5.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f6.png" alt=""/></p>

<h3>2、归档功能</h3>

<h4>blog的结构体属性如下</h4>

<pre><code class="language-go">package model

type Blog struct {
    Id           int
    Title        string    `form:&#34;title&#34; json:&#34;title&#34;`                          //标题
    Content      string    `gorm:&#34;type:longtext&#34; form:&#34;content&#34; json:&#34;content&#34;` //内容
    Image        string    `gorm:&#34;type:text&#34; form:&#34;image&#34; json:&#34;image&#34;`         //首图
    Numb         int       `form:&#34;numb&#34; json:&#34;numb&#34;`                            //次数
    Flag         string    `form:&#34;flag&#34; json:&#34;flag&#34;`                            //原创或者转载
    Appreciation string    `form:&#34;appreciation&#34; json:&#34;appreciation&#34;`            //打赏开关
    ShareInfo    string    `form:&#34;shareInfo&#34; json:&#34;shareInfo&#34;`                  //版权开关
    Comment      string    `form:&#34;comment&#34; json:&#34;comment&#34;`                      //评论开关
    Recommend    string    `form:&#34;recommend&#34; json:&#34;recommend&#34;`                  //推荐开关
    Description  string    `gorm:&#34;type:text&#34; form:&#34;description&#34; json:&#34;description&#34;`
    CreatTime    string    `form:&#34;creatTime&#34;  json:&#34;creat_time,omitempty&#34;`   //创建时间
    UpdateTime   string    `form:&#34;updateTime&#34;  json:&#34;update_time,omitempty&#34;` //更新时间
    Comments     []Comment `form:&#34;comments&#34; json:&#34;comments&#34;`
    TypeId       int       `form:&#34;typeId&#34; json:&#34;typeId&#34;`
    Type         Type      `form:&#34;type&#34; gorm:&#34;ForeignKey:TypeId&#34;`
    Year         int       `form:&#34;year&#34; json:&#34;year&#34;`
    Month        int       `form:&#34;month&#34; json:&#34;month&#34;`
    Day          int       `form:&#34;day&#34; json:&#34;day&#34;`
}

</code></pre>

<h4>实现方法</h4>

<p>我的思路是创建三个时间节点
year month day
利用sql分组查询</p>

<h5>Group By分组查询步骤</h5>

<h6>（1）先按照年份查询</h6>

<h6>（2）再按照年份遍历每个月份</h6>

<p>并将所有保存在一个切片中</p>

<h6>（3）按照月份遍历每个月的所有文章</h6>

<p>保存在一个Map中，key是对应的月份，value是每个月份的所有文章</p>

<h4>自此归档功能实现</h4>

<h2>3.已知BUG</h2>

<h3>后台退出功能</h3>

<p>后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧</p>

<p>开源地址
<a href="https://github.com/likewl/blog" title="github" rel="nofollow">github</a>
<a href="https://gitee.com/nculike/blog" title="gitee" rel="nofollow">gitee</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:21:19][0m  [36;1m[0.28ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-21 00:21:29][0m  [36;1m[0.59ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:21:29][0m  [36;1m[0.25ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 00:21:29][0m  [36;1m[0.78ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-21 00:21:29][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-21 00:21:31][0m  [36;1m[0.58ms][0m  SELECT * FROM `tags`    
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:21:31][0m  [36;1m[0.27ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 00:21:31][0m  [36;1m[0.69ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:31)[0m 
[33m[2020-07-21 00:21:31][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `tags`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:21:32][0m  [36;1m[0.56ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 00:21:32][0m  [36;1m[0.22ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:137)[0m 
[33m[2020-07-21 00:21:32][0m  [36;1m[0.61ms][0m   SELECT * FROM `blogs` GROUP BY YEAR DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:150)[0m 
[33m[2020-07-21 00:21:32][0m  [36;1m[0.69ms][0m   SELECT * FROM `blogs` where year = 2020 GROUP BY month DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:162)[0m 
[33m[2020-07-21 00:21:32][0m  [36;1m[0.66ms][0m   SELECT * FROM `blogs` where year = 2020 and month = 7 ORDER BY `id` DESC  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 00:21:32][0m  [36;1m[0.40ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=4  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 00:21:32][0m  [36;1m[0.38ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=3  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 00:21:32][0m  [36;1m[0.34ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=2  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 00:21:32][0m  [36;1m[0.36ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=1  
[36;31m[1 rows affected or returned ][0m 
[GIN-debug] redirecting request 301: /admin/ --> /admin/
中间件开始校验
admin 获取user
admin 校验正确
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:21:36][0m  [36;1m[0.52ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
[GIN-debug] redirecting request 301: /admin/blog/ --> /admin/blog/
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:21:37][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:38)[0m 
[33m[2020-07-21 00:21:37][0m  [36;1m[0.48ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.recommend,blogs.update_time FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 
&[{4 本博客开源公告 0 博客公告 是 2020-07-20 15:24:23} {3 解决Linux关闭终端后运行的程序自动停止 0 linux 是 2020-07-19 19:05:36} {2 mysql5.7 查询数据，group by 报错：Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 't.id' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by？ 0 mysql 是 2020-07-19 18:59:30} {1 golang项目简单服务器部署到阿里云(linux) 0 go 是 2020-07-20 13:11:56}]
4 ceshi

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-21 00:21:37][0m  [36;1m[0.23ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 
0
[GIN-debug] redirecting request 301: /admin/type/ --> /admin/type/
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:21:37][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-21 00:21:37][0m  [36;1m[0.26ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:21:38][0m  [36;1m[0.59ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:21:39][0m  [36;1m[0.74ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:21:43][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:16)[0m 
[33m[2020-07-21 00:21:43][0m  [36;1m[0.48ms][0m  UPDATE `types` SET `type_name` = '公告'  WHERE (id = 4)  
[36;31m[1 rows affected or returned ][0m 
[GIN-debug] redirecting request 301: /admin/type/ --> /admin/type/
中间件开始校验
admin 获取user
admin 校验正确

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:21:43][0m  [36;1m[0.63ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-21 00:21:43][0m  [36;1m[0.25ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 
[GIN-debug] redirecting request 301: /types --> /types

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-21 00:21:49][0m  [36;1m[0.59ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:21:49][0m  [36;1m[0.25ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 00:21:49][0m  [36;1m[0.66ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-21 00:21:49][0m  [36;1m[0.18ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:21:51][0m  [36;1m[0.61ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-21 00:21:51][0m  [36;1m[0.24ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-21 00:21:51][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/types.go:52)[0m 
[33m[2020-07-21 00:21:51][0m  [36;1m[0.46ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id WHERE (type_id = 4) ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-21 00:21:52][0m  [36;1m[0.38ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 4)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-21 00:21:52][0m  [36;1m[0.43ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=4  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-21 00:21:52][0m  [36;1m[0.43ms][0m  UPDATE `blogs` SET `title` = '本博客开源公告', `content` = '今天本博客评论功能发布
# 自今天起，本博客基本功能已经完成
## 发布V1.0版本并开源
## 博客语言说明
#### 本博客后端是用golang 的gin框架+gorm编写
前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的
#### 博客效果参考本站
#一、博客简介
## 1.博客目录

    blog
    ├────controller
	├────└───admin
	|	|	├──adminblog.go
	|	|	├───adminController.go
	|	|	├──adminTag.go
	|	|	├──adminType.go
	|	|	└──adminUser.go
	|	└──page
	|		├──404.go
	|		├───about.go
	|		├──archives.go
	|		├──blog.go
	|		├──comment.go
	|		├──pagesController.go
	|		├──researchController.go
	|		└──tagsController.go
    ├── dao
	│	├──blogs.go
	│	├──comment.go
	│	├──sql.go
	│	├──tags.go
	│	├──types.go
	│	└──user.go
    ├── logic
    │   └── user.go
    ├── middlerware
	│	├──function.go
	│	├──getImg.go
	│	├──getTime.go
	│	├──markdown.go
	│	├──select.go
	│	└──session.go
    ├── model
	│	├──blog.go
	│	├──commnent.go
	│	├──tag.go
	│	├──type.go
	│	└──user/go
    ├── static
	│	└──静态文件（头像、图片、logo、css、js等）
    ├── templates
	│	└──html模板文件
    ├── go.mod（依赖）
    └── main.go
    

## 2.相关功能实现简介
### 1、评论及回复功能
comment的结构体属性如下
```go
package model

type Comment struct {
	Id     int //评论id
	BlogId int //博文id
	ReCommentId    int    //父评论id
	CommentName string //评论人姓名
	ReCommentName  string //父评论人姓名
	CommentEmail   string
	Img            string
	CommentContent string `gorm:"type:text" form:"CommentContent" json:"CommentContent"` //评论内容
	CommentTime    string ` json:"comment_time,omitempty"`
	Parent         *Comment
	Comments       []Comment
}
```
#### 实现方法
##### 1先通过查找父评论为-1的顶级评论
父评论Id为-1说明他不是任何评论的子评论
##### 2在html上遍历所有的顶级评论
在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论
###### （1）递归存储每个顶级评论的子评论
这里我用一个切片来储存一个顶级评论的所有子评论
```go
var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
	var comments []model.Comment
	DB.Debug().Where("re_comment_id = -1 AND blog_id = ?", id).Find(&comments)
	return &comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
	if count != 0 {
		fmt.Println("if判断1")
		var comments []model.Comment
		DB.Debug().Where("re_comment_id = ?", id).Find(&comments)
		count = len(comments)
		if count != 0 {
			fmt.Println("if判断2")
			for _, comment := range comments {
				fmt.Println("for判断1")
				Comments = append(Comments, comment)
				SelectCommentByComment(comment.Id, count)
			}
		}
	}
	fmt.Println(Comments)
	return &Comments

}
```
ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来
###### （2）出现问题的原因
因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量
###### （3）解决问题
```go
func ClearComments() bool {
	var comments []model.Comment
	Comments = comments
	return true
}

```
这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现
#### 这里我还加了一个小小的随机头像功能
```go
if  CommentName == user.Name && CommentEmail == user.UserEmail {
		fmt.Println("进入了1")
		comment.Img =user.UserImg
		//找相同评论人
	}else if CommentName == one.CommentName && CommentEmail == one.CommentEmail {
		fmt.Println("进入了2")
		comment.Img =one.Img
		//随机选头像
	}else{
		fmt.Println("进入了3")
		comment.Img =middleware.GetImg()
	}
```
##### 123分别代表三种不同的用户群体
1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
![](/static/images/%e5%a4%b4%e5%83%8f1.png)![](/static/images/%e5%a4%b4%e5%83%8f2.png)![](/static/images/%e5%a4%b4%e5%83%8f3.png)![](/static/images/%e5%a4%b4%e5%83%8f4.png)![](/static/images/%e5%a4%b4%e5%83%8f5.png)![](/static/images/%e5%a4%b4%e5%83%8f6.png)
### 2、归档功能
#### blog的结构体属性如下
```go
package model

type Blog struct {
	Id           int
	Title        string    `form:"title" json:"title"`                          //标题
	Content      string    `gorm:"type:longtext" form:"content" json:"content"` //内容
	Image        string    `gorm:"type:text" form:"image" json:"image"`         //首图
	Numb         int       `form:"numb" json:"numb"`                            //次数
	Flag         string    `form:"flag" json:"flag"`                            //原创或者转载
	Appreciation string    `form:"appreciation" json:"appreciation"`            //打赏开关
	ShareInfo    string    `form:"shareInfo" json:"shareInfo"`                  //版权开关
	Comment      string    `form:"comment" json:"comment"`                      //评论开关
	Recommend    string    `form:"recommend" json:"recommend"`                  //推荐开关
	Description  string    `gorm:"type:text" form:"description" json:"description"`
	CreatTime    string    `form:"creatTime"  json:"creat_time,omitempty"`   //创建时间
	UpdateTime   string    `form:"updateTime"  json:"update_time,omitempty"` //更新时间
	Comments     []Comment `form:"comments" json:"comments"`
	TypeId       int       `form:"typeId" json:"typeId"`
	Type         Type      `form:"type" gorm:"ForeignKey:TypeId"`
	Year         int       `form:"year" json:"year"`
	Month        int       `form:"month" json:"month"`
	Day          int       `form:"day" json:"day"`
}

```
#### 实现方法
我的思路是创建三个时间节点
year month day 
利用sql分组查询
##### Group By分组查询步骤
###### （1）先按照年份查询
###### （2）再按照年份遍历每个月份
并将所有保存在一个切片中
###### （3）按照月份遍历每个月的所有文章
保存在一个Map中，key是对应的月份，value是每个月份的所有文章
#### 自此归档功能实现


## 3.已知BUG
### 后台退出功能
后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧

开源地址
[github](https://github.com/likewl/blog "github")
[gitee](https://gitee.com/nculike/blog "gitee")', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1535821573,4166447487&fm=26&gp=0.jpg', `numb` = 32, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '本博客后端是用golang 的gin框架+gorm编写', `creat_time` = '2020-07-20 15:24:23', `update_time` = '2020-07-20 15:24:23', `type_id` = 4, `year` = 2020, `month` = 7, `day` = 20  WHERE `blogs`.`id` = 4  
[36;31m[1 rows affected or returned ][0m 
<p>今天本博客评论功能发布</p>

<h1>自今天起，本博客基本功能已经完成</h1>

<h2>发布V1.0版本并开源</h2>

<h2>博客语言说明</h2>

<h4>本博客后端是用golang 的gin框架+gorm编写</h4>

<p>前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的</p>

<h4>博客效果参考本站</h4>

<p>#一、博客简介</p>

<h2>1.博客目录</h2>

<pre><code>blog
├────controller
├────└───admin
|   |   ├──adminblog.go
|   |   ├───adminController.go
|   |   ├──adminTag.go
|   |   ├──adminType.go
|   |   └──adminUser.go
|   └──page
|       ├──404.go
|       ├───about.go
|       ├──archives.go
|       ├──blog.go
|       ├──comment.go
|       ├──pagesController.go
|       ├──researchController.go
|       └──tagsController.go
├── dao
│   ├──blogs.go
│   ├──comment.go
│   ├──sql.go
│   ├──tags.go
│   ├──types.go
│   └──user.go
├── logic
│   └── user.go
├── middlerware
│   ├──function.go
│   ├──getImg.go
│   ├──getTime.go
│   ├──markdown.go
│   ├──select.go
│   └──session.go
├── model
│   ├──blog.go
│   ├──commnent.go
│   ├──tag.go
│   ├──type.go
│   └──user/go
├── static
│   └──静态文件（头像、图片、logo、css、js等）
├── templates
│   └──html模板文件
├── go.mod（依赖）
└── main.go
</code></pre>

<h2>2.相关功能实现简介</h2>

<h3>1、评论及回复功能</h3>

<p>comment的结构体属性如下</p>

<pre><code class="language-go">package model

type Comment struct {
    Id     int //评论id
    BlogId int //博文id
    ReCommentId    int    //父评论id
    CommentName string //评论人姓名
    ReCommentName  string //父评论人姓名
    CommentEmail   string
    Img            string
    CommentContent string `gorm:&#34;type:text&#34; form:&#34;CommentContent&#34; json:&#34;CommentContent&#34;` //评论内容
    CommentTime    string ` json:&#34;comment_time,omitempty&#34;`
    Parent         *Comment
    Comments       []Comment
}
</code></pre>

<h4>实现方法</h4>

<h5>1先通过查找父评论为-1的顶级评论</h5>

<p>父评论Id为-1说明他不是任何评论的子评论</p>

<h5>2在html上遍历所有的顶级评论</h5>

<p>在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论</p>

<h6>（1）递归存储每个顶级评论的子评论</h6>

<p>这里我用一个切片来储存一个顶级评论的所有子评论</p>

<pre><code class="language-go">var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
    var comments []model.Comment
    DB.Debug().Where(&#34;re_comment_id = -1 AND blog_id = ?&#34;, id).Find(&amp;comments)
    return &amp;comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
    if count != 0 {
        fmt.Println(&#34;if判断1&#34;)
        var comments []model.Comment
        DB.Debug().Where(&#34;re_comment_id = ?&#34;, id).Find(&amp;comments)
        count = len(comments)
        if count != 0 {
            fmt.Println(&#34;if判断2&#34;)
            for _, comment := range comments {
                fmt.Println(&#34;for判断1&#34;)
                Comments = append(Comments, comment)
                SelectCommentByComment(comment.Id, count)
            }
        }
    }
    fmt.Println(Comments)
    return &amp;Comments

}
</code></pre>

<p>ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来</p>

<h6>（2）出现问题的原因</h6>

<p>因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量</p>

<h6>（3）解决问题</h6>

<pre><code class="language-go">func ClearComments() bool {
    var comments []model.Comment
    Comments = comments
    return true
}

</code></pre>

<p>这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现</p>

<h4>这里我还加了一个小小的随机头像功能</h4>

<pre><code class="language-go">if  CommentName == user.Name &amp;&amp; CommentEmail == user.UserEmail {
        fmt.Println(&#34;进入了1&#34;)
        comment.Img =user.UserImg
        //找相同评论人
    }else if CommentName == one.CommentName &amp;&amp; CommentEmail == one.CommentEmail {
        fmt.Println(&#34;进入了2&#34;)
        comment.Img =one.Img
        //随机选头像
    }else{
        fmt.Println(&#34;进入了3&#34;)
        comment.Img =middleware.GetImg()
    }
</code></pre>

<h5>123分别代表三种不同的用户群体</h5>

<p>1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
<img src="/static/images/%e5%a4%b4%e5%83%8f1.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f2.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f3.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f4.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f5.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f6.png" alt=""/></p>

<h3>2、归档功能</h3>

<h4>blog的结构体属性如下</h4>

<pre><code class="language-go">package model

type Blog struct {
    Id           int
    Title        string    `form:&#34;title&#34; json:&#34;title&#34;`                          //标题
    Content      string    `gorm:&#34;type:longtext&#34; form:&#34;content&#34; json:&#34;content&#34;` //内容
    Image        string    `gorm:&#34;type:text&#34; form:&#34;image&#34; json:&#34;image&#34;`         //首图
    Numb         int       `form:&#34;numb&#34; json:&#34;numb&#34;`                            //次数
    Flag         string    `form:&#34;flag&#34; json:&#34;flag&#34;`                            //原创或者转载
    Appreciation string    `form:&#34;appreciation&#34; json:&#34;appreciation&#34;`            //打赏开关
    ShareInfo    string    `form:&#34;shareInfo&#34; json:&#34;shareInfo&#34;`                  //版权开关
    Comment      string    `form:&#34;comment&#34; json:&#34;comment&#34;`                      //评论开关
    Recommend    string    `form:&#34;recommend&#34; json:&#34;recommend&#34;`                  //推荐开关
    Description  string    `gorm:&#34;type:text&#34; form:&#34;description&#34; json:&#34;description&#34;`
    CreatTime    string    `form:&#34;creatTime&#34;  json:&#34;creat_time,omitempty&#34;`   //创建时间
    UpdateTime   string    `form:&#34;updateTime&#34;  json:&#34;update_time,omitempty&#34;` //更新时间
    Comments     []Comment `form:&#34;comments&#34; json:&#34;comments&#34;`
    TypeId       int       `form:&#34;typeId&#34; json:&#34;typeId&#34;`
    Type         Type      `form:&#34;type&#34; gorm:&#34;ForeignKey:TypeId&#34;`
    Year         int       `form:&#34;year&#34; json:&#34;year&#34;`
    Month        int       `form:&#34;month&#34; json:&#34;month&#34;`
    Day          int       `form:&#34;day&#34; json:&#34;day&#34;`
}

</code></pre>

<h4>实现方法</h4>

<p>我的思路是创建三个时间节点
year month day
利用sql分组查询</p>

<h5>Group By分组查询步骤</h5>

<h6>（1）先按照年份查询</h6>

<h6>（2）再按照年份遍历每个月份</h6>

<p>并将所有保存在一个切片中</p>

<h6>（3）按照月份遍历每个月的所有文章</h6>

<p>保存在一个Map中，key是对应的月份，value是每个月份的所有文章</p>

<h4>自此归档功能实现</h4>

<h2>3.已知BUG</h2>

<h3>后台退出功能</h3>

<p>后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧</p>

<p>开源地址
<a href="https://github.com/likewl/blog" title="github" rel="nofollow">github</a>
<a href="https://gitee.com/nculike/blog" title="gitee" rel="nofollow">gitee</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:21:52][0m  [36;1m[0.33ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:22:34][0m  [36;1m[0.57ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 00:22:34][0m  [36;1m[0.73ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 00:22:34][0m  [36;1m[0.23ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 00:22:34][0m  [36;1m[0.35ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 00:22:34][0m  [36;1m[0.27ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 00:22:34][0m  [36;1m[0.36ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:25:39][0m  [36;1m[0.49ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 00:25:39][0m  [36;1m[0.68ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 00:25:39][0m  [36;1m[0.22ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 00:25:39][0m  [36;1m[0.31ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 00:25:39][0m  [36;1m[0.28ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 00:25:39][0m  [36;1m[0.32ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:25:40][0m  [36;1m[0.57ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 00:25:40][0m  [36;1m[0.69ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 00:25:40][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 00:25:40][0m  [36;1m[0.29ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 00:25:40][0m  [36;1m[0.29ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 00:25:40][0m  [36;1m[0.36ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 
[GIN-debug] [WARNING] Running in "debug" mode. Switch to "release" mode in production.
 - using env:	export GIN_MODE=release
 - using code:	gin.SetMode(gin.ReleaseMode)

[GIN-debug] GET    /static/*filepath         --> github.com/gin-gonic/gin.(*RouterGroup).createStaticHandler.func1 (2 handlers)
[GIN-debug] HEAD   /static/*filepath         --> github.com/gin-gonic/gin.(*RouterGroup).createStaticHandler.func1 (2 handlers)
[GIN-debug] Loaded HTML Templates (30): 
	- pages/index.html
	- admin/tags.html
	- types-input.html
	- 404.html
	- footer1.html
	- footer1
	- header
	- tags-input.html
	- types-edit.html
	- login.html
	- type.html
	- index.html
	- tags-edit.html
	- header1.html
	- blogs-input.html
	- blog.html
	- archives.html
	- 
	- admin/types.html
	- user-edit.html
	- header1
	- tag.html
	- blogs-edit.html
	- header.html
	- admin/index.html
	- about.html
	- research.html
	- blogs.html
	- tags.html
	- types.html

[GIN-debug] GET    /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] POST   /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] PUT    /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] PATCH  /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] HEAD   /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] OPTIONS /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] DELETE /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] CONNECT /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] TRACE  /                         --> blog/controller/page.IndexHandler (2 handlers)
[GIN-debug] GET    /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] POST   /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] PUT    /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] PATCH  /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] HEAD   /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] OPTIONS /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] DELETE /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] CONNECT /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] TRACE  /research                 --> blog/controller/page.ResearchHandler (2 handlers)
[GIN-debug] GET    /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] POST   /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] PUT    /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] PATCH  /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] HEAD   /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] OPTIONS /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] DELETE /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] CONNECT /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] TRACE  /blogs/page/:page         --> blog/controller/page.PagesHandler (2 handlers)
[GIN-debug] GET    /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] POST   /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] PUT    /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] PATCH  /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] HEAD   /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] OPTIONS /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] DELETE /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] CONNECT /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] TRACE  /comments                 --> blog/controller/page.CommentHandler (2 handlers)
[GIN-debug] GET    /types                    --> blog/controller/page.TypesHandler (2 handlers)
[GIN-debug] GET    /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] POST   /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] PUT    /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] PATCH  /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] HEAD   /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] OPTIONS /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] DELETE /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] CONNECT /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] TRACE  /types/:name              --> blog/controller/page.TypesNameHandler (2 handlers)
[GIN-debug] GET    /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] POST   /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] PUT    /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] PATCH  /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] HEAD   /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] OPTIONS /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] DELETE /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] CONNECT /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] TRACE  /types/:name/:id          --> blog/controller/page.BlogHandler (2 handlers)
[GIN-debug] GET    /tags                     --> blog/controller/page.TagsHandler (2 handlers)
[GIN-debug] GET    /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] POST   /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] PUT    /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] PATCH  /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] HEAD   /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] OPTIONS /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] DELETE /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] CONNECT /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] TRACE  /tags/:name               --> blog/controller/page.TagsNameHandler (2 handlers)
[GIN-debug] GET    /archives                 --> blog/controller/page.ArchivesHandler (2 handlers)
[GIN-debug] GET    /about                    --> blog/controller/page.AboutHandler (2 handlers)
[GIN-debug] GET    /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] POST   /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] PUT    /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] PATCH  /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] HEAD   /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] OPTIONS /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] DELETE /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] CONNECT /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] TRACE  /admin/login              --> blog/controller/admin.LoginHandler (2 handlers)
[GIN-debug] GET    /admin/logout             --> blog/controller/admin.LogoutHandler (2 handlers)
[GIN-debug] GET    /admin/                   --> blog/controller/admin.AdminHandler (3 handlers)
[GIN-debug] GET    /admin/index              --> blog/controller/admin.AdminIndexHandler (3 handlers)
[GIN-debug] GET    /admin/type/              --> blog/controller/admin.TypeHandler (3 handlers)
[GIN-debug] GET    /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] POST   /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] PUT    /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] PATCH  /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] HEAD   /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] OPTIONS /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] DELETE /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] CONNECT /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] TRACE  /admin/type/edit          --> blog/controller/admin.TypeEditHandler (3 handlers)
[GIN-debug] GET    /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] POST   /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] PUT    /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] PATCH  /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] HEAD   /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] OPTIONS /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] DELETE /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] CONNECT /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] TRACE  /admin/type/add           --> blog/controller/admin.TypeAddHandler (3 handlers)
[GIN-debug] GET    /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] POST   /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] PUT    /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] PATCH  /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] HEAD   /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] OPTIONS /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] DELETE /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] CONNECT /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] TRACE  /admin/tag/               --> blog/controller/admin.TagHandler (3 handlers)
[GIN-debug] GET    /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] POST   /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] PUT    /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] PATCH  /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] HEAD   /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] OPTIONS /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] DELETE /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] CONNECT /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] TRACE  /admin/tag/edit           --> blog/controller/admin.TagEditHandler (3 handlers)
[GIN-debug] GET    /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] POST   /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] PUT    /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] PATCH  /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] HEAD   /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] OPTIONS /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] DELETE /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] CONNECT /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] TRACE  /admin/tag/add            --> blog/controller/admin.TagAddHandler (3 handlers)
[GIN-debug] GET    /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] POST   /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] PUT    /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] PATCH  /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] HEAD   /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] OPTIONS /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] DELETE /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] CONNECT /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] TRACE  /admin/blog/              --> blog/controller/admin.BlogHandler (3 handlers)
[GIN-debug] GET    /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] POST   /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] PUT    /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] PATCH  /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] HEAD   /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] OPTIONS /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] DELETE /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] CONNECT /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] TRACE  /admin/blog/edit          --> blog/controller/admin.BlogEditHandler (3 handlers)
[GIN-debug] GET    /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] POST   /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] PUT    /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] PATCH  /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] HEAD   /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] OPTIONS /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] DELETE /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] CONNECT /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] TRACE  /admin/blog/add           --> blog/controller/admin.BlogAddHandler (3 handlers)
[GIN-debug] GET    /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] POST   /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] PUT    /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] PATCH  /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] HEAD   /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] OPTIONS /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] DELETE /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] CONNECT /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] TRACE  /admin/user/              --> blog/controller/admin.UserEditHandler (3 handlers)
[GIN-debug] Listening and serving HTTP on :80

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:27:50][0m  [36;1m[0.60ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 00:27:50][0m  [36;1m[0.81ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 00:27:50][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 00:27:50][0m  [36;1m[0.31ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 00:27:50][0m  [36;1m[0.25ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 00:27:50][0m  [36;1m[0.36ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:27:54][0m  [36;1m[0.51ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 00:27:54][0m  [36;1m[0.71ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 00:27:54][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 00:27:54][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 00:27:54][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 00:27:54][0m  [36;1m[0.34ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:27:55][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 00:27:55][0m  [36;1m[0.71ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 00:27:55][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 00:27:55][0m  [36;1m[0.38ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 00:27:55][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 00:27:55][0m  [36;1m[0.33ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:27:57][0m  [36;1m[0.53ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 00:27:57][0m  [36;1m[0.77ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 00:27:57][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 00:27:57][0m  [36;1m[0.32ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 00:27:57][0m  [36;1m[0.25ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 00:27:57][0m  [36;1m[0.34ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:28:13][0m  [36;1m[0.57ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 00:28:13][0m  [36;1m[0.72ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 00:28:13][0m  [36;1m[0.22ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 00:28:13][0m  [36;1m[0.29ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 00:28:13][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 00:28:13][0m  [36;1m[0.37ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:28:16][0m  [36;1m[0.53ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 00:28:16][0m  [36;1m[0.72ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 00:28:16][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 00:28:16][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 00:28:16][0m  [36;1m[0.25ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 00:28:16][0m  [36;1m[0.33ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:28:17][0m  [36;1m[0.58ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 00:28:17][0m  [36;1m[0.80ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 00:28:17][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 00:28:17][0m  [36;1m[0.35ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 00:28:17][0m  [36;1m[0.30ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 00:28:17][0m  [36;1m[0.38ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:28:23][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 00:28:23][0m  [36;1m[0.72ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 00:28:23][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 00:28:23][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 00:28:23][0m  [36;1m[0.34ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 00:28:23][0m  [36;1m[0.40ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:28:34][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:176)[0m 
[33m[2020-07-21 00:28:34][0m  [36;1m[0.55ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id WHERE (title like '%go%') ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 00:28:34][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
1

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 00:28:34][0m  [36;1m[0.34ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 00:28:34][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:121)[0m 
[33m[2020-07-21 00:28:34][0m  [36;1m[0.32ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id WHERE (recommend = '是') ORDER BY blogs.id DESC LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:28:37][0m  [36;1m[0.53ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 00:28:37][0m  [36;1m[0.70ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 00:28:37][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 00:28:37][0m  [36;1m[0.34ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 00:28:37][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 00:28:37][0m  [36;1m[0.33ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-21 00:28:37][0m  [36;1m[0.53ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:28:37][0m  [36;1m[0.32ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 00:28:37][0m  [36;1m[0.69ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-21 00:28:37][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-21 00:28:38][0m  [36;1m[0.57ms][0m  SELECT * FROM `tags`    
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:28:38][0m  [36;1m[0.28ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 00:28:38][0m  [36;1m[0.77ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:31)[0m 
[33m[2020-07-21 00:28:38][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `tags`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:28:39][0m  [36;1m[0.52ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 00:28:39][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:144)[0m 
[33m[2020-07-21 00:28:39][0m  [36;1m[0.59ms][0m   SELECT * FROM `blogs` GROUP BY YEAR DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:157)[0m 
[33m[2020-07-21 00:28:39][0m  [36;1m[0.67ms][0m   SELECT * FROM `blogs` where year = 2020 GROUP BY month DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:169)[0m 
[33m[2020-07-21 00:28:39][0m  [36;1m[0.66ms][0m   SELECT * FROM `blogs` where year = 2020 and month = 7 ORDER BY `id` DESC  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 00:28:39][0m  [36;1m[0.38ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=4  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 00:28:39][0m  [36;1m[0.33ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=3  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 00:28:39][0m  [36;1m[0.36ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=2  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 00:28:39][0m  [36;1m[0.32ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 00:28:39][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 01:35:53][0m  [36;1m[0.51ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 01:35:53][0m  [36;1m[0.77ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 01:35:53][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 01:35:53][0m  [36;1m[0.35ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 01:35:53][0m  [36;1m[0.25ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 01:35:53][0m  [36;1m[0.33ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 01:43:34][0m  [36;1m[0.74ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 01:43:35][0m  [36;1m[0.52ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 01:43:58][0m  [36;1m[0.53ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 01:44:17][0m  [36;1m[0.53ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 03:05:05][0m  [36;1m[0.56ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 03:13:30][0m  [36;1m[0.52ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 03:13:30][0m  [36;1m[0.69ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 03:13:30][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 03:13:30][0m  [36;1m[0.31ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 03:13:30][0m  [36;1m[0.28ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 03:13:30][0m  [36;1m[0.34ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 03:20:23][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
2020/07/21 03:20:23 http: panic serving 123.125.67.160:25269: write tcp 172.16.13.169:80->123.125.67.160:25269: write: broken pipe
goroutine 609 [running]:
net/http.(*conn).serve.func1(0xc0003b65a0)
	/usr/local/go/src/net/http/server.go:1772 +0x139
panic(0xb50ee0, 0xc00037bb80)
	/usr/local/go/src/runtime/panic.go:975 +0x3e3
github.com/gin-gonic/gin.(*Context).Render(0xc0005bc2d0, 0x194, 0xd0e260, 0xc000274e40)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:842 +0x173
github.com/gin-gonic/gin.(*Context).HTML(0xc0005bc2d0, 0x194, 0xbf193d, 0x8, 0xb43d60, 0xc0000de5d0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:851 +0x99
blog/controller/page.NotFoundHandler(0xc0005bc2d0)
	/usr/workspace/src/blog/controller/page/404.go:12 +0x120
github.com/gin-gonic/gin.(*Context).Next(0xc0005bc2d0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:161 +0x3b
github.com/gin-contrib/sessions.Sessions.func1(0xc0005bc2d0)
	/usr/workspace/pkg/mod/github.com/gin-contrib/sessions@v0.0.3/sessions.go:52 +0x16d
github.com/gin-gonic/gin.(*Context).Next(0xc0005bc2d0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:161 +0x3b
github.com/gin-gonic/gin.serveError(0xc0005bc2d0, 0x194, 0x1248dc0, 0x12, 0x12)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/gin.go:445 +0x38
github.com/gin-gonic/gin.(*Engine).handleHTTPRequest(0xc0003b8500, 0xc0005bc2d0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/gin.go:438 +0x3d3
github.com/gin-gonic/gin.(*Engine).ServeHTTP(0xc0003b8500, 0xd12a40, 0xc0000b80e0, 0xc0003ca000)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/gin.go:367 +0x14d
net/http.serverHandler.ServeHTTP(0xc0000b8380, 0xd12a40, 0xc0000b80e0, 0xc0003ca000)
	/usr/local/go/src/net/http/server.go:2807 +0xa3
net/http.(*conn).serve(0xc0003b65a0, 0xd15200, 0xc0003d2000)
	/usr/local/go/src/net/http/server.go:1895 +0x86c
created by net/http.(*Server).Serve
	/usr/local/go/src/net/http/server.go:2933 +0x35c

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 03:26:25][0m  [36;1m[0.60ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 03:26:25][0m  [36;1m[0.75ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 03:26:25][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 03:26:25][0m  [36;1m[0.34ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 03:26:25][0m  [36;1m[0.25ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 03:26:25][0m  [36;1m[0.33ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 
2020/07/21 03:26:25 http: panic serving 216.107.139.39:47705: write tcp 172.16.13.169:80->216.107.139.39:47705: write: broken pipe
goroutine 637 [running]:
net/http.(*conn).serve.func1(0xc0003b66e0)
	/usr/local/go/src/net/http/server.go:1772 +0x139
panic(0xb50ee0, 0xc00037bf40)
	/usr/local/go/src/runtime/panic.go:975 +0x3e3
github.com/gin-gonic/gin.(*Context).Render(0xc0005bc2d0, 0xc8, 0xd0e260, 0xc0002c2960)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:842 +0x173
github.com/gin-gonic/gin.(*Context).HTML(0xc0005bc2d0, 0xc8, 0xbf926d, 0x10, 0xb43d60, 0xc0006561b0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:851 +0x99
blog/controller/page.IndexHandler(0xc0005bc2d0)
	/usr/workspace/src/blog/controller/page/pagesController.go:22 +0x570
github.com/gin-gonic/gin.(*Context).Next(0xc0005bc2d0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:161 +0x3b
github.com/gin-contrib/sessions.Sessions.func1(0xc0005bc2d0)
	/usr/workspace/pkg/mod/github.com/gin-contrib/sessions@v0.0.3/sessions.go:52 +0x16d
github.com/gin-gonic/gin.(*Context).Next(0xc0005bc2d0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:161 +0x3b
github.com/gin-gonic/gin.(*Engine).handleHTTPRequest(0xc0003b8500, 0xc0005bc2d0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/gin.go:409 +0x666
github.com/gin-gonic/gin.(*Engine).ServeHTTP(0xc0003b8500, 0xd12a40, 0xc0000b80e0, 0xc0000f2100)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/gin.go:367 +0x14d
net/http.serverHandler.ServeHTTP(0xc0000b8380, 0xd12a40, 0xc0000b80e0, 0xc0000f2100)
	/usr/local/go/src/net/http/server.go:2807 +0xa3
net/http.(*conn).serve(0xc0003b66e0, 0xd15200, 0xc0001b2100)
	/usr/local/go/src/net/http/server.go:1895 +0x86c
created by net/http.(*Server).Serve
	/usr/local/go/src/net/http/server.go:2933 +0x35c

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 03:52:09][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 03:52:09][0m  [36;1m[0.71ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 03:52:09][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 03:52:09][0m  [36;1m[0.29ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 03:52:09][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 03:52:09][0m  [36;1m[0.31ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 04:43:09][0m  [36;1m[0.58ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 04:43:09][0m  [36;1m[0.70ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 04:43:09][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 04:43:09][0m  [36;1m[0.34ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 04:43:09][0m  [36;1m[0.25ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 04:43:09][0m  [36;1m[0.32ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 
2020/07/21 04:43:09 http: panic serving 47.101.155.38:40092: write tcp 172.16.13.169:80->47.101.155.38:40092: write: broken pipe
goroutine 692 [running]:
net/http.(*conn).serve.func1(0xc0003b65a0)
	/usr/local/go/src/net/http/server.go:1772 +0x139
panic(0xb50ee0, 0xc00037bf40)
	/usr/local/go/src/runtime/panic.go:975 +0x3e3
github.com/gin-gonic/gin.(*Context).Render(0xc0005bc2d0, 0xc8, 0xd0e260, 0xc000294960)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:842 +0x173
github.com/gin-gonic/gin.(*Context).HTML(0xc0005bc2d0, 0xc8, 0xbf926d, 0x10, 0xb43d60, 0xc0000de1b0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:851 +0x99
blog/controller/page.IndexHandler(0xc0005bc2d0)
	/usr/workspace/src/blog/controller/page/pagesController.go:22 +0x570
github.com/gin-gonic/gin.(*Context).Next(0xc0005bc2d0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:161 +0x3b
github.com/gin-contrib/sessions.Sessions.func1(0xc0005bc2d0)
	/usr/workspace/pkg/mod/github.com/gin-contrib/sessions@v0.0.3/sessions.go:52 +0x16d
github.com/gin-gonic/gin.(*Context).Next(0xc0005bc2d0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:161 +0x3b
github.com/gin-gonic/gin.(*Engine).handleHTTPRequest(0xc0003b8500, 0xc0005bc2d0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/gin.go:409 +0x666
github.com/gin-gonic/gin.(*Engine).ServeHTTP(0xc0003b8500, 0xd12a40, 0xc0000b80e0, 0xc0000f2000)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/gin.go:367 +0x14d
net/http.serverHandler.ServeHTTP(0xc0000b8380, 0xd12a40, 0xc0000b80e0, 0xc0000f2000)
	/usr/local/go/src/net/http/server.go:2807 +0xa3
net/http.(*conn).serve(0xc0003b65a0, 0xd15200, 0xc0001b2040)
	/usr/local/go/src/net/http/server.go:1895 +0x86c
created by net/http.(*Server).Serve
	/usr/local/go/src/net/http/server.go:2933 +0x35c

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 05:27:46][0m  [36;1m[0.57ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 05:27:46][0m  [36;1m[0.70ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 05:27:46][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 05:27:46][0m  [36;1m[0.33ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 05:27:46][0m  [36;1m[0.27ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 05:27:46][0m  [36;1m[0.32ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 05:43:39][0m  [36;1m[0.56ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 05:43:39][0m  [36;1m[0.68ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 05:43:39][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 05:43:39][0m  [36;1m[0.29ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 05:43:39][0m  [36;1m[0.28ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 05:43:39][0m  [36;1m[0.32ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 06:07:48][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 06:07:49][0m  [36;1m[0.56ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 06:11:18][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 06:11:18][0m  [36;1m[0.69ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 06:11:18][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 06:11:18][0m  [36;1m[0.32ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 06:11:18][0m  [36;1m[0.25ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 06:11:18][0m  [36;1m[0.34ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 06:12:34][0m  [36;1m[0.53ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 06:12:35][0m  [36;1m[0.52ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 06:24:43][0m  [36;1m[0.56ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 06:24:44][0m  [36;1m[0.59ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 07:02:15][0m  [36;1m[0.57ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 07:02:15][0m  [36;1m[0.72ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 07:02:15][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 07:02:15][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 07:02:15][0m  [36;1m[0.29ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 07:02:15][0m  [36;1m[0.34ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 08:38:58][0m  [36;1m[0.59ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 08:38:58][0m  [36;1m[0.73ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 08:38:58][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 08:38:58][0m  [36;1m[0.32ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 08:38:58][0m  [36;1m[0.27ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 08:38:58][0m  [36;1m[0.33ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:06:46][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:50:25][0m  [36;1m[0.53ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 09:50:25][0m  [36;1m[0.71ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 09:50:25][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 09:50:25][0m  [36;1m[0.32ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 09:50:25][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 09:50:25][0m  [36;1m[0.34ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:50:37][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 09:50:37][0m  [36;1m[0.77ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 09:50:37][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 09:50:37][0m  [36;1m[0.29ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 09:50:37][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 09:50:37][0m  [36;1m[0.31ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 
2020/07/21 09:50:37 http: panic serving 116.238.210.229:49410: write tcp 172.16.13.169:80->116.238.210.229:49410: write: broken pipe
goroutine 1087 [running]:
net/http.(*conn).serve.func1(0xc0003b7ae0)
	/usr/local/go/src/net/http/server.go:1772 +0x139
panic(0xb50ee0, 0xc0001dac30)
	/usr/local/go/src/runtime/panic.go:975 +0x3e3
github.com/gin-gonic/gin.(*Context).Render(0xc0005bc2d0, 0xc8, 0xd0e260, 0xc0006242a0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:842 +0x173
github.com/gin-gonic/gin.(*Context).HTML(0xc0005bc2d0, 0xc8, 0xbf926d, 0x10, 0xb43d60, 0xc0003ade60)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:851 +0x99
blog/controller/page.IndexHandler(0xc0005bc2d0)
	/usr/workspace/src/blog/controller/page/pagesController.go:22 +0x570
github.com/gin-gonic/gin.(*Context).Next(0xc0005bc2d0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:161 +0x3b
github.com/gin-contrib/sessions.Sessions.func1(0xc0005bc2d0)
	/usr/workspace/pkg/mod/github.com/gin-contrib/sessions@v0.0.3/sessions.go:52 +0x16d
github.com/gin-gonic/gin.(*Context).Next(0xc0005bc2d0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:161 +0x3b
github.com/gin-gonic/gin.(*Engine).handleHTTPRequest(0xc0003b8500, 0xc0005bc2d0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/gin.go:409 +0x666
github.com/gin-gonic/gin.(*Engine).ServeHTTP(0xc0003b8500, 0xd12a40, 0xc0000b8e00, 0xc000295a00)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/gin.go:367 +0x14d
net/http.serverHandler.ServeHTTP(0xc0000b8380, 0xd12a40, 0xc0000b8e00, 0xc000295a00)
	/usr/local/go/src/net/http/server.go:2807 +0xa3
net/http.(*conn).serve(0xc0003b7ae0, 0xd15200, 0xc0002c64c0)
	/usr/local/go/src/net/http/server.go:1895 +0x86c
created by net/http.(*Server).Serve
	/usr/local/go/src/net/http/server.go:2933 +0x35c

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:50:39][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
2020/07/21 09:50:39 http: panic serving 116.238.210.229:49411: write tcp 172.16.13.169:80->116.238.210.229:49411: write: broken pipe
goroutine 1089 [running]:
net/http.(*conn).serve.func1(0xc0003b7d60)
	/usr/local/go/src/net/http/server.go:1772 +0x139
panic(0xb50ee0, 0xc0001dafa0)
	/usr/local/go/src/runtime/panic.go:975 +0x3e3
github.com/gin-gonic/gin.(*Context).Render(0xc0005bc960, 0x194, 0xd0e260, 0xc0007033b0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:842 +0x173
github.com/gin-gonic/gin.(*Context).HTML(0xc0005bc960, 0x194, 0xbf193d, 0x8, 0xb43d60, 0xc00062cf90)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:851 +0x99
blog/controller/page.NotFoundHandler(0xc0005bc960)
	/usr/workspace/src/blog/controller/page/404.go:12 +0x120
github.com/gin-gonic/gin.(*Context).Next(0xc0005bc960)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:161 +0x3b
github.com/gin-contrib/sessions.Sessions.func1(0xc0005bc960)
	/usr/workspace/pkg/mod/github.com/gin-contrib/sessions@v0.0.3/sessions.go:52 +0x16d
github.com/gin-gonic/gin.(*Context).Next(0xc0005bc960)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:161 +0x3b
github.com/gin-gonic/gin.serveError(0xc0005bc960, 0x194, 0x1248dc0, 0x12, 0x12)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/gin.go:445 +0x38
github.com/gin-gonic/gin.(*Engine).handleHTTPRequest(0xc0003b8500, 0xc0005bc960)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/gin.go:438 +0x3d3
github.com/gin-gonic/gin.(*Engine).ServeHTTP(0xc0003b8500, 0xd12a40, 0xc0000b9180, 0xc000295b00)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/gin.go:367 +0x14d
net/http.serverHandler.ServeHTTP(0xc0000b8380, 0xd12a40, 0xc0000b9180, 0xc000295b00)
	/usr/local/go/src/net/http/server.go:2807 +0xa3
net/http.(*conn).serve(0xc0003b7d60, 0xd15200, 0xc0002c66c0)
	/usr/local/go/src/net/http/server.go:1895 +0x86c
created by net/http.(*Server).Serve
	/usr/local/go/src/net/http/server.go:2933 +0x35c

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-21 09:52:21][0m  [36;1m[0.54ms][0m  SELECT * FROM `tags`    
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:52:21][0m  [36;1m[0.26ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 09:52:21][0m  [36;1m[0.70ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:31)[0m 
[33m[2020-07-21 09:52:21][0m  [36;1m[0.22ms][0m  SELECT count(*) FROM `tags`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:52:23][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 09:52:23][0m  [36;1m[0.25ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:144)[0m 
[33m[2020-07-21 09:52:23][0m  [36;1m[0.61ms][0m   SELECT * FROM `blogs` GROUP BY YEAR DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:157)[0m 
[33m[2020-07-21 09:52:23][0m  [36;1m[0.68ms][0m   SELECT * FROM `blogs` where year = 2020 GROUP BY month DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:169)[0m 
[33m[2020-07-21 09:52:23][0m  [36;1m[0.60ms][0m   SELECT * FROM `blogs` where year = 2020 and month = 7 ORDER BY `id` DESC  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 09:52:23][0m  [36;1m[0.38ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=4  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 09:52:23][0m  [36;1m[0.39ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=3  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 09:52:23][0m  [36;1m[0.35ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=2  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 09:52:23][0m  [36;1m[0.35ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:52:24][0m  [36;1m[0.58ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:52:24][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 09:52:24][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:144)[0m 
[33m[2020-07-21 09:52:24][0m  [36;1m[0.61ms][0m   SELECT * FROM `blogs` GROUP BY YEAR DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:157)[0m 
[33m[2020-07-21 09:52:24][0m  [36;1m[1.01ms][0m   SELECT * FROM `blogs` where year = 2020 GROUP BY month DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:169)[0m 
[33m[2020-07-21 09:52:24][0m  [36;1m[0.58ms][0m   SELECT * FROM `blogs` where year = 2020 and month = 7 ORDER BY `id` DESC  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 09:52:24][0m  [36;1m[0.36ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=4  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 09:52:24][0m  [36;1m[0.33ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=3  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 09:52:24][0m  [36;1m[0.32ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=2  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 09:52:24][0m  [36;1m[0.35ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:52:25][0m  [36;1m[0.60ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:52:26][0m  [36;1m[0.52ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 09:52:26][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:144)[0m 
[33m[2020-07-21 09:52:26][0m  [36;1m[0.59ms][0m   SELECT * FROM `blogs` GROUP BY YEAR DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:157)[0m 
[33m[2020-07-21 09:52:26][0m  [36;1m[0.70ms][0m   SELECT * FROM `blogs` where year = 2020 GROUP BY month DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:169)[0m 
[33m[2020-07-21 09:52:26][0m  [36;1m[0.59ms][0m   SELECT * FROM `blogs` where year = 2020 and month = 7 ORDER BY `id` DESC  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 09:52:26][0m  [36;1m[0.38ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=4  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 09:52:26][0m  [36;1m[0.34ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=3  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 09:52:26][0m  [36;1m[0.33ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=2  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 09:52:26][0m  [36;1m[0.31ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:52:27][0m  [36;1m[0.51ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:52:28][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 09:52:28][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:144)[0m 
[33m[2020-07-21 09:52:28][0m  [36;1m[0.60ms][0m   SELECT * FROM `blogs` GROUP BY YEAR DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:157)[0m 
[33m[2020-07-21 09:52:28][0m  [36;1m[2.96ms][0m   SELECT * FROM `blogs` where year = 2020 GROUP BY month DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:169)[0m 
[33m[2020-07-21 09:52:28][0m  [36;1m[0.62ms][0m   SELECT * FROM `blogs` where year = 2020 and month = 7 ORDER BY `id` DESC  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 09:52:28][0m  [36;1m[0.38ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=4  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 09:52:28][0m  [36;1m[0.33ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=3  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 09:52:28][0m  [36;1m[0.33ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=2  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 09:52:28][0m  [36;1m[0.32ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:52:29][0m  [36;1m[0.53ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-21 09:52:30][0m  [36;1m[0.51ms][0m  SELECT * FROM `tags`    
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:52:30][0m  [36;1m[0.28ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 09:52:30][0m  [36;1m[0.70ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:31)[0m 
[33m[2020-07-21 09:52:30][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `tags`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:52:31][0m  [36;1m[0.56ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:52:31][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 09:52:31][0m  [36;1m[0.28ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:144)[0m 
[33m[2020-07-21 09:52:31][0m  [36;1m[0.66ms][0m   SELECT * FROM `blogs` GROUP BY YEAR DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:157)[0m 
[33m[2020-07-21 09:52:31][0m  [36;1m[2.94ms][0m   SELECT * FROM `blogs` where year = 2020 GROUP BY month DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:169)[0m 
[33m[2020-07-21 09:52:31][0m  [36;1m[0.68ms][0m   SELECT * FROM `blogs` where year = 2020 and month = 7 ORDER BY `id` DESC  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 09:52:31][0m  [36;1m[0.46ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=4  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 09:52:31][0m  [36;1m[0.43ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=3  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 09:52:31][0m  [36;1m[0.37ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=2  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 09:52:31][0m  [36;1m[0.39ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:52:32][0m  [36;1m[0.53ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:52:38][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 09:52:38][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:144)[0m 
[33m[2020-07-21 09:52:38][0m  [36;1m[0.64ms][0m   SELECT * FROM `blogs` GROUP BY YEAR DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:157)[0m 
[33m[2020-07-21 09:52:38][0m  [36;1m[0.76ms][0m   SELECT * FROM `blogs` where year = 2020 GROUP BY month DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:169)[0m 
[33m[2020-07-21 09:52:38][0m  [36;1m[0.60ms][0m   SELECT * FROM `blogs` where year = 2020 and month = 7 ORDER BY `id` DESC  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 09:52:38][0m  [36;1m[0.40ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=4  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 09:52:38][0m  [36;1m[0.34ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=3  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 09:52:38][0m  [36;1m[0.32ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=2  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 09:52:38][0m  [36;1m[0.35ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:52:39][0m  [36;1m[0.58ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:52:41][0m  [36;1m[0.52ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 09:52:41][0m  [36;1m[0.22ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:144)[0m 
[33m[2020-07-21 09:52:41][0m  [36;1m[0.66ms][0m   SELECT * FROM `blogs` GROUP BY YEAR DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:157)[0m 
[33m[2020-07-21 09:52:41][0m  [36;1m[2.15ms][0m   SELECT * FROM `blogs` where year = 2020 GROUP BY month DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:169)[0m 
[33m[2020-07-21 09:52:41][0m  [36;1m[0.61ms][0m   SELECT * FROM `blogs` where year = 2020 and month = 7 ORDER BY `id` DESC  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 09:52:41][0m  [36;1m[0.39ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=4  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 09:52:41][0m  [36;1m[0.33ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=3  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 09:52:41][0m  [36;1m[0.34ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=2  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 09:52:41][0m  [36;1m[0.34ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-21 09:52:42][0m  [36;1m[0.61ms][0m  SELECT * FROM `tags`    
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:52:42][0m  [36;1m[0.23ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 09:52:42][0m  [36;1m[0.72ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:31)[0m 
[33m[2020-07-21 09:52:42][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `tags`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:52:43][0m  [36;1m[0.52ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 09:52:43][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:144)[0m 
[33m[2020-07-21 09:52:43][0m  [36;1m[0.59ms][0m   SELECT * FROM `blogs` GROUP BY YEAR DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:157)[0m 
[33m[2020-07-21 09:52:43][0m  [36;1m[0.61ms][0m   SELECT * FROM `blogs` where year = 2020 GROUP BY month DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:169)[0m 
[33m[2020-07-21 09:52:43][0m  [36;1m[0.61ms][0m   SELECT * FROM `blogs` where year = 2020 and month = 7 ORDER BY `id` DESC  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 09:52:43][0m  [36;1m[0.38ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=4  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 09:52:43][0m  [36;1m[0.33ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=3  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 09:52:43][0m  [36;1m[0.33ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=2  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 09:52:43][0m  [36;1m[0.43ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:52:44][0m  [36;1m[0.58ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:52:45][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:52:46][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 09:52:46][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:144)[0m 
[33m[2020-07-21 09:52:46][0m  [36;1m[0.60ms][0m   SELECT * FROM `blogs` GROUP BY YEAR DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:157)[0m 
[33m[2020-07-21 09:52:46][0m  [36;1m[0.65ms][0m   SELECT * FROM `blogs` where year = 2020 GROUP BY month DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:169)[0m 
[33m[2020-07-21 09:52:46][0m  [36;1m[0.66ms][0m   SELECT * FROM `blogs` where year = 2020 and month = 7 ORDER BY `id` DESC  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 09:52:46][0m  [36;1m[0.38ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=4  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 09:52:46][0m  [36;1m[0.32ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=3  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 09:52:46][0m  [36;1m[0.37ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=2  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 09:52:46][0m  [36;1m[0.36ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:52:49][0m  [36;1m[0.64ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 09:52:49][0m  [36;1m[0.79ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 09:52:49][0m  [36;1m[0.24ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 09:52:49][0m  [36;1m[0.33ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 09:52:49][0m  [36;1m[0.32ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 09:52:49][0m  [36;1m[0.35ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:52:56][0m  [36;1m[0.57ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 09:52:56][0m  [36;1m[0.80ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 09:52:56][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 09:52:56][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 09:52:56][0m  [36;1m[0.25ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 09:52:56][0m  [36;1m[0.34ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:52:58][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 09:52:58][0m  [36;1m[0.70ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 09:52:58][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 09:52:58][0m  [36;1m[0.29ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 09:52:58][0m  [36;1m[0.27ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 09:52:58][0m  [36;1m[0.31ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:52:59][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 09:52:59][0m  [36;1m[0.72ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 09:52:59][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 09:52:59][0m  [36;1m[0.35ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 09:52:59][0m  [36;1m[0.27ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 09:52:59][0m  [36;1m[0.37ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:53:00][0m  [36;1m[0.42ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 09:53:00][0m  [36;1m[0.75ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 09:53:00][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 09:53:00][0m  [36;1m[0.31ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 09:53:00][0m  [36;1m[0.28ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 09:53:00][0m  [36;1m[0.34ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:53:02][0m  [36;1m[0.60ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 09:53:02][0m  [36;1m[0.75ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 09:53:02][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 09:53:02][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 09:53:02][0m  [36;1m[0.24ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 09:53:02][0m  [36;1m[0.35ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:53:03][0m  [36;1m[0.58ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 09:53:03][0m  [36;1m[0.74ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 09:53:03][0m  [36;1m[0.23ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 09:53:03][0m  [36;1m[0.33ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 09:53:03][0m  [36;1m[0.28ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 09:53:03][0m  [36;1m[0.43ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:53:04][0m  [36;1m[0.53ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 09:53:04][0m  [36;1m[0.73ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 09:53:04][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 09:53:04][0m  [36;1m[0.29ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 09:53:04][0m  [36;1m[0.25ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 09:53:04][0m  [36;1m[0.31ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:53:05][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 09:53:05][0m  [36;1m[0.70ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 09:53:05][0m  [36;1m[0.22ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 09:53:05][0m  [36;1m[0.31ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 09:53:05][0m  [36;1m[0.27ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 09:53:05][0m  [36;1m[0.32ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-21 09:53:09][0m  [36;1m[0.56ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:53:09][0m  [36;1m[0.24ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 09:53:09][0m  [36;1m[0.66ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-21 09:53:09][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-21 09:53:09][0m  [36;1m[0.54ms][0m  SELECT * FROM `tags`    
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:53:09][0m  [36;1m[0.25ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 09:53:09][0m  [36;1m[0.67ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:31)[0m 
[33m[2020-07-21 09:53:09][0m  [36;1m[0.18ms][0m  SELECT count(*) FROM `tags`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:53:10][0m  [36;1m[0.59ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 09:53:10][0m  [36;1m[0.68ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 09:53:10][0m  [36;1m[0.17ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 09:53:10][0m  [36;1m[0.33ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 09:53:10][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 09:53:10][0m  [36;1m[0.33ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-21 09:53:13][0m  [36;1m[0.72ms][0m  SELECT * FROM `tags`    
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:53:13][0m  [36;1m[0.34ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 09:53:13][0m  [36;1m[1.00ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:31)[0m 
[33m[2020-07-21 09:53:13][0m  [36;1m[0.25ms][0m  SELECT count(*) FROM `tags`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-21 09:53:13][0m  [36;1m[0.63ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:53:13][0m  [36;1m[0.25ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 09:53:13][0m  [36;1m[0.69ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-21 09:53:13][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:53:14][0m  [36;1m[0.57ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 09:53:14][0m  [36;1m[0.73ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 09:53:14][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 09:53:14][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 09:53:14][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 09:53:14][0m  [36;1m[0.34ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-21 09:53:22][0m  [36;1m[0.40ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 4)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-21 09:53:22][0m  [36;1m[0.46ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=4  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-21 09:53:22][0m  [36;1m[0.50ms][0m  UPDATE `blogs` SET `title` = '本博客开源公告', `content` = '今天本博客评论功能发布
# 自今天起，本博客基本功能已经完成
## 发布V1.0版本并开源
## 博客语言说明
#### 本博客后端是用golang 的gin框架+gorm编写
前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的
#### 博客效果参考本站
#一、博客简介
## 1.博客目录

    blog
    ├────controller
	├────└───admin
	|	|	├──adminblog.go
	|	|	├───adminController.go
	|	|	├──adminTag.go
	|	|	├──adminType.go
	|	|	└──adminUser.go
	|	└──page
	|		├──404.go
	|		├───about.go
	|		├──archives.go
	|		├──blog.go
	|		├──comment.go
	|		├──pagesController.go
	|		├──researchController.go
	|		└──tagsController.go
    ├── dao
	│	├──blogs.go
	│	├──comment.go
	│	├──sql.go
	│	├──tags.go
	│	├──types.go
	│	└──user.go
    ├── logic
    │   └── user.go
    ├── middlerware
	│	├──function.go
	│	├──getImg.go
	│	├──getTime.go
	│	├──markdown.go
	│	├──select.go
	│	└──session.go
    ├── model
	│	├──blog.go
	│	├──commnent.go
	│	├──tag.go
	│	├──type.go
	│	└──user/go
    ├── static
	│	└──静态文件（头像、图片、logo、css、js等）
    ├── templates
	│	└──html模板文件
    ├── go.mod（依赖）
    └── main.go
    

## 2.相关功能实现简介
### 1、评论及回复功能
comment的结构体属性如下
```go
package model

type Comment struct {
	Id     int //评论id
	BlogId int //博文id
	ReCommentId    int    //父评论id
	CommentName string //评论人姓名
	ReCommentName  string //父评论人姓名
	CommentEmail   string
	Img            string
	CommentContent string `gorm:"type:text" form:"CommentContent" json:"CommentContent"` //评论内容
	CommentTime    string ` json:"comment_time,omitempty"`
	Parent         *Comment
	Comments       []Comment
}
```
#### 实现方法
##### 1先通过查找父评论为-1的顶级评论
父评论Id为-1说明他不是任何评论的子评论
##### 2在html上遍历所有的顶级评论
在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论
###### （1）递归存储每个顶级评论的子评论
这里我用一个切片来储存一个顶级评论的所有子评论
```go
var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
	var comments []model.Comment
	DB.Debug().Where("re_comment_id = -1 AND blog_id = ?", id).Find(&comments)
	return &comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
	if count != 0 {
		fmt.Println("if判断1")
		var comments []model.Comment
		DB.Debug().Where("re_comment_id = ?", id).Find(&comments)
		count = len(comments)
		if count != 0 {
			fmt.Println("if判断2")
			for _, comment := range comments {
				fmt.Println("for判断1")
				Comments = append(Comments, comment)
				SelectCommentByComment(comment.Id, count)
			}
		}
	}
	fmt.Println(Comments)
	return &Comments

}
```
ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来
###### （2）出现问题的原因
因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量
###### （3）解决问题
```go
func ClearComments() bool {
	var comments []model.Comment
	Comments = comments
	return true
}

```
这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现
#### 这里我还加了一个小小的随机头像功能
```go
if  CommentName == user.Name && CommentEmail == user.UserEmail {
		fmt.Println("进入了1")
		comment.Img =user.UserImg
		//找相同评论人
	}else if CommentName == one.CommentName && CommentEmail == one.CommentEmail {
		fmt.Println("进入了2")
		comment.Img =one.Img
		//随机选头像
	}else{
		fmt.Println("进入了3")
		comment.Img =middleware.GetImg()
	}
```
##### 123分别代表三种不同的用户群体
1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
![](/static/images/%e5%a4%b4%e5%83%8f1.png)![](/static/images/%e5%a4%b4%e5%83%8f2.png)![](/static/images/%e5%a4%b4%e5%83%8f3.png)![](/static/images/%e5%a4%b4%e5%83%8f4.png)![](/static/images/%e5%a4%b4%e5%83%8f5.png)![](/static/images/%e5%a4%b4%e5%83%8f6.png)
### 2、归档功能
#### blog的结构体属性如下
```go
package model

type Blog struct {
	Id           int
	Title        string    `form:"title" json:"title"`                          //标题
	Content      string    `gorm:"type:longtext" form:"content" json:"content"` //内容
	Image        string    `gorm:"type:text" form:"image" json:"image"`         //首图
	Numb         int       `form:"numb" json:"numb"`                            //次数
	Flag         string    `form:"flag" json:"flag"`                            //原创或者转载
	Appreciation string    `form:"appreciation" json:"appreciation"`            //打赏开关
	ShareInfo    string    `form:"shareInfo" json:"shareInfo"`                  //版权开关
	Comment      string    `form:"comment" json:"comment"`                      //评论开关
	Recommend    string    `form:"recommend" json:"recommend"`                  //推荐开关
	Description  string    `gorm:"type:text" form:"description" json:"description"`
	CreatTime    string    `form:"creatTime"  json:"creat_time,omitempty"`   //创建时间
	UpdateTime   string    `form:"updateTime"  json:"update_time,omitempty"` //更新时间
	Comments     []Comment `form:"comments" json:"comments"`
	TypeId       int       `form:"typeId" json:"typeId"`
	Type         Type      `form:"type" gorm:"ForeignKey:TypeId"`
	Year         int       `form:"year" json:"year"`
	Month        int       `form:"month" json:"month"`
	Day          int       `form:"day" json:"day"`
}

```
#### 实现方法
我的思路是创建三个时间节点
year month day 
利用sql分组查询
##### Group By分组查询步骤
###### （1）先按照年份查询
###### （2）再按照年份遍历每个月份
并将所有保存在一个切片中
###### （3）按照月份遍历每个月的所有文章
保存在一个Map中，key是对应的月份，value是每个月份的所有文章
#### 自此归档功能实现


## 3.已知BUG
### 后台退出功能
后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧

开源地址
[github](https://github.com/likewl/blog "github")
[gitee](https://gitee.com/nculike/blog "gitee")', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1535821573,4166447487&fm=26&gp=0.jpg', `numb` = 33, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '本博客后端是用golang 的gin框架+gorm编写', `creat_time` = '2020-07-20 15:24:23', `update_time` = '2020-07-20 15:24:23', `type_id` = 4, `year` = 2020, `month` = 7, `day` = 20  WHERE `blogs`.`id` = 4  
[36;31m[1 rows affected or returned ][0m 
<p>今天本博客评论功能发布</p>

<h1>自今天起，本博客基本功能已经完成</h1>

<h2>发布V1.0版本并开源</h2>

<h2>博客语言说明</h2>

<h4>本博客后端是用golang 的gin框架+gorm编写</h4>

<p>前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的</p>

<h4>博客效果参考本站</h4>

<p>#一、博客简介</p>

<h2>1.博客目录</h2>

<pre><code>blog
├────controller
├────└───admin
|   |   ├──adminblog.go
|   |   ├───adminController.go
|   |   ├──adminTag.go
|   |   ├──adminType.go
|   |   └──adminUser.go
|   └──page
|       ├──404.go
|       ├───about.go
|       ├──archives.go
|       ├──blog.go
|       ├──comment.go
|       ├──pagesController.go
|       ├──researchController.go
|       └──tagsController.go
├── dao
│   ├──blogs.go
│   ├──comment.go
│   ├──sql.go
│   ├──tags.go
│   ├──types.go
│   └──user.go
├── logic
│   └── user.go
├── middlerware
│   ├──function.go
│   ├──getImg.go
│   ├──getTime.go
│   ├──markdown.go
│   ├──select.go
│   └──session.go
├── model
│   ├──blog.go
│   ├──commnent.go
│   ├──tag.go
│   ├──type.go
│   └──user/go
├── static
│   └──静态文件（头像、图片、logo、css、js等）
├── templates
│   └──html模板文件
├── go.mod（依赖）
└── main.go
</code></pre>

<h2>2.相关功能实现简介</h2>

<h3>1、评论及回复功能</h3>

<p>comment的结构体属性如下</p>

<pre><code class="language-go">package model

type Comment struct {
    Id     int //评论id
    BlogId int //博文id
    ReCommentId    int    //父评论id
    CommentName string //评论人姓名
    ReCommentName  string //父评论人姓名
    CommentEmail   string
    Img            string
    CommentContent string `gorm:&#34;type:text&#34; form:&#34;CommentContent&#34; json:&#34;CommentContent&#34;` //评论内容
    CommentTime    string ` json:&#34;comment_time,omitempty&#34;`
    Parent         *Comment
    Comments       []Comment
}
</code></pre>

<h4>实现方法</h4>

<h5>1先通过查找父评论为-1的顶级评论</h5>

<p>父评论Id为-1说明他不是任何评论的子评论</p>

<h5>2在html上遍历所有的顶级评论</h5>

<p>在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论</p>

<h6>（1）递归存储每个顶级评论的子评论</h6>

<p>这里我用一个切片来储存一个顶级评论的所有子评论</p>

<pre><code class="language-go">var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
    var comments []model.Comment
    DB.Debug().Where(&#34;re_comment_id = -1 AND blog_id = ?&#34;, id).Find(&amp;comments)
    return &amp;comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
    if count != 0 {
        fmt.Println(&#34;if判断1&#34;)
        var comments []model.Comment
        DB.Debug().Where(&#34;re_comment_id = ?&#34;, id).Find(&amp;comments)
        count = len(comments)
        if count != 0 {
            fmt.Println(&#34;if判断2&#34;)
            for _, comment := range comments {
                fmt.Println(&#34;for判断1&#34;)
                Comments = append(Comments, comment)
                SelectCommentByComment(comment.Id, count)
            }
        }
    }
    fmt.Println(Comments)
    return &amp;Comments

}
</code></pre>

<p>ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来</p>

<h6>（2）出现问题的原因</h6>

<p>因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量</p>

<h6>（3）解决问题</h6>

<pre><code class="language-go">func ClearComments() bool {
    var comments []model.Comment
    Comments = comments
    return true
}

</code></pre>

<p>这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现</p>

<h4>这里我还加了一个小小的随机头像功能</h4>

<pre><code class="language-go">if  CommentName == user.Name &amp;&amp; CommentEmail == user.UserEmail {
        fmt.Println(&#34;进入了1&#34;)
        comment.Img =user.UserImg
        //找相同评论人
    }else if CommentName == one.CommentName &amp;&amp; CommentEmail == one.CommentEmail {
        fmt.Println(&#34;进入了2&#34;)
        comment.Img =one.Img
        //随机选头像
    }else{
        fmt.Println(&#34;进入了3&#34;)
        comment.Img =middleware.GetImg()
    }
</code></pre>

<h5>123分别代表三种不同的用户群体</h5>

<p>1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
<img src="/static/images/%e5%a4%b4%e5%83%8f1.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f2.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f3.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f4.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f5.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f6.png" alt=""/></p>

<h3>2、归档功能</h3>

<h4>blog的结构体属性如下</h4>

<pre><code class="language-go">package model

type Blog struct {
    Id           int
    Title        string    `form:&#34;title&#34; json:&#34;title&#34;`                          //标题
    Content      string    `gorm:&#34;type:longtext&#34; form:&#34;content&#34; json:&#34;content&#34;` //内容
    Image        string    `gorm:&#34;type:text&#34; form:&#34;image&#34; json:&#34;image&#34;`         //首图
    Numb         int       `form:&#34;numb&#34; json:&#34;numb&#34;`                            //次数
    Flag         string    `form:&#34;flag&#34; json:&#34;flag&#34;`                            //原创或者转载
    Appreciation string    `form:&#34;appreciation&#34; json:&#34;appreciation&#34;`            //打赏开关
    ShareInfo    string    `form:&#34;shareInfo&#34; json:&#34;shareInfo&#34;`                  //版权开关
    Comment      string    `form:&#34;comment&#34; json:&#34;comment&#34;`                      //评论开关
    Recommend    string    `form:&#34;recommend&#34; json:&#34;recommend&#34;`                  //推荐开关
    Description  string    `gorm:&#34;type:text&#34; form:&#34;description&#34; json:&#34;description&#34;`
    CreatTime    string    `form:&#34;creatTime&#34;  json:&#34;creat_time,omitempty&#34;`   //创建时间
    UpdateTime   string    `form:&#34;updateTime&#34;  json:&#34;update_time,omitempty&#34;` //更新时间
    Comments     []Comment `form:&#34;comments&#34; json:&#34;comments&#34;`
    TypeId       int       `form:&#34;typeId&#34; json:&#34;typeId&#34;`
    Type         Type      `form:&#34;type&#34; gorm:&#34;ForeignKey:TypeId&#34;`
    Year         int       `form:&#34;year&#34; json:&#34;year&#34;`
    Month        int       `form:&#34;month&#34; json:&#34;month&#34;`
    Day          int       `form:&#34;day&#34; json:&#34;day&#34;`
}

</code></pre>

<h4>实现方法</h4>

<p>我的思路是创建三个时间节点
year month day
利用sql分组查询</p>

<h5>Group By分组查询步骤</h5>

<h6>（1）先按照年份查询</h6>

<h6>（2）再按照年份遍历每个月份</h6>

<p>并将所有保存在一个切片中</p>

<h6>（3）按照月份遍历每个月的所有文章</h6>

<p>保存在一个Map中，key是对应的月份，value是每个月份的所有文章</p>

<h4>自此归档功能实现</h4>

<h2>3.已知BUG</h2>

<h3>后台退出功能</h3>

<p>后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧</p>

<p>开源地址
<a href="https://github.com/likewl/blog" title="github" rel="nofollow">github</a>
<a href="https://gitee.com/nculike/blog" title="gitee" rel="nofollow">gitee</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:53:22][0m  [36;1m[0.26ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-21 09:53:26][0m  [36;1m[0.56ms][0m  SELECT * FROM `tags`    
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:53:26][0m  [36;1m[0.26ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 09:53:26][0m  [36;1m[0.67ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:31)[0m 
[33m[2020-07-21 09:53:26][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `tags`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:53:27][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 09:53:27][0m  [36;1m[0.23ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:144)[0m 
[33m[2020-07-21 09:53:27][0m  [36;1m[0.61ms][0m   SELECT * FROM `blogs` GROUP BY YEAR DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:157)[0m 
[33m[2020-07-21 09:53:27][0m  [36;1m[1.92ms][0m   SELECT * FROM `blogs` where year = 2020 GROUP BY month DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:169)[0m 
[33m[2020-07-21 09:53:27][0m  [36;1m[0.66ms][0m   SELECT * FROM `blogs` where year = 2020 and month = 7 ORDER BY `id` DESC  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 09:53:27][0m  [36;1m[0.40ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=4  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 09:53:27][0m  [36;1m[0.41ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=3  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 09:53:27][0m  [36;1m[0.34ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=2  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 09:53:27][0m  [36;1m[0.36ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:53:29][0m  [36;1m[0.57ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-21 09:53:30][0m  [36;1m[0.54ms][0m  SELECT * FROM `tags`    
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:53:30][0m  [36;1m[0.26ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 09:53:30][0m  [36;1m[0.80ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:31)[0m 
[33m[2020-07-21 09:53:30][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `tags`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-21 09:53:30][0m  [36;1m[0.56ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:53:30][0m  [36;1m[0.27ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 09:53:30][0m  [36;1m[0.72ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-21 09:53:30][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-21 09:53:31][0m  [36;1m[0.54ms][0m  SELECT * FROM `tags`    
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:53:31][0m  [36;1m[0.27ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 09:53:31][0m  [36;1m[0.69ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:31)[0m 
[33m[2020-07-21 09:53:31][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `tags`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-21 09:53:32][0m  [36;1m[0.58ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:53:32][0m  [36;1m[0.25ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 09:53:32][0m  [36;1m[0.70ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-21 09:53:32][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:53:33][0m  [36;1m[0.56ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 09:53:33][0m  [36;1m[0.75ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 09:53:33][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 09:53:33][0m  [36;1m[0.32ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 09:53:33][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 09:53:33][0m  [36;1m[0.33ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-21 09:53:35][0m  [36;1m[0.36ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 4)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-21 09:53:35][0m  [36;1m[0.43ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=4  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-21 09:53:35][0m  [36;1m[0.43ms][0m  UPDATE `blogs` SET `title` = '本博客开源公告', `content` = '今天本博客评论功能发布
# 自今天起，本博客基本功能已经完成
## 发布V1.0版本并开源
## 博客语言说明
#### 本博客后端是用golang 的gin框架+gorm编写
前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的
#### 博客效果参考本站
#一、博客简介
## 1.博客目录

    blog
    ├────controller
	├────└───admin
	|	|	├──adminblog.go
	|	|	├───adminController.go
	|	|	├──adminTag.go
	|	|	├──adminType.go
	|	|	└──adminUser.go
	|	└──page
	|		├──404.go
	|		├───about.go
	|		├──archives.go
	|		├──blog.go
	|		├──comment.go
	|		├──pagesController.go
	|		├──researchController.go
	|		└──tagsController.go
    ├── dao
	│	├──blogs.go
	│	├──comment.go
	│	├──sql.go
	│	├──tags.go
	│	├──types.go
	│	└──user.go
    ├── logic
    │   └── user.go
    ├── middlerware
	│	├──function.go
	│	├──getImg.go
	│	├──getTime.go
	│	├──markdown.go
	│	├──select.go
	│	└──session.go
    ├── model
	│	├──blog.go
	│	├──commnent.go
	│	├──tag.go
	│	├──type.go
	│	└──user/go
    ├── static
	│	└──静态文件（头像、图片、logo、css、js等）
    ├── templates
	│	└──html模板文件
    ├── go.mod（依赖）
    └── main.go
    

## 2.相关功能实现简介
### 1、评论及回复功能
comment的结构体属性如下
```go
package model

type Comment struct {
	Id     int //评论id
	BlogId int //博文id
	ReCommentId    int    //父评论id
	CommentName string //评论人姓名
	ReCommentName  string //父评论人姓名
	CommentEmail   string
	Img            string
	CommentContent string `gorm:"type:text" form:"CommentContent" json:"CommentContent"` //评论内容
	CommentTime    string ` json:"comment_time,omitempty"`
	Parent         *Comment
	Comments       []Comment
}
```
#### 实现方法
##### 1先通过查找父评论为-1的顶级评论
父评论Id为-1说明他不是任何评论的子评论
##### 2在html上遍历所有的顶级评论
在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论
###### （1）递归存储每个顶级评论的子评论
这里我用一个切片来储存一个顶级评论的所有子评论
```go
var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
	var comments []model.Comment
	DB.Debug().Where("re_comment_id = -1 AND blog_id = ?", id).Find(&comments)
	return &comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
	if count != 0 {
		fmt.Println("if判断1")
		var comments []model.Comment
		DB.Debug().Where("re_comment_id = ?", id).Find(&comments)
		count = len(comments)
		if count != 0 {
			fmt.Println("if判断2")
			for _, comment := range comments {
				fmt.Println("for判断1")
				Comments = append(Comments, comment)
				SelectCommentByComment(comment.Id, count)
			}
		}
	}
	fmt.Println(Comments)
	return &Comments

}
```
ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来
###### （2）出现问题的原因
因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量
###### （3）解决问题
```go
func ClearComments() bool {
	var comments []model.Comment
	Comments = comments
	return true
}

```
这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现
#### 这里我还加了一个小小的随机头像功能
```go
if  CommentName == user.Name && CommentEmail == user.UserEmail {
		fmt.Println("进入了1")
		comment.Img =user.UserImg
		//找相同评论人
	}else if CommentName == one.CommentName && CommentEmail == one.CommentEmail {
		fmt.Println("进入了2")
		comment.Img =one.Img
		//随机选头像
	}else{
		fmt.Println("进入了3")
		comment.Img =middleware.GetImg()
	}
```
##### 123分别代表三种不同的用户群体
1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
![](/static/images/%e5%a4%b4%e5%83%8f1.png)![](/static/images/%e5%a4%b4%e5%83%8f2.png)![](/static/images/%e5%a4%b4%e5%83%8f3.png)![](/static/images/%e5%a4%b4%e5%83%8f4.png)![](/static/images/%e5%a4%b4%e5%83%8f5.png)![](/static/images/%e5%a4%b4%e5%83%8f6.png)
### 2、归档功能
#### blog的结构体属性如下
```go
package model

type Blog struct {
	Id           int
	Title        string    `form:"title" json:"title"`                          //标题
	Content      string    `gorm:"type:longtext" form:"content" json:"content"` //内容
	Image        string    `gorm:"type:text" form:"image" json:"image"`         //首图
	Numb         int       `form:"numb" json:"numb"`                            //次数
	Flag         string    `form:"flag" json:"flag"`                            //原创或者转载
	Appreciation string    `form:"appreciation" json:"appreciation"`            //打赏开关
	ShareInfo    string    `form:"shareInfo" json:"shareInfo"`                  //版权开关
	Comment      string    `form:"comment" json:"comment"`                      //评论开关
	Recommend    string    `form:"recommend" json:"recommend"`                  //推荐开关
	Description  string    `gorm:"type:text" form:"description" json:"description"`
	CreatTime    string    `form:"creatTime"  json:"creat_time,omitempty"`   //创建时间
	UpdateTime   string    `form:"updateTime"  json:"update_time,omitempty"` //更新时间
	Comments     []Comment `form:"comments" json:"comments"`
	TypeId       int       `form:"typeId" json:"typeId"`
	Type         Type      `form:"type" gorm:"ForeignKey:TypeId"`
	Year         int       `form:"year" json:"year"`
	Month        int       `form:"month" json:"month"`
	Day          int       `form:"day" json:"day"`
}

```
#### 实现方法
我的思路是创建三个时间节点
year month day 
利用sql分组查询
##### Group By分组查询步骤
###### （1）先按照年份查询
###### （2）再按照年份遍历每个月份
并将所有保存在一个切片中
###### （3）按照月份遍历每个月的所有文章
保存在一个Map中，key是对应的月份，value是每个月份的所有文章
#### 自此归档功能实现


## 3.已知BUG
### 后台退出功能
后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧

开源地址
[github](https://github.com/likewl/blog "github")
[gitee](https://gitee.com/nculike/blog "gitee")', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1535821573,4166447487&fm=26&gp=0.jpg', `numb` = 34, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '本博客后端是用golang 的gin框架+gorm编写', `creat_time` = '2020-07-20 15:24:23', `update_time` = '2020-07-20 15:24:23', `type_id` = 4, `year` = 2020, `month` = 7, `day` = 20  WHERE `blogs`.`id` = 4  
[36;31m[1 rows affected or returned ][0m 
<p>今天本博客评论功能发布</p>

<h1>自今天起，本博客基本功能已经完成</h1>

<h2>发布V1.0版本并开源</h2>

<h2>博客语言说明</h2>

<h4>本博客后端是用golang 的gin框架+gorm编写</h4>

<p>前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的</p>

<h4>博客效果参考本站</h4>

<p>#一、博客简介</p>

<h2>1.博客目录</h2>

<pre><code>blog
├────controller
├────└───admin
|   |   ├──adminblog.go
|   |   ├───adminController.go
|   |   ├──adminTag.go
|   |   ├──adminType.go
|   |   └──adminUser.go
|   └──page
|       ├──404.go
|       ├───about.go
|       ├──archives.go
|       ├──blog.go
|       ├──comment.go
|       ├──pagesController.go
|       ├──researchController.go
|       └──tagsController.go
├── dao
│   ├──blogs.go
│   ├──comment.go
│   ├──sql.go
│   ├──tags.go
│   ├──types.go
│   └──user.go
├── logic
│   └── user.go
├── middlerware
│   ├──function.go
│   ├──getImg.go
│   ├──getTime.go
│   ├──markdown.go
│   ├──select.go
│   └──session.go
├── model
│   ├──blog.go
│   ├──commnent.go
│   ├──tag.go
│   ├──type.go
│   └──user/go
├── static
│   └──静态文件（头像、图片、logo、css、js等）
├── templates
│   └──html模板文件
├── go.mod（依赖）
└── main.go
</code></pre>

<h2>2.相关功能实现简介</h2>

<h3>1、评论及回复功能</h3>

<p>comment的结构体属性如下</p>

<pre><code class="language-go">package model

type Comment struct {
    Id     int //评论id
    BlogId int //博文id
    ReCommentId    int    //父评论id
    CommentName string //评论人姓名
    ReCommentName  string //父评论人姓名
    CommentEmail   string
    Img            string
    CommentContent string `gorm:&#34;type:text&#34; form:&#34;CommentContent&#34; json:&#34;CommentContent&#34;` //评论内容
    CommentTime    string ` json:&#34;comment_time,omitempty&#34;`
    Parent         *Comment
    Comments       []Comment
}
</code></pre>

<h4>实现方法</h4>

<h5>1先通过查找父评论为-1的顶级评论</h5>

<p>父评论Id为-1说明他不是任何评论的子评论</p>

<h5>2在html上遍历所有的顶级评论</h5>

<p>在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论</p>

<h6>（1）递归存储每个顶级评论的子评论</h6>

<p>这里我用一个切片来储存一个顶级评论的所有子评论</p>

<pre><code class="language-go">var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
    var comments []model.Comment
    DB.Debug().Where(&#34;re_comment_id = -1 AND blog_id = ?&#34;, id).Find(&amp;comments)
    return &amp;comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
    if count != 0 {
        fmt.Println(&#34;if判断1&#34;)
        var comments []model.Comment
        DB.Debug().Where(&#34;re_comment_id = ?&#34;, id).Find(&amp;comments)
        count = len(comments)
        if count != 0 {
            fmt.Println(&#34;if判断2&#34;)
            for _, comment := range comments {
                fmt.Println(&#34;for判断1&#34;)
                Comments = append(Comments, comment)
                SelectCommentByComment(comment.Id, count)
            }
        }
    }
    fmt.Println(Comments)
    return &amp;Comments

}
</code></pre>

<p>ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来</p>

<h6>（2）出现问题的原因</h6>

<p>因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量</p>

<h6>（3）解决问题</h6>

<pre><code class="language-go">func ClearComments() bool {
    var comments []model.Comment
    Comments = comments
    return true
}

</code></pre>

<p>这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现</p>

<h4>这里我还加了一个小小的随机头像功能</h4>

<pre><code class="language-go">if  CommentName == user.Name &amp;&amp; CommentEmail == user.UserEmail {
        fmt.Println(&#34;进入了1&#34;)
        comment.Img =user.UserImg
        //找相同评论人
    }else if CommentName == one.CommentName &amp;&amp; CommentEmail == one.CommentEmail {
        fmt.Println(&#34;进入了2&#34;)
        comment.Img =one.Img
        //随机选头像
    }else{
        fmt.Println(&#34;进入了3&#34;)
        comment.Img =middleware.GetImg()
    }
</code></pre>

<h5>123分别代表三种不同的用户群体</h5>

<p>1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
<img src="/static/images/%e5%a4%b4%e5%83%8f1.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f2.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f3.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f4.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f5.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f6.png" alt=""/></p>

<h3>2、归档功能</h3>

<h4>blog的结构体属性如下</h4>

<pre><code class="language-go">package model

type Blog struct {
    Id           int
    Title        string    `form:&#34;title&#34; json:&#34;title&#34;`                          //标题
    Content      string    `gorm:&#34;type:longtext&#34; form:&#34;content&#34; json:&#34;content&#34;` //内容
    Image        string    `gorm:&#34;type:text&#34; form:&#34;image&#34; json:&#34;image&#34;`         //首图
    Numb         int       `form:&#34;numb&#34; json:&#34;numb&#34;`                            //次数
    Flag         string    `form:&#34;flag&#34; json:&#34;flag&#34;`                            //原创或者转载
    Appreciation string    `form:&#34;appreciation&#34; json:&#34;appreciation&#34;`            //打赏开关
    ShareInfo    string    `form:&#34;shareInfo&#34; json:&#34;shareInfo&#34;`                  //版权开关
    Comment      string    `form:&#34;comment&#34; json:&#34;comment&#34;`                      //评论开关
    Recommend    string    `form:&#34;recommend&#34; json:&#34;recommend&#34;`                  //推荐开关
    Description  string    `gorm:&#34;type:text&#34; form:&#34;description&#34; json:&#34;description&#34;`
    CreatTime    string    `form:&#34;creatTime&#34;  json:&#34;creat_time,omitempty&#34;`   //创建时间
    UpdateTime   string    `form:&#34;updateTime&#34;  json:&#34;update_time,omitempty&#34;` //更新时间
    Comments     []Comment `form:&#34;comments&#34; json:&#34;comments&#34;`
    TypeId       int       `form:&#34;typeId&#34; json:&#34;typeId&#34;`
    Type         Type      `form:&#34;type&#34; gorm:&#34;ForeignKey:TypeId&#34;`
    Year         int       `form:&#34;year&#34; json:&#34;year&#34;`
    Month        int       `form:&#34;month&#34; json:&#34;month&#34;`
    Day          int       `form:&#34;day&#34; json:&#34;day&#34;`
}

</code></pre>

<h4>实现方法</h4>

<p>我的思路是创建三个时间节点
year month day
利用sql分组查询</p>

<h5>Group By分组查询步骤</h5>

<h6>（1）先按照年份查询</h6>

<h6>（2）再按照年份遍历每个月份</h6>

<p>并将所有保存在一个切片中</p>

<h6>（3）按照月份遍历每个月的所有文章</h6>

<p>保存在一个Map中，key是对应的月份，value是每个月份的所有文章</p>

<h4>自此归档功能实现</h4>

<h2>3.已知BUG</h2>

<h3>后台退出功能</h3>

<p>后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧</p>

<p>开源地址
<a href="https://github.com/likewl/blog" title="github" rel="nofollow">github</a>
<a href="https://gitee.com/nculike/blog" title="gitee" rel="nofollow">gitee</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:53:35][0m  [36;1m[0.25ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:53:36][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 09:53:36][0m  [36;1m[0.74ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 09:53:36][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 09:53:36][0m  [36;1m[0.37ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 09:53:36][0m  [36;1m[0.27ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 09:53:36][0m  [36;1m[0.33ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:53:37][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-21 09:53:37][0m  [36;1m[0.23ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-21 09:53:37][0m  [36;1m[0.18ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/types.go:52)[0m 
[33m[2020-07-21 09:53:37][0m  [36;1m[0.46ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id WHERE (type_id = 4) ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-21 09:53:40][0m  [36;1m[0.36ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 4)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-21 09:53:40][0m  [36;1m[0.44ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=4  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-21 09:53:40][0m  [36;1m[0.46ms][0m  UPDATE `blogs` SET `title` = '本博客开源公告', `content` = '今天本博客评论功能发布
# 自今天起，本博客基本功能已经完成
## 发布V1.0版本并开源
## 博客语言说明
#### 本博客后端是用golang 的gin框架+gorm编写
前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的
#### 博客效果参考本站
#一、博客简介
## 1.博客目录

    blog
    ├────controller
	├────└───admin
	|	|	├──adminblog.go
	|	|	├───adminController.go
	|	|	├──adminTag.go
	|	|	├──adminType.go
	|	|	└──adminUser.go
	|	└──page
	|		├──404.go
	|		├───about.go
	|		├──archives.go
	|		├──blog.go
	|		├──comment.go
	|		├──pagesController.go
	|		├──researchController.go
	|		└──tagsController.go
    ├── dao
	│	├──blogs.go
	│	├──comment.go
	│	├──sql.go
	│	├──tags.go
	│	├──types.go
	│	└──user.go
    ├── logic
    │   └── user.go
    ├── middlerware
	│	├──function.go
	│	├──getImg.go
	│	├──getTime.go
	│	├──markdown.go
	│	├──select.go
	│	└──session.go
    ├── model
	│	├──blog.go
	│	├──commnent.go
	│	├──tag.go
	│	├──type.go
	│	└──user/go
    ├── static
	│	└──静态文件（头像、图片、logo、css、js等）
    ├── templates
	│	└──html模板文件
    ├── go.mod（依赖）
    └── main.go
    

## 2.相关功能实现简介
### 1、评论及回复功能
comment的结构体属性如下
```go
package model

type Comment struct {
	Id     int //评论id
	BlogId int //博文id
	ReCommentId    int    //父评论id
	CommentName string //评论人姓名
	ReCommentName  string //父评论人姓名
	CommentEmail   string
	Img            string
	CommentContent string `gorm:"type:text" form:"CommentContent" json:"CommentContent"` //评论内容
	CommentTime    string ` json:"comment_time,omitempty"`
	Parent         *Comment
	Comments       []Comment
}
```
#### 实现方法
##### 1先通过查找父评论为-1的顶级评论
父评论Id为-1说明他不是任何评论的子评论
##### 2在html上遍历所有的顶级评论
在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论
###### （1）递归存储每个顶级评论的子评论
这里我用一个切片来储存一个顶级评论的所有子评论
```go
var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
	var comments []model.Comment
	DB.Debug().Where("re_comment_id = -1 AND blog_id = ?", id).Find(&comments)
	return &comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
	if count != 0 {
		fmt.Println("if判断1")
		var comments []model.Comment
		DB.Debug().Where("re_comment_id = ?", id).Find(&comments)
		count = len(comments)
		if count != 0 {
			fmt.Println("if判断2")
			for _, comment := range comments {
				fmt.Println("for判断1")
				Comments = append(Comments, comment)
				SelectCommentByComment(comment.Id, count)
			}
		}
	}
	fmt.Println(Comments)
	return &Comments

}
```
ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来
###### （2）出现问题的原因
因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量
###### （3）解决问题
```go
func ClearComments() bool {
	var comments []model.Comment
	Comments = comments
	return true
}

```
这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现
#### 这里我还加了一个小小的随机头像功能
```go
if  CommentName == user.Name && CommentEmail == user.UserEmail {
		fmt.Println("进入了1")
		comment.Img =user.UserImg
		//找相同评论人
	}else if CommentName == one.CommentName && CommentEmail == one.CommentEmail {
		fmt.Println("进入了2")
		comment.Img =one.Img
		//随机选头像
	}else{
		fmt.Println("进入了3")
		comment.Img =middleware.GetImg()
	}
```
##### 123分别代表三种不同的用户群体
1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
![](/static/images/%e5%a4%b4%e5%83%8f1.png)![](/static/images/%e5%a4%b4%e5%83%8f2.png)![](/static/images/%e5%a4%b4%e5%83%8f3.png)![](/static/images/%e5%a4%b4%e5%83%8f4.png)![](/static/images/%e5%a4%b4%e5%83%8f5.png)![](/static/images/%e5%a4%b4%e5%83%8f6.png)
### 2、归档功能
#### blog的结构体属性如下
```go
package model

type Blog struct {
	Id           int
	Title        string    `form:"title" json:"title"`                          //标题
	Content      string    `gorm:"type:longtext" form:"content" json:"content"` //内容
	Image        string    `gorm:"type:text" form:"image" json:"image"`         //首图
	Numb         int       `form:"numb" json:"numb"`                            //次数
	Flag         string    `form:"flag" json:"flag"`                            //原创或者转载
	Appreciation string    `form:"appreciation" json:"appreciation"`            //打赏开关
	ShareInfo    string    `form:"shareInfo" json:"shareInfo"`                  //版权开关
	Comment      string    `form:"comment" json:"comment"`                      //评论开关
	Recommend    string    `form:"recommend" json:"recommend"`                  //推荐开关
	Description  string    `gorm:"type:text" form:"description" json:"description"`
	CreatTime    string    `form:"creatTime"  json:"creat_time,omitempty"`   //创建时间
	UpdateTime   string    `form:"updateTime"  json:"update_time,omitempty"` //更新时间
	Comments     []Comment `form:"comments" json:"comments"`
	TypeId       int       `form:"typeId" json:"typeId"`
	Type         Type      `form:"type" gorm:"ForeignKey:TypeId"`
	Year         int       `form:"year" json:"year"`
	Month        int       `form:"month" json:"month"`
	Day          int       `form:"day" json:"day"`
}

```
#### 实现方法
我的思路是创建三个时间节点
year month day 
利用sql分组查询
##### Group By分组查询步骤
###### （1）先按照年份查询
###### （2）再按照年份遍历每个月份
并将所有保存在一个切片中
###### （3）按照月份遍历每个月的所有文章
保存在一个Map中，key是对应的月份，value是每个月份的所有文章
#### 自此归档功能实现


## 3.已知BUG
### 后台退出功能
后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧

开源地址
[github](https://github.com/likewl/blog "github")
[gitee](https://gitee.com/nculike/blog "gitee")', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1535821573,4166447487&fm=26&gp=0.jpg', `numb` = 35, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '本博客后端是用golang 的gin框架+gorm编写', `creat_time` = '2020-07-20 15:24:23', `update_time` = '2020-07-20 15:24:23', `type_id` = 4, `year` = 2020, `month` = 7, `day` = 20  WHERE `blogs`.`id` = 4  
[36;31m[1 rows affected or returned ][0m 
<p>今天本博客评论功能发布</p>

<h1>自今天起，本博客基本功能已经完成</h1>

<h2>发布V1.0版本并开源</h2>

<h2>博客语言说明</h2>

<h4>本博客后端是用golang 的gin框架+gorm编写</h4>

<p>前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的</p>

<h4>博客效果参考本站</h4>

<p>#一、博客简介</p>

<h2>1.博客目录</h2>

<pre><code>blog
├────controller
├────└───admin
|   |   ├──adminblog.go
|   |   ├───adminController.go
|   |   ├──adminTag.go
|   |   ├──adminType.go
|   |   └──adminUser.go
|   └──page
|       ├──404.go
|       ├───about.go
|       ├──archives.go
|       ├──blog.go
|       ├──comment.go
|       ├──pagesController.go
|       ├──researchController.go
|       └──tagsController.go
├── dao
│   ├──blogs.go
│   ├──comment.go
│   ├──sql.go
│   ├──tags.go
│   ├──types.go
│   └──user.go
├── logic
│   └── user.go
├── middlerware
│   ├──function.go
│   ├──getImg.go
│   ├──getTime.go
│   ├──markdown.go
│   ├──select.go
│   └──session.go
├── model
│   ├──blog.go
│   ├──commnent.go
│   ├──tag.go
│   ├──type.go
│   └──user/go
├── static
│   └──静态文件（头像、图片、logo、css、js等）
├── templates
│   └──html模板文件
├── go.mod（依赖）
└── main.go
</code></pre>

<h2>2.相关功能实现简介</h2>

<h3>1、评论及回复功能</h3>

<p>comment的结构体属性如下</p>

<pre><code class="language-go">package model

type Comment struct {
    Id     int //评论id
    BlogId int //博文id
    ReCommentId    int    //父评论id
    CommentName string //评论人姓名
    ReCommentName  string //父评论人姓名
    CommentEmail   string
    Img            string
    CommentContent string `gorm:&#34;type:text&#34; form:&#34;CommentContent&#34; json:&#34;CommentContent&#34;` //评论内容
    CommentTime    string ` json:&#34;comment_time,omitempty&#34;`
    Parent         *Comment
    Comments       []Comment
}
</code></pre>

<h4>实现方法</h4>

<h5>1先通过查找父评论为-1的顶级评论</h5>

<p>父评论Id为-1说明他不是任何评论的子评论</p>

<h5>2在html上遍历所有的顶级评论</h5>

<p>在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论</p>

<h6>（1）递归存储每个顶级评论的子评论</h6>

<p>这里我用一个切片来储存一个顶级评论的所有子评论</p>

<pre><code class="language-go">var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
    var comments []model.Comment
    DB.Debug().Where(&#34;re_comment_id = -1 AND blog_id = ?&#34;, id).Find(&amp;comments)
    return &amp;comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
    if count != 0 {
        fmt.Println(&#34;if判断1&#34;)
        var comments []model.Comment
        DB.Debug().Where(&#34;re_comment_id = ?&#34;, id).Find(&amp;comments)
        count = len(comments)
        if count != 0 {
            fmt.Println(&#34;if判断2&#34;)
            for _, comment := range comments {
                fmt.Println(&#34;for判断1&#34;)
                Comments = append(Comments, comment)
                SelectCommentByComment(comment.Id, count)
            }
        }
    }
    fmt.Println(Comments)
    return &amp;Comments

}
</code></pre>

<p>ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来</p>

<h6>（2）出现问题的原因</h6>

<p>因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量</p>

<h6>（3）解决问题</h6>

<pre><code class="language-go">func ClearComments() bool {
    var comments []model.Comment
    Comments = comments
    return true
}

</code></pre>

<p>这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现</p>

<h4>这里我还加了一个小小的随机头像功能</h4>

<pre><code class="language-go">if  CommentName == user.Name &amp;&amp; CommentEmail == user.UserEmail {
        fmt.Println(&#34;进入了1&#34;)
        comment.Img =user.UserImg
        //找相同评论人
    }else if CommentName == one.CommentName &amp;&amp; CommentEmail == one.CommentEmail {
        fmt.Println(&#34;进入了2&#34;)
        comment.Img =one.Img
        //随机选头像
    }else{
        fmt.Println(&#34;进入了3&#34;)
        comment.Img =middleware.GetImg()
    }
</code></pre>

<h5>123分别代表三种不同的用户群体</h5>

<p>1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
<img src="/static/images/%e5%a4%b4%e5%83%8f1.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f2.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f3.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f4.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f5.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f6.png" alt=""/></p>

<h3>2、归档功能</h3>

<h4>blog的结构体属性如下</h4>

<pre><code class="language-go">package model

type Blog struct {
    Id           int
    Title        string    `form:&#34;title&#34; json:&#34;title&#34;`                          //标题
    Content      string    `gorm:&#34;type:longtext&#34; form:&#34;content&#34; json:&#34;content&#34;` //内容
    Image        string    `gorm:&#34;type:text&#34; form:&#34;image&#34; json:&#34;image&#34;`         //首图
    Numb         int       `form:&#34;numb&#34; json:&#34;numb&#34;`                            //次数
    Flag         string    `form:&#34;flag&#34; json:&#34;flag&#34;`                            //原创或者转载
    Appreciation string    `form:&#34;appreciation&#34; json:&#34;appreciation&#34;`            //打赏开关
    ShareInfo    string    `form:&#34;shareInfo&#34; json:&#34;shareInfo&#34;`                  //版权开关
    Comment      string    `form:&#34;comment&#34; json:&#34;comment&#34;`                      //评论开关
    Recommend    string    `form:&#34;recommend&#34; json:&#34;recommend&#34;`                  //推荐开关
    Description  string    `gorm:&#34;type:text&#34; form:&#34;description&#34; json:&#34;description&#34;`
    CreatTime    string    `form:&#34;creatTime&#34;  json:&#34;creat_time,omitempty&#34;`   //创建时间
    UpdateTime   string    `form:&#34;updateTime&#34;  json:&#34;update_time,omitempty&#34;` //更新时间
    Comments     []Comment `form:&#34;comments&#34; json:&#34;comments&#34;`
    TypeId       int       `form:&#34;typeId&#34; json:&#34;typeId&#34;`
    Type         Type      `form:&#34;type&#34; gorm:&#34;ForeignKey:TypeId&#34;`
    Year         int       `form:&#34;year&#34; json:&#34;year&#34;`
    Month        int       `form:&#34;month&#34; json:&#34;month&#34;`
    Day          int       `form:&#34;day&#34; json:&#34;day&#34;`
}

</code></pre>

<h4>实现方法</h4>

<p>我的思路是创建三个时间节点
year month day
利用sql分组查询</p>

<h5>Group By分组查询步骤</h5>

<h6>（1）先按照年份查询</h6>

<h6>（2）再按照年份遍历每个月份</h6>

<p>并将所有保存在一个切片中</p>

<h6>（3）按照月份遍历每个月的所有文章</h6>

<p>保存在一个Map中，key是对应的月份，value是每个月份的所有文章</p>

<h4>自此归档功能实现</h4>

<h2>3.已知BUG</h2>

<h3>后台退出功能</h3>

<p>后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧</p>

<p>开源地址
<a href="https://github.com/likewl/blog" title="github" rel="nofollow">github</a>
<a href="https://gitee.com/nculike/blog" title="gitee" rel="nofollow">gitee</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:53:40][0m  [36;1m[0.26ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:53:56][0m  [36;1m[0.57ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 09:53:56][0m  [36;1m[0.77ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 09:53:56][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 09:53:56][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 09:53:56][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 09:53:56][0m  [36;1m[0.33ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-21 09:53:59][0m  [36;1m[0.61ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:53:59][0m  [36;1m[0.27ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 09:53:59][0m  [36;1m[0.73ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-21 09:53:59][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:54:00][0m  [36;1m[0.59ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 09:54:00][0m  [36;1m[0.29ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:144)[0m 
[33m[2020-07-21 09:54:00][0m  [36;1m[0.74ms][0m   SELECT * FROM `blogs` GROUP BY YEAR DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:157)[0m 
[33m[2020-07-21 09:54:00][0m  [36;1m[0.74ms][0m   SELECT * FROM `blogs` where year = 2020 GROUP BY month DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:169)[0m 
[33m[2020-07-21 09:54:00][0m  [36;1m[0.65ms][0m   SELECT * FROM `blogs` where year = 2020 and month = 7 ORDER BY `id` DESC  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 09:54:00][0m  [36;1m[0.49ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=4  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 09:54:00][0m  [36;1m[0.39ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=3  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 09:54:00][0m  [36;1m[0.35ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=2  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 09:54:00][0m  [36;1m[0.37ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:54:01][0m  [36;1m[0.72ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:54:02][0m  [36;1m[0.52ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 09:54:02][0m  [36;1m[0.23ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:144)[0m 
[33m[2020-07-21 09:54:02][0m  [36;1m[0.65ms][0m   SELECT * FROM `blogs` GROUP BY YEAR DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:157)[0m 
[33m[2020-07-21 09:54:02][0m  [36;1m[0.67ms][0m   SELECT * FROM `blogs` where year = 2020 GROUP BY month DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:169)[0m 
[33m[2020-07-21 09:54:02][0m  [36;1m[0.62ms][0m   SELECT * FROM `blogs` where year = 2020 and month = 7 ORDER BY `id` DESC  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 09:54:02][0m  [36;1m[0.38ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=4  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 09:54:02][0m  [36;1m[0.32ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=3  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 09:54:02][0m  [36;1m[0.35ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=2  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 09:54:02][0m  [36;1m[0.32ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-21 09:54:03][0m  [36;1m[0.53ms][0m  SELECT * FROM `tags`    
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:54:03][0m  [36;1m[0.26ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 09:54:03][0m  [36;1m[0.72ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:31)[0m 
[33m[2020-07-21 09:54:03][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `tags`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-21 09:54:04][0m  [36;1m[0.51ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:54:04][0m  [36;1m[0.26ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 09:54:04][0m  [36;1m[0.66ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-21 09:54:04][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:54:04][0m  [36;1m[0.64ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 09:54:04][0m  [36;1m[0.83ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 09:54:04][0m  [36;1m[0.22ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 09:54:04][0m  [36;1m[0.38ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 09:54:04][0m  [36;1m[0.32ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 09:54:04][0m  [36;1m[0.38ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:58:13][0m  [36;1m[0.58ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:58:14][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 09:58:14][0m  [36;1m[0.25ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:144)[0m 
[33m[2020-07-21 09:58:14][0m  [36;1m[0.60ms][0m   SELECT * FROM `blogs` GROUP BY YEAR DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:157)[0m 
[33m[2020-07-21 09:58:14][0m  [36;1m[0.64ms][0m   SELECT * FROM `blogs` where year = 2020 GROUP BY month DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:169)[0m 
[33m[2020-07-21 09:58:14][0m  [36;1m[0.62ms][0m   SELECT * FROM `blogs` where year = 2020 and month = 7 ORDER BY `id` DESC  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 09:58:14][0m  [36;1m[0.38ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=4  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 09:58:14][0m  [36;1m[0.33ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=3  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 09:58:14][0m  [36;1m[0.34ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=2  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 09:58:14][0m  [36;1m[0.33ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-21 09:58:15][0m  [36;1m[0.53ms][0m  SELECT * FROM `tags`    
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:58:15][0m  [36;1m[0.30ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 09:58:15][0m  [36;1m[0.69ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:31)[0m 
[33m[2020-07-21 09:58:15][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `tags`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-21 09:58:17][0m  [36;1m[0.40ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 2)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-21 09:58:17][0m  [36;1m[0.50ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=2  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-21 09:58:17][0m  [36;1m[0.47ms][0m  UPDATE `blogs` SET `title` = '解决Linux关闭终端后运行的程序自动停止', `content` = '# 问题发现
  昨天博客发布，操作完关闭终端就睡了
  然而今天醒来突然发现终端不能访问了
  查看发现原来博客项目进程被杀死了
# 解决办法
    go build main.go
执行完后

    nohup ./main &
让程序在后台运行就可了


[========]
# ps:这个方法并不完美，因为我也是刚刚接触还不知道怎么切回来', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3696516981,3671280793&fm=26&gp=0.jpg', `numb` = 16, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '昨天博客发布，操作完关闭终端就睡了，然而今天醒来突然发现终端不能访问了，查看发现原来博客项目进程被杀死了', `creat_time` = '2020-07-19 19:05:36', `update_time` = '2020-07-19 19:05:36', `type_id` = 2, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 3  
[36;31m[1 rows affected or returned ][0m 
<h1>问题发现</h1>

<p>昨天博客发布，操作完关闭终端就睡了
  然而今天醒来突然发现终端不能访问了
  查看发现原来博客项目进程被杀死了</p>

<h1>解决办法</h1>

<pre><code>go build main.go
</code></pre>

<p>执行完后</p>

<pre><code>nohup ./main &amp;
</code></pre>

<p>让程序在后台运行就可了</p>

<p>[========]</p>

<h1>ps:这个方法并不完美，因为我也是刚刚接触还不知道怎么切回来</h1>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:58:17][0m  [36;1m[1.92ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 09:58:55][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 09:58:55][0m  [36;1m[0.76ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 09:58:55][0m  [36;1m[0.26ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 09:58:55][0m  [36;1m[0.33ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 09:58:55][0m  [36;1m[0.28ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 09:58:55][0m  [36;1m[0.37ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 
2020/07/21 09:58:55 http: panic serving 116.238.210.229:49807: write tcp 172.16.13.169:80->116.238.210.229:49807: write: broken pipe
goroutine 2756 [running]:
net/http.(*conn).serve.func1(0xc0000bea00)
	/usr/local/go/src/net/http/server.go:1772 +0x139
panic(0xb50ee0, 0xc0001dab40)
	/usr/local/go/src/runtime/panic.go:975 +0x3e3
github.com/gin-gonic/gin.(*Context).Render(0xc0005bc2d0, 0xc8, 0xd0e260, 0xc0005b6a50)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:842 +0x173
github.com/gin-gonic/gin.(*Context).HTML(0xc0005bc2d0, 0xc8, 0xbf926d, 0x10, 0xb43d60, 0xc0006988a0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:851 +0x99
blog/controller/page.IndexHandler(0xc0005bc2d0)
	/usr/workspace/src/blog/controller/page/pagesController.go:22 +0x570
github.com/gin-gonic/gin.(*Context).Next(0xc0005bc2d0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:161 +0x3b
github.com/gin-contrib/sessions.Sessions.func1(0xc0005bc2d0)
	/usr/workspace/pkg/mod/github.com/gin-contrib/sessions@v0.0.3/sessions.go:52 +0x16d
github.com/gin-gonic/gin.(*Context).Next(0xc0005bc2d0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:161 +0x3b
github.com/gin-gonic/gin.(*Engine).handleHTTPRequest(0xc0003b8500, 0xc0005bc2d0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/gin.go:409 +0x666
github.com/gin-gonic/gin.(*Engine).ServeHTTP(0xc0003b8500, 0xd12a40, 0xc0000b8460, 0xc0003ca900)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/gin.go:367 +0x14d
net/http.serverHandler.ServeHTTP(0xc0000b8380, 0xd12a40, 0xc0000b8460, 0xc0003ca900)
	/usr/local/go/src/net/http/server.go:2807 +0xa3
net/http.(*conn).serve(0xc0000bea00, 0xd15200, 0xc0001b3b80)
	/usr/local/go/src/net/http/server.go:1895 +0x86c
created by net/http.(*Server).Serve
	/usr/local/go/src/net/http/server.go:2933 +0x35c

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 10:35:46][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 10:35:46][0m  [36;1m[0.71ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 10:35:46][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 10:35:46][0m  [36;1m[0.29ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 10:35:46][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 10:35:46][0m  [36;1m[0.32ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 11:39:53][0m  [36;1m[0.62ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 11:39:53][0m  [36;1m[0.72ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 11:39:53][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 11:39:53][0m  [36;1m[0.29ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 11:39:53][0m  [36;1m[0.24ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 11:39:53][0m  [36;1m[0.34ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 
2020/07/21 11:39:53 http: panic serving 106.15.201.111:59268: write tcp 172.16.13.169:80->106.15.201.111:59268: write: broken pipe
goroutine 2812 [running]:
net/http.(*conn).serve.func1(0xc0000be000)
	/usr/local/go/src/net/http/server.go:1772 +0x139
panic(0xb50ee0, 0xc0001da730)
	/usr/local/go/src/runtime/panic.go:975 +0x3e3
github.com/gin-gonic/gin.(*Context).Render(0xc0005bc2d0, 0xc8, 0xd0e260, 0xc0002c2930)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:842 +0x173
github.com/gin-gonic/gin.(*Context).HTML(0xc0005bc2d0, 0xc8, 0xbf926d, 0x10, 0xb43d60, 0xc00029a2a0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:851 +0x99
blog/controller/page.IndexHandler(0xc0005bc2d0)
	/usr/workspace/src/blog/controller/page/pagesController.go:22 +0x570
github.com/gin-gonic/gin.(*Context).Next(0xc0005bc2d0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:161 +0x3b
github.com/gin-contrib/sessions.Sessions.func1(0xc0005bc2d0)
	/usr/workspace/pkg/mod/github.com/gin-contrib/sessions@v0.0.3/sessions.go:52 +0x16d
github.com/gin-gonic/gin.(*Context).Next(0xc0005bc2d0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:161 +0x3b
github.com/gin-gonic/gin.(*Engine).handleHTTPRequest(0xc0003b8500, 0xc0005bc2d0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/gin.go:409 +0x666
github.com/gin-gonic/gin.(*Engine).ServeHTTP(0xc0003b8500, 0xd12a40, 0xc0000b80e0, 0xc0003ca000)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/gin.go:367 +0x14d
net/http.serverHandler.ServeHTTP(0xc0000b8380, 0xd12a40, 0xc0000b80e0, 0xc0003ca000)
	/usr/local/go/src/net/http/server.go:2807 +0xa3
net/http.(*conn).serve(0xc0000be000, 0xd15200, 0xc0001b2040)
	/usr/local/go/src/net/http/server.go:1895 +0x86c
created by net/http.(*Server).Serve
	/usr/local/go/src/net/http/server.go:2933 +0x35c

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 12:28:59][0m  [36;1m[0.57ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 12:28:59][0m  [36;1m[0.70ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 12:28:59][0m  [36;1m[0.18ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 12:28:59][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 12:28:59][0m  [36;1m[0.29ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 12:28:59][0m  [36;1m[0.31ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 12:36:52][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 12:36:52][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 12:36:52][0m  [36;1m[0.72ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 12:36:52][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 12:36:52][0m  [36;1m[0.31ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 12:36:52][0m  [36;1m[0.25ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 12:36:52][0m  [36;1m[0.34ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 12:53:12][0m  [36;1m[0.53ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 12:53:12][0m  [36;1m[0.73ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 12:53:12][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 12:53:12][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 12:53:12][0m  [36;1m[0.27ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 12:53:12][0m  [36;1m[0.32ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 12:53:13][0m  [36;1m[0.52ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 12:53:13][0m  [36;1m[0.69ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 12:53:13][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 12:53:13][0m  [36;1m[0.29ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 12:53:13][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 12:53:13][0m  [36;1m[0.31ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 14:17:39][0m  [36;1m[0.51ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 14:17:39][0m  [36;1m[0.70ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 14:17:39][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 14:17:39][0m  [36;1m[0.32ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 14:17:39][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 14:17:39][0m  [36;1m[0.31ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-21 14:17:40][0m  [36;1m[0.52ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 14:17:40][0m  [36;1m[0.25ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 14:17:40][0m  [36;1m[0.65ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-21 14:17:40][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 14:17:41][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 14:17:41][0m  [36;1m[0.70ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 14:17:41][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 14:17:41][0m  [36;1m[0.29ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 14:17:41][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 14:17:41][0m  [36;1m[0.32ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-21 14:17:43][0m  [36;1m[0.46ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 1)  
[36;31m[2 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-21 14:17:43][0m  [36;1m[0.54ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=1  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-21 14:17:43][0m  [36;1m[0.46ms][0m  UPDATE `blogs` SET `title` = 'golang项目简单服务器部署到阿里云(linux)', `content` = '# 我个人比较推荐使用Xftp和Xshell 
# 重要是个人免费用
# 舒服又好用

# 1.下载安装go安装包：
	## （1）go语言下载地址：
	[Go语言中文网](https://studygolang.com/dl "Go语言中文网")
下载linux版本的安装包。

## （2）使用Xftp将安装包上传至指定的路径：

![](https://img-blog.csdnimg.cn/20190719142701389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
	这里上传到root目录下就行
	方便解压
## （3）解压并移到/usr/local/下：

进入指定目录，查看已有文件并且解压文件：

![](https://img-blog.csdnimg.cn/20190719143211340.png)
```
#在root目录输入ls查看目录文件
ls
#在root解压go包
tar -zxvf go的包名
```

解压完成后发现目录下多了一个go文件夹：
![](https://img-blog.csdnimg.cn/20190719143042938.png)
将文件夹移动到/usr/local/
![](https://img-blog.csdnimg.cn/20190719143137645.png)
# 2.配置环境变量：
## （1）进入目的目录查看go文件夹是否移动成功：
![](https://img-blog.csdnimg.cn/20190719143506382.png)
## （2）在usr下创建文件夹，用来存放自己的项目：
workspace
## （3）进入新建的目录workspace新建三个文件夹：
src
pkg
bin
### 说明：

	src 目录存放的是我们的go源代码，不同工程项目的代码以包名区分
	pkg 编译后生成的文件
	bin文件夹存放go install命名生成的可执行文件（这个文件夹会配置到环境变量中）
## （4）配置环境变量：

进入 /etc 修改profile文件：
![](https://img-blog.csdnimg.cn/20190719144319621.png)
```
#进入etc目录
cd /etc/
#配置 profile
vim profile
```
![](https://img-blog.csdnimg.cn/20190719145650864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
在此文件夹下加入上图的代码，代码如下：
```
// 设置go安装路径
export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin
 
// 设置工程目录
export GOPATH=/usr/workspace
export PATH=$PATH:$GOPATH/bin
```

## （5）刷新环境变量：
```
source /etc/profile
```
##  （6）查看go环境是否配置成功：
```
go version
```
## （7）查看详细配置：
```
go env
```
结果如下：  
![](https://img-blog.csdnimg.cn/20190719145255720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70) 
# 3.上传项目代码：
在刚刚创建的workspace下新创建的三个文件夹中，src 目录存放的是我们的go源代码
# 4运行
```go
go build main.go
//或者
go run main.go
```
最后执行 ./main 就行了。
如果想让项目在后台执行：执行 nohup ./main & ，这样就可以程序在后台运行了。

参考教程https://blog.csdn.net/qq_42410605/article/details/96479892', `image` = 'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3111860246,1925938903&fm=26&gp=0.jpg', `numb` = 44, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '简单又详细的教程', `creat_time` = '2020-07-19 18:32:31', `update_time` = '2020-07-20 13:11:56', `type_id` = 1, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 1  
[36;31m[1 rows affected or returned ][0m 
<h1>我个人比较推荐使用Xftp和Xshell</h1>

<h1>重要是个人免费用</h1>

<h1>舒服又好用</h1>

<h1>1.下载安装go安装包：</h1>

<pre><code>## （1）go语言下载地址：
[Go语言中文网](https://studygolang.com/dl &#34;Go语言中文网&#34;)
</code></pre>

<p>下载linux版本的安装包。</p>

<h2>（2）使用Xftp将安装包上传至指定的路径：</h2>

<p><img src="https://img-blog.csdnimg.cn/20190719142701389.png?x-oss-process=image%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1%2Csize_16%2Ccolor_FFFFFF%2Ct_70" alt=""/>
    这里上传到root目录下就行
    方便解压</p>

<h2>（3）解压并移到/usr/local/下：</h2>

<p>进入指定目录，查看已有文件并且解压文件：</p>

<p><img src="https://img-blog.csdnimg.cn/20190719143211340.png" alt=""/></p>

<pre><code>#在root目录输入ls查看目录文件
ls
#在root解压go包
tar -zxvf go的包名
</code></pre>

<p>解压完成后发现目录下多了一个go文件夹：
<img src="https://img-blog.csdnimg.cn/20190719143042938.png" alt=""/>
将文件夹移动到/usr/local/
<img src="https://img-blog.csdnimg.cn/20190719143137645.png" alt=""/></p>

<h1>2.配置环境变量：</h1>

<h2>（1）进入目的目录查看go文件夹是否移动成功：</h2>

<p><img src="https://img-blog.csdnimg.cn/20190719143506382.png" alt=""/></p>

<h2>（2）在usr下创建文件夹，用来存放自己的项目：</h2>

<p>workspace</p>

<h2>（3）进入新建的目录workspace新建三个文件夹：</h2>

<p>src
pkg
bin</p>

<h3>说明：</h3>

<pre><code>src 目录存放的是我们的go源代码，不同工程项目的代码以包名区分
pkg 编译后生成的文件
bin文件夹存放go install命名生成的可执行文件（这个文件夹会配置到环境变量中）
</code></pre>

<h2>（4）配置环境变量：</h2>

<p>进入 /etc 修改profile文件：
<img src="https://img-blog.csdnimg.cn/20190719144319621.png" alt=""/></p>

<pre><code>#进入etc目录
cd /etc/
#配置 profile
vim profile
</code></pre>

<p><img src="https://img-blog.csdnimg.cn/20190719145650864.png?x-oss-process=image%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1%2Csize_16%2Ccolor_FFFFFF%2Ct_70" alt=""/>
在此文件夹下加入上图的代码，代码如下：</p>

<pre><code>// 设置go安装路径
export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin
 
// 设置工程目录
export GOPATH=/usr/workspace
export PATH=$PATH:$GOPATH/bin
</code></pre>

<h2>（5）刷新环境变量：</h2>

<pre><code>source /etc/profile
</code></pre>

<h2> （6）查看go环境是否配置成功：</h2>

<pre><code>go version
</code></pre>

<h2>（7）查看详细配置：</h2>

<pre><code>go env
</code></pre>

<p>结果如下：  
<img src="https://img-blog.csdnimg.cn/20190719145255720.png?x-oss-process=image%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1%2Csize_16%2Ccolor_FFFFFF%2Ct_70" alt=""/> </p>

<h1>3.上传项目代码：</h1>

<p>在刚刚创建的workspace下新创建的三个文件夹中，src 目录存放的是我们的go源代码</p>

<h1>4运行</h1>

<pre><code class="language-go">go build main.go
//或者
go run main.go
</code></pre>

<p>最后执行 ./main 就行了。
如果想让项目在后台执行：执行 nohup ./main &amp; ，这样就可以程序在后台运行了。</p>

<p>参考教程<a href="https://blog.csdn.net/qq_42410605/article/details/96479892" rel="nofollow">https://blog.csdn.net/qq_42410605/article/details/96479892</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 14:17:43][0m  [36;1m[0.27ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-21 14:17:43][0m  [36;1m[0.43ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 1)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-21 14:17:43][0m  [36;1m[0.38ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 2)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-21 14:17:43][0m  [36;1m[0.34ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 4)  
[36;31m[0 rows affected or returned ][0m 
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-21 14:17:43][0m  [36;1m[0.40ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 3)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-21 14:17:43][0m  [36;1m[0.34ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 5)  
[36;31m[0 rows affected or returned ][0m 
[{5 1 3 like 狗科 535889315@qq.com /static/images/header.jpg ？？？ 2020-07-20 13:30:17 <nil> []}]
[{5 1 3 like 狗科 535889315@qq.com /static/images/header.jpg ？？？ 2020-07-20 13:30:17 <nil> []}]

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 14:18:49][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 14:18:49][0m  [36;1m[0.71ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 14:18:49][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 14:18:49][0m  [36;1m[0.29ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 14:18:49][0m  [36;1m[0.25ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 14:18:49][0m  [36;1m[0.31ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 14:19:43][0m  [36;1m[0.97ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 14:19:43][0m  [36;1m[2.44ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 14:19:43][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 14:19:43][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 14:19:43][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 14:19:43][0m  [36;1m[0.36ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-21 14:19:45][0m  [36;1m[0.58ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 14:19:45][0m  [36;1m[0.25ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 14:19:45][0m  [36;1m[0.74ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-21 14:19:45][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-21 14:19:46][0m  [36;1m[0.72ms][0m  SELECT * FROM `tags`    
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 14:19:46][0m  [36;1m[0.33ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 14:19:46][0m  [36;1m[0.71ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:31)[0m 
[33m[2020-07-21 14:19:46][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `tags`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 14:19:46][0m  [36;1m[0.63ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 14:19:46][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:144)[0m 
[33m[2020-07-21 14:19:46][0m  [36;1m[0.64ms][0m   SELECT * FROM `blogs` GROUP BY YEAR DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:157)[0m 
[33m[2020-07-21 14:19:46][0m  [36;1m[1.10ms][0m   SELECT * FROM `blogs` where year = 2020 GROUP BY month DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:169)[0m 
[33m[2020-07-21 14:19:46][0m  [36;1m[0.61ms][0m   SELECT * FROM `blogs` where year = 2020 and month = 7 ORDER BY `id` DESC  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 14:19:46][0m  [36;1m[0.42ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=4  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 14:19:46][0m  [36;1m[0.34ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=3  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 14:19:46][0m  [36;1m[0.36ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=2  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 14:19:46][0m  [36;1m[0.34ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 14:39:05][0m  [36;1m[0.56ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 14:39:05][0m  [36;1m[0.72ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 14:39:05][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 14:39:05][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 14:39:05][0m  [36;1m[0.28ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 14:39:05][0m  [36;1m[0.34ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 14:40:47][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 14:40:47][0m  [36;1m[0.67ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 14:40:47][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 14:40:47][0m  [36;1m[0.29ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 14:40:47][0m  [36;1m[0.25ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 14:40:47][0m  [36;1m[0.31ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 14:41:48][0m  [36;1m[0.58ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 14:41:48][0m  [36;1m[0.79ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 14:41:48][0m  [36;1m[0.22ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 14:41:48][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 14:41:48][0m  [36;1m[0.27ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 14:41:48][0m  [36;1m[0.36ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 14:41:48][0m  [36;1m[0.59ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 14:41:48][0m  [36;1m[0.76ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 14:41:48][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 14:41:48][0m  [36;1m[0.31ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 14:41:48][0m  [36;1m[0.30ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 14:41:48][0m  [36;1m[0.35ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 14:41:49][0m  [36;1m[0.56ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 14:41:49][0m  [36;1m[0.77ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 14:41:49][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 14:41:49][0m  [36;1m[0.33ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 14:41:49][0m  [36;1m[0.33ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 14:41:49][0m  [36;1m[0.34ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 14:41:50][0m  [36;1m[0.53ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 14:41:50][0m  [36;1m[0.70ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 14:41:50][0m  [36;1m[0.22ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 14:41:50][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 14:41:50][0m  [36;1m[0.28ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 14:41:50][0m  [36;1m[0.36ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 14:41:53][0m  [36;1m[0.56ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 14:41:53][0m  [36;1m[0.75ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 14:41:53][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 14:41:53][0m  [36;1m[0.33ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 14:41:53][0m  [36;1m[0.27ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 14:41:53][0m  [36;1m[0.37ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 14:42:02][0m  [36;1m[0.51ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 14:42:02][0m  [36;1m[0.67ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 14:42:02][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 14:42:02][0m  [36;1m[0.29ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 14:42:02][0m  [36;1m[0.24ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 14:42:02][0m  [36;1m[0.31ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 14:42:21][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 14:42:21][0m  [36;1m[0.72ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 14:42:21][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 14:42:21][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 14:42:21][0m  [36;1m[0.27ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 14:42:21][0m  [36;1m[0.36ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 14:42:34][0m  [36;1m[0.58ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 14:42:34][0m  [36;1m[0.71ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 14:42:34][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 14:42:34][0m  [36;1m[0.32ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 14:42:34][0m  [36;1m[0.35ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 14:42:34][0m  [36;1m[0.32ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 14:42:54][0m  [36;1m[0.52ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 14:42:54][0m  [36;1m[0.72ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 14:42:54][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 14:42:54][0m  [36;1m[0.35ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 14:42:54][0m  [36;1m[0.27ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 14:42:54][0m  [36;1m[0.35ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-21 14:43:09][0m  [36;1m[0.41ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 2)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-21 14:43:09][0m  [36;1m[0.48ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=2  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-21 14:43:09][0m  [36;1m[0.44ms][0m  UPDATE `blogs` SET `title` = '解决Linux关闭终端后运行的程序自动停止', `content` = '# 问题发现
  昨天博客发布，操作完关闭终端就睡了
  然而今天醒来突然发现终端不能访问了
  查看发现原来博客项目进程被杀死了
# 解决办法
    go build main.go
执行完后

    nohup ./main &
让程序在后台运行就可了


[========]
# ps:这个方法并不完美，因为我也是刚刚接触还不知道怎么切回来', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3696516981,3671280793&fm=26&gp=0.jpg', `numb` = 17, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '昨天博客发布，操作完关闭终端就睡了，然而今天醒来突然发现终端不能访问了，查看发现原来博客项目进程被杀死了', `creat_time` = '2020-07-19 19:05:36', `update_time` = '2020-07-19 19:05:36', `type_id` = 2, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 3  
[36;31m[1 rows affected or returned ][0m 
<h1>问题发现</h1>

<p>昨天博客发布，操作完关闭终端就睡了
  然而今天醒来突然发现终端不能访问了
  查看发现原来博客项目进程被杀死了</p>

<h1>解决办法</h1>

<pre><code>go build main.go
</code></pre>

<p>执行完后</p>

<pre><code>nohup ./main &amp;
</code></pre>

<p>让程序在后台运行就可了</p>

<p>[========]</p>

<h1>ps:这个方法并不完美，因为我也是刚刚接触还不知道怎么切回来</h1>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 14:43:09][0m  [36;1m[0.31ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-21 14:43:18][0m  [36;1m[0.36ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 2)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-21 14:43:18][0m  [36;1m[0.44ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=2  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-21 14:43:18][0m  [36;1m[0.36ms][0m  UPDATE `blogs` SET `title` = '解决Linux关闭终端后运行的程序自动停止', `content` = '# 问题发现
  昨天博客发布，操作完关闭终端就睡了
  然而今天醒来突然发现终端不能访问了
  查看发现原来博客项目进程被杀死了
# 解决办法
    go build main.go
执行完后

    nohup ./main &
让程序在后台运行就可了


[========]
# ps:这个方法并不完美，因为我也是刚刚接触还不知道怎么切回来', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3696516981,3671280793&fm=26&gp=0.jpg', `numb` = 18, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '昨天博客发布，操作完关闭终端就睡了，然而今天醒来突然发现终端不能访问了，查看发现原来博客项目进程被杀死了', `creat_time` = '2020-07-19 19:05:36', `update_time` = '2020-07-19 19:05:36', `type_id` = 2, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 3  
[36;31m[1 rows affected or returned ][0m 
<h1>问题发现</h1>

<p>昨天博客发布，操作完关闭终端就睡了
  然而今天醒来突然发现终端不能访问了
  查看发现原来博客项目进程被杀死了</p>

<h1>解决办法</h1>

<pre><code>go build main.go
</code></pre>

<p>执行完后</p>

<pre><code>nohup ./main &amp;
</code></pre>

<p>让程序在后台运行就可了</p>

<p>[========]</p>

<h1>ps:这个方法并不完美，因为我也是刚刚接触还不知道怎么切回来</h1>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 14:43:18][0m  [36;1m[0.24ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 14:43:19][0m  [36;1m[0.52ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 14:43:19][0m  [36;1m[0.76ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 14:43:19][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 14:43:19][0m  [36;1m[0.29ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 14:43:19][0m  [36;1m[0.25ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 14:43:19][0m  [36;1m[0.38ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 14:43:21][0m  [36;1m[0.60ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 14:43:21][0m  [36;1m[0.91ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 14:43:21][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 14:43:21][0m  [36;1m[0.29ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 14:43:21][0m  [36;1m[0.28ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 14:43:21][0m  [36;1m[0.49ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 14:43:34][0m  [36;1m[0.60ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 14:43:34][0m  [36;1m[1.07ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 14:43:34][0m  [36;1m[2.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 14:43:34][0m  [36;1m[0.37ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 14:43:34][0m  [36;1m[0.28ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 14:43:34][0m  [36;1m[0.39ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-21 14:43:36][0m  [36;1m[0.63ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 4)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-21 14:43:36][0m  [36;1m[0.80ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=4  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-21 14:43:36][0m  [36;1m[0.76ms][0m  UPDATE `blogs` SET `title` = '本博客开源公告', `content` = '今天本博客评论功能发布
# 自今天起，本博客基本功能已经完成
## 发布V1.0版本并开源
## 博客语言说明
#### 本博客后端是用golang 的gin框架+gorm编写
前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的
#### 博客效果参考本站
#一、博客简介
## 1.博客目录

    blog
    ├────controller
	├────└───admin
	|	|	├──adminblog.go
	|	|	├───adminController.go
	|	|	├──adminTag.go
	|	|	├──adminType.go
	|	|	└──adminUser.go
	|	└──page
	|		├──404.go
	|		├───about.go
	|		├──archives.go
	|		├──blog.go
	|		├──comment.go
	|		├──pagesController.go
	|		├──researchController.go
	|		└──tagsController.go
    ├── dao
	│	├──blogs.go
	│	├──comment.go
	│	├──sql.go
	│	├──tags.go
	│	├──types.go
	│	└──user.go
    ├── logic
    │   └── user.go
    ├── middlerware
	│	├──function.go
	│	├──getImg.go
	│	├──getTime.go
	│	├──markdown.go
	│	├──select.go
	│	└──session.go
    ├── model
	│	├──blog.go
	│	├──commnent.go
	│	├──tag.go
	│	├──type.go
	│	└──user/go
    ├── static
	│	└──静态文件（头像、图片、logo、css、js等）
    ├── templates
	│	└──html模板文件
    ├── go.mod（依赖）
    └── main.go
    

## 2.相关功能实现简介
### 1、评论及回复功能
comment的结构体属性如下
```go
package model

type Comment struct {
	Id     int //评论id
	BlogId int //博文id
	ReCommentId    int    //父评论id
	CommentName string //评论人姓名
	ReCommentName  string //父评论人姓名
	CommentEmail   string
	Img            string
	CommentContent string `gorm:"type:text" form:"CommentContent" json:"CommentContent"` //评论内容
	CommentTime    string ` json:"comment_time,omitempty"`
	Parent         *Comment
	Comments       []Comment
}
```
#### 实现方法
##### 1先通过查找父评论为-1的顶级评论
父评论Id为-1说明他不是任何评论的子评论
##### 2在html上遍历所有的顶级评论
在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论
###### （1）递归存储每个顶级评论的子评论
这里我用一个切片来储存一个顶级评论的所有子评论
```go
var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
	var comments []model.Comment
	DB.Debug().Where("re_comment_id = -1 AND blog_id = ?", id).Find(&comments)
	return &comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
	if count != 0 {
		fmt.Println("if判断1")
		var comments []model.Comment
		DB.Debug().Where("re_comment_id = ?", id).Find(&comments)
		count = len(comments)
		if count != 0 {
			fmt.Println("if判断2")
			for _, comment := range comments {
				fmt.Println("for判断1")
				Comments = append(Comments, comment)
				SelectCommentByComment(comment.Id, count)
			}
		}
	}
	fmt.Println(Comments)
	return &Comments

}
```
ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来
###### （2）出现问题的原因
因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量
###### （3）解决问题
```go
func ClearComments() bool {
	var comments []model.Comment
	Comments = comments
	return true
}

```
这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现
#### 这里我还加了一个小小的随机头像功能
```go
if  CommentName == user.Name && CommentEmail == user.UserEmail {
		fmt.Println("进入了1")
		comment.Img =user.UserImg
		//找相同评论人
	}else if CommentName == one.CommentName && CommentEmail == one.CommentEmail {
		fmt.Println("进入了2")
		comment.Img =one.Img
		//随机选头像
	}else{
		fmt.Println("进入了3")
		comment.Img =middleware.GetImg()
	}
```
##### 123分别代表三种不同的用户群体
1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
![](/static/images/%e5%a4%b4%e5%83%8f1.png)![](/static/images/%e5%a4%b4%e5%83%8f2.png)![](/static/images/%e5%a4%b4%e5%83%8f3.png)![](/static/images/%e5%a4%b4%e5%83%8f4.png)![](/static/images/%e5%a4%b4%e5%83%8f5.png)![](/static/images/%e5%a4%b4%e5%83%8f6.png)
### 2、归档功能
#### blog的结构体属性如下
```go
package model

type Blog struct {
	Id           int
	Title        string    `form:"title" json:"title"`                          //标题
	Content      string    `gorm:"type:longtext" form:"content" json:"content"` //内容
	Image        string    `gorm:"type:text" form:"image" json:"image"`         //首图
	Numb         int       `form:"numb" json:"numb"`                            //次数
	Flag         string    `form:"flag" json:"flag"`                            //原创或者转载
	Appreciation string    `form:"appreciation" json:"appreciation"`            //打赏开关
	ShareInfo    string    `form:"shareInfo" json:"shareInfo"`                  //版权开关
	Comment      string    `form:"comment" json:"comment"`                      //评论开关
	Recommend    string    `form:"recommend" json:"recommend"`                  //推荐开关
	Description  string    `gorm:"type:text" form:"description" json:"description"`
	CreatTime    string    `form:"creatTime"  json:"creat_time,omitempty"`   //创建时间
	UpdateTime   string    `form:"updateTime"  json:"update_time,omitempty"` //更新时间
	Comments     []Comment `form:"comments" json:"comments"`
	TypeId       int       `form:"typeId" json:"typeId"`
	Type         Type      `form:"type" gorm:"ForeignKey:TypeId"`
	Year         int       `form:"year" json:"year"`
	Month        int       `form:"month" json:"month"`
	Day          int       `form:"day" json:"day"`
}

```
#### 实现方法
我的思路是创建三个时间节点
year month day 
利用sql分组查询
##### Group By分组查询步骤
###### （1）先按照年份查询
###### （2）再按照年份遍历每个月份
并将所有保存在一个切片中
###### （3）按照月份遍历每个月的所有文章
保存在一个Map中，key是对应的月份，value是每个月份的所有文章
#### 自此归档功能实现


## 3.已知BUG
### 后台退出功能
后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧

开源地址
[github](https://github.com/likewl/blog "github")
[gitee](https://gitee.com/nculike/blog "gitee")', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1535821573,4166447487&fm=26&gp=0.jpg', `numb` = 36, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '本博客后端是用golang 的gin框架+gorm编写', `creat_time` = '2020-07-20 15:24:23', `update_time` = '2020-07-20 15:24:23', `type_id` = 4, `year` = 2020, `month` = 7, `day` = 20  WHERE `blogs`.`id` = 4  
[36;31m[1 rows affected or returned ][0m 
<p>今天本博客评论功能发布</p>

<h1>自今天起，本博客基本功能已经完成</h1>

<h2>发布V1.0版本并开源</h2>

<h2>博客语言说明</h2>

<h4>本博客后端是用golang 的gin框架+gorm编写</h4>

<p>前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的</p>

<h4>博客效果参考本站</h4>

<p>#一、博客简介</p>

<h2>1.博客目录</h2>

<pre><code>blog
├────controller
├────└───admin
|   |   ├──adminblog.go
|   |   ├───adminController.go
|   |   ├──adminTag.go
|   |   ├──adminType.go
|   |   └──adminUser.go
|   └──page
|       ├──404.go
|       ├───about.go
|       ├──archives.go
|       ├──blog.go
|       ├──comment.go
|       ├──pagesController.go
|       ├──researchController.go
|       └──tagsController.go
├── dao
│   ├──blogs.go
│   ├──comment.go
│   ├──sql.go
│   ├──tags.go
│   ├──types.go
│   └──user.go
├── logic
│   └── user.go
├── middlerware
│   ├──function.go
│   ├──getImg.go
│   ├──getTime.go
│   ├──markdown.go
│   ├──select.go
│   └──session.go
├── model
│   ├──blog.go
│   ├──commnent.go
│   ├──tag.go
│   ├──type.go
│   └──user/go
├── static
│   └──静态文件（头像、图片、logo、css、js等）
├── templates
│   └──html模板文件
├── go.mod（依赖）
└── main.go
</code></pre>

<h2>2.相关功能实现简介</h2>

<h3>1、评论及回复功能</h3>

<p>comment的结构体属性如下</p>

<pre><code class="language-go">package model

type Comment struct {
    Id     int //评论id
    BlogId int //博文id
    ReCommentId    int    //父评论id
    CommentName string //评论人姓名
    ReCommentName  string //父评论人姓名
    CommentEmail   string
    Img            string
    CommentContent string `gorm:&#34;type:text&#34; form:&#34;CommentContent&#34; json:&#34;CommentContent&#34;` //评论内容
    CommentTime    string ` json:&#34;comment_time,omitempty&#34;`
    Parent         *Comment
    Comments       []Comment
}
</code></pre>

<h4>实现方法</h4>

<h5>1先通过查找父评论为-1的顶级评论</h5>

<p>父评论Id为-1说明他不是任何评论的子评论</p>

<h5>2在html上遍历所有的顶级评论</h5>

<p>在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论</p>

<h6>（1）递归存储每个顶级评论的子评论</h6>

<p>这里我用一个切片来储存一个顶级评论的所有子评论</p>

<pre><code class="language-go">var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
    var comments []model.Comment
    DB.Debug().Where(&#34;re_comment_id = -1 AND blog_id = ?&#34;, id).Find(&amp;comments)
    return &amp;comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
    if count != 0 {
        fmt.Println(&#34;if判断1&#34;)
        var comments []model.Comment
        DB.Debug().Where(&#34;re_comment_id = ?&#34;, id).Find(&amp;comments)
        count = len(comments)
        if count != 0 {
            fmt.Println(&#34;if判断2&#34;)
            for _, comment := range comments {
                fmt.Println(&#34;for判断1&#34;)
                Comments = append(Comments, comment)
                SelectCommentByComment(comment.Id, count)
            }
        }
    }
    fmt.Println(Comments)
    return &amp;Comments

}
</code></pre>

<p>ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来</p>

<h6>（2）出现问题的原因</h6>

<p>因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量</p>

<h6>（3）解决问题</h6>

<pre><code class="language-go">func ClearComments() bool {
    var comments []model.Comment
    Comments = comments
    return true
}

</code></pre>

<p>这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现</p>

<h4>这里我还加了一个小小的随机头像功能</h4>

<pre><code class="language-go">if  CommentName == user.Name &amp;&amp; CommentEmail == user.UserEmail {
        fmt.Println(&#34;进入了1&#34;)
        comment.Img =user.UserImg
        //找相同评论人
    }else if CommentName == one.CommentName &amp;&amp; CommentEmail == one.CommentEmail {
        fmt.Println(&#34;进入了2&#34;)
        comment.Img =one.Img
        //随机选头像
    }else{
        fmt.Println(&#34;进入了3&#34;)
        comment.Img =middleware.GetImg()
    }
</code></pre>

<h5>123分别代表三种不同的用户群体</h5>

<p>1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
<img src="/static/images/%e5%a4%b4%e5%83%8f1.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f2.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f3.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f4.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f5.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f6.png" alt=""/></p>

<h3>2、归档功能</h3>

<h4>blog的结构体属性如下</h4>

<pre><code class="language-go">package model

type Blog struct {
    Id           int
    Title        string    `form:&#34;title&#34; json:&#34;title&#34;`                          //标题
    Content      string    `gorm:&#34;type:longtext&#34; form:&#34;content&#34; json:&#34;content&#34;` //内容
    Image        string    `gorm:&#34;type:text&#34; form:&#34;image&#34; json:&#34;image&#34;`         //首图
    Numb         int       `form:&#34;numb&#34; json:&#34;numb&#34;`                            //次数
    Flag         string    `form:&#34;flag&#34; json:&#34;flag&#34;`                            //原创或者转载
    Appreciation string    `form:&#34;appreciation&#34; json:&#34;appreciation&#34;`            //打赏开关
    ShareInfo    string    `form:&#34;shareInfo&#34; json:&#34;shareInfo&#34;`                  //版权开关
    Comment      string    `form:&#34;comment&#34; json:&#34;comment&#34;`                      //评论开关
    Recommend    string    `form:&#34;recommend&#34; json:&#34;recommend&#34;`                  //推荐开关
    Description  string    `gorm:&#34;type:text&#34; form:&#34;description&#34; json:&#34;description&#34;`
    CreatTime    string    `form:&#34;creatTime&#34;  json:&#34;creat_time,omitempty&#34;`   //创建时间
    UpdateTime   string    `form:&#34;updateTime&#34;  json:&#34;update_time,omitempty&#34;` //更新时间
    Comments     []Comment `form:&#34;comments&#34; json:&#34;comments&#34;`
    TypeId       int       `form:&#34;typeId&#34; json:&#34;typeId&#34;`
    Type         Type      `form:&#34;type&#34; gorm:&#34;ForeignKey:TypeId&#34;`
    Year         int       `form:&#34;year&#34; json:&#34;year&#34;`
    Month        int       `form:&#34;month&#34; json:&#34;month&#34;`
    Day          int       `form:&#34;day&#34; json:&#34;day&#34;`
}

</code></pre>

<h4>实现方法</h4>

<p>我的思路是创建三个时间节点
year month day
利用sql分组查询</p>

<h5>Group By分组查询步骤</h5>

<h6>（1）先按照年份查询</h6>

<h6>（2）再按照年份遍历每个月份</h6>

<p>并将所有保存在一个切片中</p>

<h6>（3）按照月份遍历每个月的所有文章</h6>

<p>保存在一个Map中，key是对应的月份，value是每个月份的所有文章</p>

<h4>自此归档功能实现</h4>

<h2>3.已知BUG</h2>

<h3>后台退出功能</h3>

<p>后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧</p>

<p>开源地址
<a href="https://github.com/likewl/blog" title="github" rel="nofollow">github</a>
<a href="https://gitee.com/nculike/blog" title="gitee" rel="nofollow">gitee</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 14:43:36][0m  [36;1m[0.63ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 14:44:11][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 14:44:11][0m  [36;1m[0.69ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 14:44:11][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 14:44:11][0m  [36;1m[0.32ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 14:44:11][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 14:44:11][0m  [36;1m[0.34ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 14:44:25][0m  [36;1m[0.56ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 14:44:25][0m  [36;1m[0.69ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 14:44:25][0m  [36;1m[0.18ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 14:44:25][0m  [36;1m[0.32ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 14:44:25][0m  [36;1m[0.30ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 14:44:25][0m  [36;1m[0.33ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 14:44:33][0m  [36;1m[0.51ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 14:44:33][0m  [36;1m[0.77ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 14:44:33][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 14:44:33][0m  [36;1m[0.35ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 14:44:33][0m  [36;1m[0.32ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 14:44:33][0m  [36;1m[0.37ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 14:44:36][0m  [36;1m[0.51ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 14:44:36][0m  [36;1m[0.70ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 14:44:36][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 14:44:36][0m  [36;1m[0.28ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 14:44:36][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 14:44:36][0m  [36;1m[0.31ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-21 14:44:45][0m  [36;1m[0.38ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 4)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-21 14:44:45][0m  [36;1m[0.44ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=4  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-21 14:44:45][0m  [36;1m[0.45ms][0m  UPDATE `blogs` SET `title` = '本博客开源公告', `content` = '今天本博客评论功能发布
# 自今天起，本博客基本功能已经完成
## 发布V1.0版本并开源
## 博客语言说明
#### 本博客后端是用golang 的gin框架+gorm编写
前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的
#### 博客效果参考本站
#一、博客简介
## 1.博客目录

    blog
    ├────controller
	├────└───admin
	|	|	├──adminblog.go
	|	|	├───adminController.go
	|	|	├──adminTag.go
	|	|	├──adminType.go
	|	|	└──adminUser.go
	|	└──page
	|		├──404.go
	|		├───about.go
	|		├──archives.go
	|		├──blog.go
	|		├──comment.go
	|		├──pagesController.go
	|		├──researchController.go
	|		└──tagsController.go
    ├── dao
	│	├──blogs.go
	│	├──comment.go
	│	├──sql.go
	│	├──tags.go
	│	├──types.go
	│	└──user.go
    ├── logic
    │   └── user.go
    ├── middlerware
	│	├──function.go
	│	├──getImg.go
	│	├──getTime.go
	│	├──markdown.go
	│	├──select.go
	│	└──session.go
    ├── model
	│	├──blog.go
	│	├──commnent.go
	│	├──tag.go
	│	├──type.go
	│	└──user/go
    ├── static
	│	└──静态文件（头像、图片、logo、css、js等）
    ├── templates
	│	└──html模板文件
    ├── go.mod（依赖）
    └── main.go
    

## 2.相关功能实现简介
### 1、评论及回复功能
comment的结构体属性如下
```go
package model

type Comment struct {
	Id     int //评论id
	BlogId int //博文id
	ReCommentId    int    //父评论id
	CommentName string //评论人姓名
	ReCommentName  string //父评论人姓名
	CommentEmail   string
	Img            string
	CommentContent string `gorm:"type:text" form:"CommentContent" json:"CommentContent"` //评论内容
	CommentTime    string ` json:"comment_time,omitempty"`
	Parent         *Comment
	Comments       []Comment
}
```
#### 实现方法
##### 1先通过查找父评论为-1的顶级评论
父评论Id为-1说明他不是任何评论的子评论
##### 2在html上遍历所有的顶级评论
在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论
###### （1）递归存储每个顶级评论的子评论
这里我用一个切片来储存一个顶级评论的所有子评论
```go
var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
	var comments []model.Comment
	DB.Debug().Where("re_comment_id = -1 AND blog_id = ?", id).Find(&comments)
	return &comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
	if count != 0 {
		fmt.Println("if判断1")
		var comments []model.Comment
		DB.Debug().Where("re_comment_id = ?", id).Find(&comments)
		count = len(comments)
		if count != 0 {
			fmt.Println("if判断2")
			for _, comment := range comments {
				fmt.Println("for判断1")
				Comments = append(Comments, comment)
				SelectCommentByComment(comment.Id, count)
			}
		}
	}
	fmt.Println(Comments)
	return &Comments

}
```
ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来
###### （2）出现问题的原因
因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量
###### （3）解决问题
```go
func ClearComments() bool {
	var comments []model.Comment
	Comments = comments
	return true
}

```
这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现
#### 这里我还加了一个小小的随机头像功能
```go
if  CommentName == user.Name && CommentEmail == user.UserEmail {
		fmt.Println("进入了1")
		comment.Img =user.UserImg
		//找相同评论人
	}else if CommentName == one.CommentName && CommentEmail == one.CommentEmail {
		fmt.Println("进入了2")
		comment.Img =one.Img
		//随机选头像
	}else{
		fmt.Println("进入了3")
		comment.Img =middleware.GetImg()
	}
```
##### 123分别代表三种不同的用户群体
1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
![](/static/images/%e5%a4%b4%e5%83%8f1.png)![](/static/images/%e5%a4%b4%e5%83%8f2.png)![](/static/images/%e5%a4%b4%e5%83%8f3.png)![](/static/images/%e5%a4%b4%e5%83%8f4.png)![](/static/images/%e5%a4%b4%e5%83%8f5.png)![](/static/images/%e5%a4%b4%e5%83%8f6.png)
### 2、归档功能
#### blog的结构体属性如下
```go
package model

type Blog struct {
	Id           int
	Title        string    `form:"title" json:"title"`                          //标题
	Content      string    `gorm:"type:longtext" form:"content" json:"content"` //内容
	Image        string    `gorm:"type:text" form:"image" json:"image"`         //首图
	Numb         int       `form:"numb" json:"numb"`                            //次数
	Flag         string    `form:"flag" json:"flag"`                            //原创或者转载
	Appreciation string    `form:"appreciation" json:"appreciation"`            //打赏开关
	ShareInfo    string    `form:"shareInfo" json:"shareInfo"`                  //版权开关
	Comment      string    `form:"comment" json:"comment"`                      //评论开关
	Recommend    string    `form:"recommend" json:"recommend"`                  //推荐开关
	Description  string    `gorm:"type:text" form:"description" json:"description"`
	CreatTime    string    `form:"creatTime"  json:"creat_time,omitempty"`   //创建时间
	UpdateTime   string    `form:"updateTime"  json:"update_time,omitempty"` //更新时间
	Comments     []Comment `form:"comments" json:"comments"`
	TypeId       int       `form:"typeId" json:"typeId"`
	Type         Type      `form:"type" gorm:"ForeignKey:TypeId"`
	Year         int       `form:"year" json:"year"`
	Month        int       `form:"month" json:"month"`
	Day          int       `form:"day" json:"day"`
}

```
#### 实现方法
我的思路是创建三个时间节点
year month day 
利用sql分组查询
##### Group By分组查询步骤
###### （1）先按照年份查询
###### （2）再按照年份遍历每个月份
并将所有保存在一个切片中
###### （3）按照月份遍历每个月的所有文章
保存在一个Map中，key是对应的月份，value是每个月份的所有文章
#### 自此归档功能实现


## 3.已知BUG
### 后台退出功能
后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧

开源地址
[github](https://github.com/likewl/blog "github")
[gitee](https://gitee.com/nculike/blog "gitee")', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1535821573,4166447487&fm=26&gp=0.jpg', `numb` = 37, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '本博客后端是用golang 的gin框架+gorm编写', `creat_time` = '2020-07-20 15:24:23', `update_time` = '2020-07-20 15:24:23', `type_id` = 4, `year` = 2020, `month` = 7, `day` = 20  WHERE `blogs`.`id` = 4  
[36;31m[1 rows affected or returned ][0m 
<p>今天本博客评论功能发布</p>

<h1>自今天起，本博客基本功能已经完成</h1>

<h2>发布V1.0版本并开源</h2>

<h2>博客语言说明</h2>

<h4>本博客后端是用golang 的gin框架+gorm编写</h4>

<p>前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的</p>

<h4>博客效果参考本站</h4>

<p>#一、博客简介</p>

<h2>1.博客目录</h2>

<pre><code>blog
├────controller
├────└───admin
|   |   ├──adminblog.go
|   |   ├───adminController.go
|   |   ├──adminTag.go
|   |   ├──adminType.go
|   |   └──adminUser.go
|   └──page
|       ├──404.go
|       ├───about.go
|       ├──archives.go
|       ├──blog.go
|       ├──comment.go
|       ├──pagesController.go
|       ├──researchController.go
|       └──tagsController.go
├── dao
│   ├──blogs.go
│   ├──comment.go
│   ├──sql.go
│   ├──tags.go
│   ├──types.go
│   └──user.go
├── logic
│   └── user.go
├── middlerware
│   ├──function.go
│   ├──getImg.go
│   ├──getTime.go
│   ├──markdown.go
│   ├──select.go
│   └──session.go
├── model
│   ├──blog.go
│   ├──commnent.go
│   ├──tag.go
│   ├──type.go
│   └──user/go
├── static
│   └──静态文件（头像、图片、logo、css、js等）
├── templates
│   └──html模板文件
├── go.mod（依赖）
└── main.go
</code></pre>

<h2>2.相关功能实现简介</h2>

<h3>1、评论及回复功能</h3>

<p>comment的结构体属性如下</p>

<pre><code class="language-go">package model

type Comment struct {
    Id     int //评论id
    BlogId int //博文id
    ReCommentId    int    //父评论id
    CommentName string //评论人姓名
    ReCommentName  string //父评论人姓名
    CommentEmail   string
    Img            string
    CommentContent string `gorm:&#34;type:text&#34; form:&#34;CommentContent&#34; json:&#34;CommentContent&#34;` //评论内容
    CommentTime    string ` json:&#34;comment_time,omitempty&#34;`
    Parent         *Comment
    Comments       []Comment
}
</code></pre>

<h4>实现方法</h4>

<h5>1先通过查找父评论为-1的顶级评论</h5>

<p>父评论Id为-1说明他不是任何评论的子评论</p>

<h5>2在html上遍历所有的顶级评论</h5>

<p>在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论</p>

<h6>（1）递归存储每个顶级评论的子评论</h6>

<p>这里我用一个切片来储存一个顶级评论的所有子评论</p>

<pre><code class="language-go">var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
    var comments []model.Comment
    DB.Debug().Where(&#34;re_comment_id = -1 AND blog_id = ?&#34;, id).Find(&amp;comments)
    return &amp;comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
    if count != 0 {
        fmt.Println(&#34;if判断1&#34;)
        var comments []model.Comment
        DB.Debug().Where(&#34;re_comment_id = ?&#34;, id).Find(&amp;comments)
        count = len(comments)
        if count != 0 {
            fmt.Println(&#34;if判断2&#34;)
            for _, comment := range comments {
                fmt.Println(&#34;for判断1&#34;)
                Comments = append(Comments, comment)
                SelectCommentByComment(comment.Id, count)
            }
        }
    }
    fmt.Println(Comments)
    return &amp;Comments

}
</code></pre>

<p>ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来</p>

<h6>（2）出现问题的原因</h6>

<p>因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量</p>

<h6>（3）解决问题</h6>

<pre><code class="language-go">func ClearComments() bool {
    var comments []model.Comment
    Comments = comments
    return true
}

</code></pre>

<p>这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现</p>

<h4>这里我还加了一个小小的随机头像功能</h4>

<pre><code class="language-go">if  CommentName == user.Name &amp;&amp; CommentEmail == user.UserEmail {
        fmt.Println(&#34;进入了1&#34;)
        comment.Img =user.UserImg
        //找相同评论人
    }else if CommentName == one.CommentName &amp;&amp; CommentEmail == one.CommentEmail {
        fmt.Println(&#34;进入了2&#34;)
        comment.Img =one.Img
        //随机选头像
    }else{
        fmt.Println(&#34;进入了3&#34;)
        comment.Img =middleware.GetImg()
    }
</code></pre>

<h5>123分别代表三种不同的用户群体</h5>

<p>1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
<img src="/static/images/%e5%a4%b4%e5%83%8f1.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f2.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f3.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f4.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f5.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f6.png" alt=""/></p>

<h3>2、归档功能</h3>

<h4>blog的结构体属性如下</h4>

<pre><code class="language-go">package model

type Blog struct {
    Id           int
    Title        string    `form:&#34;title&#34; json:&#34;title&#34;`                          //标题
    Content      string    `gorm:&#34;type:longtext&#34; form:&#34;content&#34; json:&#34;content&#34;` //内容
    Image        string    `gorm:&#34;type:text&#34; form:&#34;image&#34; json:&#34;image&#34;`         //首图
    Numb         int       `form:&#34;numb&#34; json:&#34;numb&#34;`                            //次数
    Flag         string    `form:&#34;flag&#34; json:&#34;flag&#34;`                            //原创或者转载
    Appreciation string    `form:&#34;appreciation&#34; json:&#34;appreciation&#34;`            //打赏开关
    ShareInfo    string    `form:&#34;shareInfo&#34; json:&#34;shareInfo&#34;`                  //版权开关
    Comment      string    `form:&#34;comment&#34; json:&#34;comment&#34;`                      //评论开关
    Recommend    string    `form:&#34;recommend&#34; json:&#34;recommend&#34;`                  //推荐开关
    Description  string    `gorm:&#34;type:text&#34; form:&#34;description&#34; json:&#34;description&#34;`
    CreatTime    string    `form:&#34;creatTime&#34;  json:&#34;creat_time,omitempty&#34;`   //创建时间
    UpdateTime   string    `form:&#34;updateTime&#34;  json:&#34;update_time,omitempty&#34;` //更新时间
    Comments     []Comment `form:&#34;comments&#34; json:&#34;comments&#34;`
    TypeId       int       `form:&#34;typeId&#34; json:&#34;typeId&#34;`
    Type         Type      `form:&#34;type&#34; gorm:&#34;ForeignKey:TypeId&#34;`
    Year         int       `form:&#34;year&#34; json:&#34;year&#34;`
    Month        int       `form:&#34;month&#34; json:&#34;month&#34;`
    Day          int       `form:&#34;day&#34; json:&#34;day&#34;`
}

</code></pre>

<h4>实现方法</h4>

<p>我的思路是创建三个时间节点
year month day
利用sql分组查询</p>

<h5>Group By分组查询步骤</h5>

<h6>（1）先按照年份查询</h6>

<h6>（2）再按照年份遍历每个月份</h6>

<p>并将所有保存在一个切片中</p>

<h6>（3）按照月份遍历每个月的所有文章</h6>

<p>保存在一个Map中，key是对应的月份，value是每个月份的所有文章</p>

<h4>自此归档功能实现</h4>

<h2>3.已知BUG</h2>

<h3>后台退出功能</h3>

<p>后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧</p>

<p>开源地址
<a href="https://github.com/likewl/blog" title="github" rel="nofollow">github</a>
<a href="https://gitee.com/nculike/blog" title="gitee" rel="nofollow">gitee</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 14:44:45][0m  [36;1m[1.59ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-21 14:44:58][0m  [36;1m[0.38ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 4)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-21 14:44:58][0m  [36;1m[0.45ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=4  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-21 14:44:58][0m  [36;1m[0.45ms][0m  UPDATE `blogs` SET `title` = '本博客开源公告', `content` = '今天本博客评论功能发布
# 自今天起，本博客基本功能已经完成
## 发布V1.0版本并开源
## 博客语言说明
#### 本博客后端是用golang 的gin框架+gorm编写
前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的
#### 博客效果参考本站
#一、博客简介
## 1.博客目录

    blog
    ├────controller
	├────└───admin
	|	|	├──adminblog.go
	|	|	├───adminController.go
	|	|	├──adminTag.go
	|	|	├──adminType.go
	|	|	└──adminUser.go
	|	└──page
	|		├──404.go
	|		├───about.go
	|		├──archives.go
	|		├──blog.go
	|		├──comment.go
	|		├──pagesController.go
	|		├──researchController.go
	|		└──tagsController.go
    ├── dao
	│	├──blogs.go
	│	├──comment.go
	│	├──sql.go
	│	├──tags.go
	│	├──types.go
	│	└──user.go
    ├── logic
    │   └── user.go
    ├── middlerware
	│	├──function.go
	│	├──getImg.go
	│	├──getTime.go
	│	├──markdown.go
	│	├──select.go
	│	└──session.go
    ├── model
	│	├──blog.go
	│	├──commnent.go
	│	├──tag.go
	│	├──type.go
	│	└──user/go
    ├── static
	│	└──静态文件（头像、图片、logo、css、js等）
    ├── templates
	│	└──html模板文件
    ├── go.mod（依赖）
    └── main.go
    

## 2.相关功能实现简介
### 1、评论及回复功能
comment的结构体属性如下
```go
package model

type Comment struct {
	Id     int //评论id
	BlogId int //博文id
	ReCommentId    int    //父评论id
	CommentName string //评论人姓名
	ReCommentName  string //父评论人姓名
	CommentEmail   string
	Img            string
	CommentContent string `gorm:"type:text" form:"CommentContent" json:"CommentContent"` //评论内容
	CommentTime    string ` json:"comment_time,omitempty"`
	Parent         *Comment
	Comments       []Comment
}
```
#### 实现方法
##### 1先通过查找父评论为-1的顶级评论
父评论Id为-1说明他不是任何评论的子评论
##### 2在html上遍历所有的顶级评论
在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论
###### （1）递归存储每个顶级评论的子评论
这里我用一个切片来储存一个顶级评论的所有子评论
```go
var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
	var comments []model.Comment
	DB.Debug().Where("re_comment_id = -1 AND blog_id = ?", id).Find(&comments)
	return &comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
	if count != 0 {
		fmt.Println("if判断1")
		var comments []model.Comment
		DB.Debug().Where("re_comment_id = ?", id).Find(&comments)
		count = len(comments)
		if count != 0 {
			fmt.Println("if判断2")
			for _, comment := range comments {
				fmt.Println("for判断1")
				Comments = append(Comments, comment)
				SelectCommentByComment(comment.Id, count)
			}
		}
	}
	fmt.Println(Comments)
	return &Comments

}
```
ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来
###### （2）出现问题的原因
因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量
###### （3）解决问题
```go
func ClearComments() bool {
	var comments []model.Comment
	Comments = comments
	return true
}

```
这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现
#### 这里我还加了一个小小的随机头像功能
```go
if  CommentName == user.Name && CommentEmail == user.UserEmail {
		fmt.Println("进入了1")
		comment.Img =user.UserImg
		//找相同评论人
	}else if CommentName == one.CommentName && CommentEmail == one.CommentEmail {
		fmt.Println("进入了2")
		comment.Img =one.Img
		//随机选头像
	}else{
		fmt.Println("进入了3")
		comment.Img =middleware.GetImg()
	}
```
##### 123分别代表三种不同的用户群体
1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
![](/static/images/%e5%a4%b4%e5%83%8f1.png)![](/static/images/%e5%a4%b4%e5%83%8f2.png)![](/static/images/%e5%a4%b4%e5%83%8f3.png)![](/static/images/%e5%a4%b4%e5%83%8f4.png)![](/static/images/%e5%a4%b4%e5%83%8f5.png)![](/static/images/%e5%a4%b4%e5%83%8f6.png)
### 2、归档功能
#### blog的结构体属性如下
```go
package model

type Blog struct {
	Id           int
	Title        string    `form:"title" json:"title"`                          //标题
	Content      string    `gorm:"type:longtext" form:"content" json:"content"` //内容
	Image        string    `gorm:"type:text" form:"image" json:"image"`         //首图
	Numb         int       `form:"numb" json:"numb"`                            //次数
	Flag         string    `form:"flag" json:"flag"`                            //原创或者转载
	Appreciation string    `form:"appreciation" json:"appreciation"`            //打赏开关
	ShareInfo    string    `form:"shareInfo" json:"shareInfo"`                  //版权开关
	Comment      string    `form:"comment" json:"comment"`                      //评论开关
	Recommend    string    `form:"recommend" json:"recommend"`                  //推荐开关
	Description  string    `gorm:"type:text" form:"description" json:"description"`
	CreatTime    string    `form:"creatTime"  json:"creat_time,omitempty"`   //创建时间
	UpdateTime   string    `form:"updateTime"  json:"update_time,omitempty"` //更新时间
	Comments     []Comment `form:"comments" json:"comments"`
	TypeId       int       `form:"typeId" json:"typeId"`
	Type         Type      `form:"type" gorm:"ForeignKey:TypeId"`
	Year         int       `form:"year" json:"year"`
	Month        int       `form:"month" json:"month"`
	Day          int       `form:"day" json:"day"`
}

```
#### 实现方法
我的思路是创建三个时间节点
year month day 
利用sql分组查询
##### Group By分组查询步骤
###### （1）先按照年份查询
###### （2）再按照年份遍历每个月份
并将所有保存在一个切片中
###### （3）按照月份遍历每个月的所有文章
保存在一个Map中，key是对应的月份，value是每个月份的所有文章
#### 自此归档功能实现


## 3.已知BUG
### 后台退出功能
后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧

开源地址
[github](https://github.com/likewl/blog "github")
[gitee](https://gitee.com/nculike/blog "gitee")', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1535821573,4166447487&fm=26&gp=0.jpg', `numb` = 38, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '本博客后端是用golang 的gin框架+gorm编写', `creat_time` = '2020-07-20 15:24:23', `update_time` = '2020-07-20 15:24:23', `type_id` = 4, `year` = 2020, `month` = 7, `day` = 20  WHERE `blogs`.`id` = 4  
[36;31m[1 rows affected or returned ][0m 
<p>今天本博客评论功能发布</p>

<h1>自今天起，本博客基本功能已经完成</h1>

<h2>发布V1.0版本并开源</h2>

<h2>博客语言说明</h2>

<h4>本博客后端是用golang 的gin框架+gorm编写</h4>

<p>前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的</p>

<h4>博客效果参考本站</h4>

<p>#一、博客简介</p>

<h2>1.博客目录</h2>

<pre><code>blog
├────controller
├────└───admin
|   |   ├──adminblog.go
|   |   ├───adminController.go
|   |   ├──adminTag.go
|   |   ├──adminType.go
|   |   └──adminUser.go
|   └──page
|       ├──404.go
|       ├───about.go
|       ├──archives.go
|       ├──blog.go
|       ├──comment.go
|       ├──pagesController.go
|       ├──researchController.go
|       └──tagsController.go
├── dao
│   ├──blogs.go
│   ├──comment.go
│   ├──sql.go
│   ├──tags.go
│   ├──types.go
│   └──user.go
├── logic
│   └── user.go
├── middlerware
│   ├──function.go
│   ├──getImg.go
│   ├──getTime.go
│   ├──markdown.go
│   ├──select.go
│   └──session.go
├── model
│   ├──blog.go
│   ├──commnent.go
│   ├──tag.go
│   ├──type.go
│   └──user/go
├── static
│   └──静态文件（头像、图片、logo、css、js等）
├── templates
│   └──html模板文件
├── go.mod（依赖）
└── main.go
</code></pre>

<h2>2.相关功能实现简介</h2>

<h3>1、评论及回复功能</h3>

<p>comment的结构体属性如下</p>

<pre><code class="language-go">package model

type Comment struct {
    Id     int //评论id
    BlogId int //博文id
    ReCommentId    int    //父评论id
    CommentName string //评论人姓名
    ReCommentName  string //父评论人姓名
    CommentEmail   string
    Img            string
    CommentContent string `gorm:&#34;type:text&#34; form:&#34;CommentContent&#34; json:&#34;CommentContent&#34;` //评论内容
    CommentTime    string ` json:&#34;comment_time,omitempty&#34;`
    Parent         *Comment
    Comments       []Comment
}
</code></pre>

<h4>实现方法</h4>

<h5>1先通过查找父评论为-1的顶级评论</h5>

<p>父评论Id为-1说明他不是任何评论的子评论</p>

<h5>2在html上遍历所有的顶级评论</h5>

<p>在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论</p>

<h6>（1）递归存储每个顶级评论的子评论</h6>

<p>这里我用一个切片来储存一个顶级评论的所有子评论</p>

<pre><code class="language-go">var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
    var comments []model.Comment
    DB.Debug().Where(&#34;re_comment_id = -1 AND blog_id = ?&#34;, id).Find(&amp;comments)
    return &amp;comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
    if count != 0 {
        fmt.Println(&#34;if判断1&#34;)
        var comments []model.Comment
        DB.Debug().Where(&#34;re_comment_id = ?&#34;, id).Find(&amp;comments)
        count = len(comments)
        if count != 0 {
            fmt.Println(&#34;if判断2&#34;)
            for _, comment := range comments {
                fmt.Println(&#34;for判断1&#34;)
                Comments = append(Comments, comment)
                SelectCommentByComment(comment.Id, count)
            }
        }
    }
    fmt.Println(Comments)
    return &amp;Comments

}
</code></pre>

<p>ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来</p>

<h6>（2）出现问题的原因</h6>

<p>因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量</p>

<h6>（3）解决问题</h6>

<pre><code class="language-go">func ClearComments() bool {
    var comments []model.Comment
    Comments = comments
    return true
}

</code></pre>

<p>这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现</p>

<h4>这里我还加了一个小小的随机头像功能</h4>

<pre><code class="language-go">if  CommentName == user.Name &amp;&amp; CommentEmail == user.UserEmail {
        fmt.Println(&#34;进入了1&#34;)
        comment.Img =user.UserImg
        //找相同评论人
    }else if CommentName == one.CommentName &amp;&amp; CommentEmail == one.CommentEmail {
        fmt.Println(&#34;进入了2&#34;)
        comment.Img =one.Img
        //随机选头像
    }else{
        fmt.Println(&#34;进入了3&#34;)
        comment.Img =middleware.GetImg()
    }
</code></pre>

<h5>123分别代表三种不同的用户群体</h5>

<p>1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
<img src="/static/images/%e5%a4%b4%e5%83%8f1.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f2.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f3.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f4.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f5.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f6.png" alt=""/></p>

<h3>2、归档功能</h3>

<h4>blog的结构体属性如下</h4>

<pre><code class="language-go">package model

type Blog struct {
    Id           int
    Title        string    `form:&#34;title&#34; json:&#34;title&#34;`                          //标题
    Content      string    `gorm:&#34;type:longtext&#34; form:&#34;content&#34; json:&#34;content&#34;` //内容
    Image        string    `gorm:&#34;type:text&#34; form:&#34;image&#34; json:&#34;image&#34;`         //首图
    Numb         int       `form:&#34;numb&#34; json:&#34;numb&#34;`                            //次数
    Flag         string    `form:&#34;flag&#34; json:&#34;flag&#34;`                            //原创或者转载
    Appreciation string    `form:&#34;appreciation&#34; json:&#34;appreciation&#34;`            //打赏开关
    ShareInfo    string    `form:&#34;shareInfo&#34; json:&#34;shareInfo&#34;`                  //版权开关
    Comment      string    `form:&#34;comment&#34; json:&#34;comment&#34;`                      //评论开关
    Recommend    string    `form:&#34;recommend&#34; json:&#34;recommend&#34;`                  //推荐开关
    Description  string    `gorm:&#34;type:text&#34; form:&#34;description&#34; json:&#34;description&#34;`
    CreatTime    string    `form:&#34;creatTime&#34;  json:&#34;creat_time,omitempty&#34;`   //创建时间
    UpdateTime   string    `form:&#34;updateTime&#34;  json:&#34;update_time,omitempty&#34;` //更新时间
    Comments     []Comment `form:&#34;comments&#34; json:&#34;comments&#34;`
    TypeId       int       `form:&#34;typeId&#34; json:&#34;typeId&#34;`
    Type         Type      `form:&#34;type&#34; gorm:&#34;ForeignKey:TypeId&#34;`
    Year         int       `form:&#34;year&#34; json:&#34;year&#34;`
    Month        int       `form:&#34;month&#34; json:&#34;month&#34;`
    Day          int       `form:&#34;day&#34; json:&#34;day&#34;`
}

</code></pre>

<h4>实现方法</h4>

<p>我的思路是创建三个时间节点
year month day
利用sql分组查询</p>

<h5>Group By分组查询步骤</h5>

<h6>（1）先按照年份查询</h6>

<h6>（2）再按照年份遍历每个月份</h6>

<p>并将所有保存在一个切片中</p>

<h6>（3）按照月份遍历每个月的所有文章</h6>

<p>保存在一个Map中，key是对应的月份，value是每个月份的所有文章</p>

<h4>自此归档功能实现</h4>

<h2>3.已知BUG</h2>

<h3>后台退出功能</h3>

<p>后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧</p>

<p>开源地址
<a href="https://github.com/likewl/blog" title="github" rel="nofollow">github</a>
<a href="https://gitee.com/nculike/blog" title="gitee" rel="nofollow">gitee</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 14:44:58][0m  [36;1m[0.28ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 14:45:01][0m  [36;1m[0.51ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 14:45:01][0m  [36;1m[0.69ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 14:45:01][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 14:45:01][0m  [36;1m[0.34ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 14:45:01][0m  [36;1m[0.28ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 14:45:01][0m  [36;1m[0.32ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-21 14:45:02][0m  [36;1m[0.36ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 4)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-21 14:45:02][0m  [36;1m[0.43ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=4  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-21 14:45:02][0m  [36;1m[0.47ms][0m  UPDATE `blogs` SET `title` = '本博客开源公告', `content` = '今天本博客评论功能发布
# 自今天起，本博客基本功能已经完成
## 发布V1.0版本并开源
## 博客语言说明
#### 本博客后端是用golang 的gin框架+gorm编写
前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的
#### 博客效果参考本站
#一、博客简介
## 1.博客目录

    blog
    ├────controller
	├────└───admin
	|	|	├──adminblog.go
	|	|	├───adminController.go
	|	|	├──adminTag.go
	|	|	├──adminType.go
	|	|	└──adminUser.go
	|	└──page
	|		├──404.go
	|		├───about.go
	|		├──archives.go
	|		├──blog.go
	|		├──comment.go
	|		├──pagesController.go
	|		├──researchController.go
	|		└──tagsController.go
    ├── dao
	│	├──blogs.go
	│	├──comment.go
	│	├──sql.go
	│	├──tags.go
	│	├──types.go
	│	└──user.go
    ├── logic
    │   └── user.go
    ├── middlerware
	│	├──function.go
	│	├──getImg.go
	│	├──getTime.go
	│	├──markdown.go
	│	├──select.go
	│	└──session.go
    ├── model
	│	├──blog.go
	│	├──commnent.go
	│	├──tag.go
	│	├──type.go
	│	└──user/go
    ├── static
	│	└──静态文件（头像、图片、logo、css、js等）
    ├── templates
	│	└──html模板文件
    ├── go.mod（依赖）
    └── main.go
    

## 2.相关功能实现简介
### 1、评论及回复功能
comment的结构体属性如下
```go
package model

type Comment struct {
	Id     int //评论id
	BlogId int //博文id
	ReCommentId    int    //父评论id
	CommentName string //评论人姓名
	ReCommentName  string //父评论人姓名
	CommentEmail   string
	Img            string
	CommentContent string `gorm:"type:text" form:"CommentContent" json:"CommentContent"` //评论内容
	CommentTime    string ` json:"comment_time,omitempty"`
	Parent         *Comment
	Comments       []Comment
}
```
#### 实现方法
##### 1先通过查找父评论为-1的顶级评论
父评论Id为-1说明他不是任何评论的子评论
##### 2在html上遍历所有的顶级评论
在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论
###### （1）递归存储每个顶级评论的子评论
这里我用一个切片来储存一个顶级评论的所有子评论
```go
var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
	var comments []model.Comment
	DB.Debug().Where("re_comment_id = -1 AND blog_id = ?", id).Find(&comments)
	return &comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
	if count != 0 {
		fmt.Println("if判断1")
		var comments []model.Comment
		DB.Debug().Where("re_comment_id = ?", id).Find(&comments)
		count = len(comments)
		if count != 0 {
			fmt.Println("if判断2")
			for _, comment := range comments {
				fmt.Println("for判断1")
				Comments = append(Comments, comment)
				SelectCommentByComment(comment.Id, count)
			}
		}
	}
	fmt.Println(Comments)
	return &Comments

}
```
ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来
###### （2）出现问题的原因
因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量
###### （3）解决问题
```go
func ClearComments() bool {
	var comments []model.Comment
	Comments = comments
	return true
}

```
这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现
#### 这里我还加了一个小小的随机头像功能
```go
if  CommentName == user.Name && CommentEmail == user.UserEmail {
		fmt.Println("进入了1")
		comment.Img =user.UserImg
		//找相同评论人
	}else if CommentName == one.CommentName && CommentEmail == one.CommentEmail {
		fmt.Println("进入了2")
		comment.Img =one.Img
		//随机选头像
	}else{
		fmt.Println("进入了3")
		comment.Img =middleware.GetImg()
	}
```
##### 123分别代表三种不同的用户群体
1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
![](/static/images/%e5%a4%b4%e5%83%8f1.png)![](/static/images/%e5%a4%b4%e5%83%8f2.png)![](/static/images/%e5%a4%b4%e5%83%8f3.png)![](/static/images/%e5%a4%b4%e5%83%8f4.png)![](/static/images/%e5%a4%b4%e5%83%8f5.png)![](/static/images/%e5%a4%b4%e5%83%8f6.png)
### 2、归档功能
#### blog的结构体属性如下
```go
package model

type Blog struct {
	Id           int
	Title        string    `form:"title" json:"title"`                          //标题
	Content      string    `gorm:"type:longtext" form:"content" json:"content"` //内容
	Image        string    `gorm:"type:text" form:"image" json:"image"`         //首图
	Numb         int       `form:"numb" json:"numb"`                            //次数
	Flag         string    `form:"flag" json:"flag"`                            //原创或者转载
	Appreciation string    `form:"appreciation" json:"appreciation"`            //打赏开关
	ShareInfo    string    `form:"shareInfo" json:"shareInfo"`                  //版权开关
	Comment      string    `form:"comment" json:"comment"`                      //评论开关
	Recommend    string    `form:"recommend" json:"recommend"`                  //推荐开关
	Description  string    `gorm:"type:text" form:"description" json:"description"`
	CreatTime    string    `form:"creatTime"  json:"creat_time,omitempty"`   //创建时间
	UpdateTime   string    `form:"updateTime"  json:"update_time,omitempty"` //更新时间
	Comments     []Comment `form:"comments" json:"comments"`
	TypeId       int       `form:"typeId" json:"typeId"`
	Type         Type      `form:"type" gorm:"ForeignKey:TypeId"`
	Year         int       `form:"year" json:"year"`
	Month        int       `form:"month" json:"month"`
	Day          int       `form:"day" json:"day"`
}

```
#### 实现方法
我的思路是创建三个时间节点
year month day 
利用sql分组查询
##### Group By分组查询步骤
###### （1）先按照年份查询
###### （2）再按照年份遍历每个月份
并将所有保存在一个切片中
###### （3）按照月份遍历每个月的所有文章
保存在一个Map中，key是对应的月份，value是每个月份的所有文章
#### 自此归档功能实现


## 3.已知BUG
### 后台退出功能
后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧

开源地址
[github](https://github.com/likewl/blog "github")
[gitee](https://gitee.com/nculike/blog "gitee")', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1535821573,4166447487&fm=26&gp=0.jpg', `numb` = 39, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '本博客后端是用golang 的gin框架+gorm编写', `creat_time` = '2020-07-20 15:24:23', `update_time` = '2020-07-20 15:24:23', `type_id` = 4, `year` = 2020, `month` = 7, `day` = 20  WHERE `blogs`.`id` = 4  
[36;31m[1 rows affected or returned ][0m 
<p>今天本博客评论功能发布</p>

<h1>自今天起，本博客基本功能已经完成</h1>

<h2>发布V1.0版本并开源</h2>

<h2>博客语言说明</h2>

<h4>本博客后端是用golang 的gin框架+gorm编写</h4>

<p>前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的</p>

<h4>博客效果参考本站</h4>

<p>#一、博客简介</p>

<h2>1.博客目录</h2>

<pre><code>blog
├────controller
├────└───admin
|   |   ├──adminblog.go
|   |   ├───adminController.go
|   |   ├──adminTag.go
|   |   ├──adminType.go
|   |   └──adminUser.go
|   └──page
|       ├──404.go
|       ├───about.go
|       ├──archives.go
|       ├──blog.go
|       ├──comment.go
|       ├──pagesController.go
|       ├──researchController.go
|       └──tagsController.go
├── dao
│   ├──blogs.go
│   ├──comment.go
│   ├──sql.go
│   ├──tags.go
│   ├──types.go
│   └──user.go
├── logic
│   └── user.go
├── middlerware
│   ├──function.go
│   ├──getImg.go
│   ├──getTime.go
│   ├──markdown.go
│   ├──select.go
│   └──session.go
├── model
│   ├──blog.go
│   ├──commnent.go
│   ├──tag.go
│   ├──type.go
│   └──user/go
├── static
│   └──静态文件（头像、图片、logo、css、js等）
├── templates
│   └──html模板文件
├── go.mod（依赖）
└── main.go
</code></pre>

<h2>2.相关功能实现简介</h2>

<h3>1、评论及回复功能</h3>

<p>comment的结构体属性如下</p>

<pre><code class="language-go">package model

type Comment struct {
    Id     int //评论id
    BlogId int //博文id
    ReCommentId    int    //父评论id
    CommentName string //评论人姓名
    ReCommentName  string //父评论人姓名
    CommentEmail   string
    Img            string
    CommentContent string `gorm:&#34;type:text&#34; form:&#34;CommentContent&#34; json:&#34;CommentContent&#34;` //评论内容
    CommentTime    string ` json:&#34;comment_time,omitempty&#34;`
    Parent         *Comment
    Comments       []Comment
}
</code></pre>

<h4>实现方法</h4>

<h5>1先通过查找父评论为-1的顶级评论</h5>

<p>父评论Id为-1说明他不是任何评论的子评论</p>

<h5>2在html上遍历所有的顶级评论</h5>

<p>在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论</p>

<h6>（1）递归存储每个顶级评论的子评论</h6>

<p>这里我用一个切片来储存一个顶级评论的所有子评论</p>

<pre><code class="language-go">var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
    var comments []model.Comment
    DB.Debug().Where(&#34;re_comment_id = -1 AND blog_id = ?&#34;, id).Find(&amp;comments)
    return &amp;comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
    if count != 0 {
        fmt.Println(&#34;if判断1&#34;)
        var comments []model.Comment
        DB.Debug().Where(&#34;re_comment_id = ?&#34;, id).Find(&amp;comments)
        count = len(comments)
        if count != 0 {
            fmt.Println(&#34;if判断2&#34;)
            for _, comment := range comments {
                fmt.Println(&#34;for判断1&#34;)
                Comments = append(Comments, comment)
                SelectCommentByComment(comment.Id, count)
            }
        }
    }
    fmt.Println(Comments)
    return &amp;Comments

}
</code></pre>

<p>ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来</p>

<h6>（2）出现问题的原因</h6>

<p>因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量</p>

<h6>（3）解决问题</h6>

<pre><code class="language-go">func ClearComments() bool {
    var comments []model.Comment
    Comments = comments
    return true
}

</code></pre>

<p>这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现</p>

<h4>这里我还加了一个小小的随机头像功能</h4>

<pre><code class="language-go">if  CommentName == user.Name &amp;&amp; CommentEmail == user.UserEmail {
        fmt.Println(&#34;进入了1&#34;)
        comment.Img =user.UserImg
        //找相同评论人
    }else if CommentName == one.CommentName &amp;&amp; CommentEmail == one.CommentEmail {
        fmt.Println(&#34;进入了2&#34;)
        comment.Img =one.Img
        //随机选头像
    }else{
        fmt.Println(&#34;进入了3&#34;)
        comment.Img =middleware.GetImg()
    }
</code></pre>

<h5>123分别代表三种不同的用户群体</h5>

<p>1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
<img src="/static/images/%e5%a4%b4%e5%83%8f1.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f2.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f3.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f4.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f5.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f6.png" alt=""/></p>

<h3>2、归档功能</h3>

<h4>blog的结构体属性如下</h4>

<pre><code class="language-go">package model

type Blog struct {
    Id           int
    Title        string    `form:&#34;title&#34; json:&#34;title&#34;`                          //标题
    Content      string    `gorm:&#34;type:longtext&#34; form:&#34;content&#34; json:&#34;content&#34;` //内容
    Image        string    `gorm:&#34;type:text&#34; form:&#34;image&#34; json:&#34;image&#34;`         //首图
    Numb         int       `form:&#34;numb&#34; json:&#34;numb&#34;`                            //次数
    Flag         string    `form:&#34;flag&#34; json:&#34;flag&#34;`                            //原创或者转载
    Appreciation string    `form:&#34;appreciation&#34; json:&#34;appreciation&#34;`            //打赏开关
    ShareInfo    string    `form:&#34;shareInfo&#34; json:&#34;shareInfo&#34;`                  //版权开关
    Comment      string    `form:&#34;comment&#34; json:&#34;comment&#34;`                      //评论开关
    Recommend    string    `form:&#34;recommend&#34; json:&#34;recommend&#34;`                  //推荐开关
    Description  string    `gorm:&#34;type:text&#34; form:&#34;description&#34; json:&#34;description&#34;`
    CreatTime    string    `form:&#34;creatTime&#34;  json:&#34;creat_time,omitempty&#34;`   //创建时间
    UpdateTime   string    `form:&#34;updateTime&#34;  json:&#34;update_time,omitempty&#34;` //更新时间
    Comments     []Comment `form:&#34;comments&#34; json:&#34;comments&#34;`
    TypeId       int       `form:&#34;typeId&#34; json:&#34;typeId&#34;`
    Type         Type      `form:&#34;type&#34; gorm:&#34;ForeignKey:TypeId&#34;`
    Year         int       `form:&#34;year&#34; json:&#34;year&#34;`
    Month        int       `form:&#34;month&#34; json:&#34;month&#34;`
    Day          int       `form:&#34;day&#34; json:&#34;day&#34;`
}

</code></pre>

<h4>实现方法</h4>

<p>我的思路是创建三个时间节点
year month day
利用sql分组查询</p>

<h5>Group By分组查询步骤</h5>

<h6>（1）先按照年份查询</h6>

<h6>（2）再按照年份遍历每个月份</h6>

<p>并将所有保存在一个切片中</p>

<h6>（3）按照月份遍历每个月的所有文章</h6>

<p>保存在一个Map中，key是对应的月份，value是每个月份的所有文章</p>

<h4>自此归档功能实现</h4>

<h2>3.已知BUG</h2>

<h3>后台退出功能</h3>

<p>后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧</p>

<p>开源地址
<a href="https://github.com/likewl/blog" title="github" rel="nofollow">github</a>
<a href="https://gitee.com/nculike/blog" title="gitee" rel="nofollow">gitee</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 14:45:02][0m  [36;1m[0.39ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 14:57:28][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 14:57:28][0m  [36;1m[0.69ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 14:57:28][0m  [36;1m[0.23ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 14:57:28][0m  [36;1m[0.32ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 14:57:28][0m  [36;1m[0.27ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 14:57:28][0m  [36;1m[0.34ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-21 14:57:29][0m  [36;1m[0.52ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 14:57:29][0m  [36;1m[0.24ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 14:57:29][0m  [36;1m[0.68ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-21 14:57:29][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 14:57:30][0m  [36;1m[0.56ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 14:57:30][0m  [36;1m[0.71ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 14:57:30][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 14:57:30][0m  [36;1m[0.31ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 14:57:30][0m  [36;1m[0.25ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 14:57:30][0m  [36;1m[0.32ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 14:57:37][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 14:57:37][0m  [36;1m[1.07ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 14:57:37][0m  [36;1m[1.77ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 14:57:37][0m  [36;1m[0.31ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 14:57:37][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 14:57:37][0m  [36;1m[0.32ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 15:02:06][0m  [36;1m[0.56ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 15:02:06][0m  [36;1m[0.70ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 15:02:06][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 15:02:06][0m  [36;1m[0.29ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 15:02:06][0m  [36;1m[0.25ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 15:02:06][0m  [36;1m[0.33ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-21 15:02:18][0m  [36;1m[0.46ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 4)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-21 15:02:18][0m  [36;1m[0.50ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=4  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-21 15:02:18][0m  [36;1m[0.48ms][0m  UPDATE `blogs` SET `title` = '本博客开源公告', `content` = '今天本博客评论功能发布
# 自今天起，本博客基本功能已经完成
## 发布V1.0版本并开源
## 博客语言说明
#### 本博客后端是用golang 的gin框架+gorm编写
前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的
#### 博客效果参考本站
#一、博客简介
## 1.博客目录

    blog
    ├────controller
	├────└───admin
	|	|	├──adminblog.go
	|	|	├───adminController.go
	|	|	├──adminTag.go
	|	|	├──adminType.go
	|	|	└──adminUser.go
	|	└──page
	|		├──404.go
	|		├───about.go
	|		├──archives.go
	|		├──blog.go
	|		├──comment.go
	|		├──pagesController.go
	|		├──researchController.go
	|		└──tagsController.go
    ├── dao
	│	├──blogs.go
	│	├──comment.go
	│	├──sql.go
	│	├──tags.go
	│	├──types.go
	│	└──user.go
    ├── logic
    │   └── user.go
    ├── middlerware
	│	├──function.go
	│	├──getImg.go
	│	├──getTime.go
	│	├──markdown.go
	│	├──select.go
	│	└──session.go
    ├── model
	│	├──blog.go
	│	├──commnent.go
	│	├──tag.go
	│	├──type.go
	│	└──user/go
    ├── static
	│	└──静态文件（头像、图片、logo、css、js等）
    ├── templates
	│	└──html模板文件
    ├── go.mod（依赖）
    └── main.go
    

## 2.相关功能实现简介
### 1、评论及回复功能
comment的结构体属性如下
```go
package model

type Comment struct {
	Id     int //评论id
	BlogId int //博文id
	ReCommentId    int    //父评论id
	CommentName string //评论人姓名
	ReCommentName  string //父评论人姓名
	CommentEmail   string
	Img            string
	CommentContent string `gorm:"type:text" form:"CommentContent" json:"CommentContent"` //评论内容
	CommentTime    string ` json:"comment_time,omitempty"`
	Parent         *Comment
	Comments       []Comment
}
```
#### 实现方法
##### 1先通过查找父评论为-1的顶级评论
父评论Id为-1说明他不是任何评论的子评论
##### 2在html上遍历所有的顶级评论
在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论
###### （1）递归存储每个顶级评论的子评论
这里我用一个切片来储存一个顶级评论的所有子评论
```go
var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
	var comments []model.Comment
	DB.Debug().Where("re_comment_id = -1 AND blog_id = ?", id).Find(&comments)
	return &comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
	if count != 0 {
		fmt.Println("if判断1")
		var comments []model.Comment
		DB.Debug().Where("re_comment_id = ?", id).Find(&comments)
		count = len(comments)
		if count != 0 {
			fmt.Println("if判断2")
			for _, comment := range comments {
				fmt.Println("for判断1")
				Comments = append(Comments, comment)
				SelectCommentByComment(comment.Id, count)
			}
		}
	}
	fmt.Println(Comments)
	return &Comments

}
```
ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来
###### （2）出现问题的原因
因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量
###### （3）解决问题
```go
func ClearComments() bool {
	var comments []model.Comment
	Comments = comments
	return true
}

```
这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现
#### 这里我还加了一个小小的随机头像功能
```go
if  CommentName == user.Name && CommentEmail == user.UserEmail {
		fmt.Println("进入了1")
		comment.Img =user.UserImg
		//找相同评论人
	}else if CommentName == one.CommentName && CommentEmail == one.CommentEmail {
		fmt.Println("进入了2")
		comment.Img =one.Img
		//随机选头像
	}else{
		fmt.Println("进入了3")
		comment.Img =middleware.GetImg()
	}
```
##### 123分别代表三种不同的用户群体
1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
![](/static/images/%e5%a4%b4%e5%83%8f1.png)![](/static/images/%e5%a4%b4%e5%83%8f2.png)![](/static/images/%e5%a4%b4%e5%83%8f3.png)![](/static/images/%e5%a4%b4%e5%83%8f4.png)![](/static/images/%e5%a4%b4%e5%83%8f5.png)![](/static/images/%e5%a4%b4%e5%83%8f6.png)
### 2、归档功能
#### blog的结构体属性如下
```go
package model

type Blog struct {
	Id           int
	Title        string    `form:"title" json:"title"`                          //标题
	Content      string    `gorm:"type:longtext" form:"content" json:"content"` //内容
	Image        string    `gorm:"type:text" form:"image" json:"image"`         //首图
	Numb         int       `form:"numb" json:"numb"`                            //次数
	Flag         string    `form:"flag" json:"flag"`                            //原创或者转载
	Appreciation string    `form:"appreciation" json:"appreciation"`            //打赏开关
	ShareInfo    string    `form:"shareInfo" json:"shareInfo"`                  //版权开关
	Comment      string    `form:"comment" json:"comment"`                      //评论开关
	Recommend    string    `form:"recommend" json:"recommend"`                  //推荐开关
	Description  string    `gorm:"type:text" form:"description" json:"description"`
	CreatTime    string    `form:"creatTime"  json:"creat_time,omitempty"`   //创建时间
	UpdateTime   string    `form:"updateTime"  json:"update_time,omitempty"` //更新时间
	Comments     []Comment `form:"comments" json:"comments"`
	TypeId       int       `form:"typeId" json:"typeId"`
	Type         Type      `form:"type" gorm:"ForeignKey:TypeId"`
	Year         int       `form:"year" json:"year"`
	Month        int       `form:"month" json:"month"`
	Day          int       `form:"day" json:"day"`
}

```
#### 实现方法
我的思路是创建三个时间节点
year month day 
利用sql分组查询
##### Group By分组查询步骤
###### （1）先按照年份查询
###### （2）再按照年份遍历每个月份
并将所有保存在一个切片中
###### （3）按照月份遍历每个月的所有文章
保存在一个Map中，key是对应的月份，value是每个月份的所有文章
#### 自此归档功能实现


## 3.已知BUG
### 后台退出功能
后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧

开源地址
[github](https://github.com/likewl/blog "github")
[gitee](https://gitee.com/nculike/blog "gitee")', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1535821573,4166447487&fm=26&gp=0.jpg', `numb` = 40, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '本博客后端是用golang 的gin框架+gorm编写', `creat_time` = '2020-07-20 15:24:23', `update_time` = '2020-07-20 15:24:23', `type_id` = 4, `year` = 2020, `month` = 7, `day` = 20  WHERE `blogs`.`id` = 4  
[36;31m[1 rows affected or returned ][0m 
<p>今天本博客评论功能发布</p>

<h1>自今天起，本博客基本功能已经完成</h1>

<h2>发布V1.0版本并开源</h2>

<h2>博客语言说明</h2>

<h4>本博客后端是用golang 的gin框架+gorm编写</h4>

<p>前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的</p>

<h4>博客效果参考本站</h4>

<p>#一、博客简介</p>

<h2>1.博客目录</h2>

<pre><code>blog
├────controller
├────└───admin
|   |   ├──adminblog.go
|   |   ├───adminController.go
|   |   ├──adminTag.go
|   |   ├──adminType.go
|   |   └──adminUser.go
|   └──page
|       ├──404.go
|       ├───about.go
|       ├──archives.go
|       ├──blog.go
|       ├──comment.go
|       ├──pagesController.go
|       ├──researchController.go
|       └──tagsController.go
├── dao
│   ├──blogs.go
│   ├──comment.go
│   ├──sql.go
│   ├──tags.go
│   ├──types.go
│   └──user.go
├── logic
│   └── user.go
├── middlerware
│   ├──function.go
│   ├──getImg.go
│   ├──getTime.go
│   ├──markdown.go
│   ├──select.go
│   └──session.go
├── model
│   ├──blog.go
│   ├──commnent.go
│   ├──tag.go
│   ├──type.go
│   └──user/go
├── static
│   └──静态文件（头像、图片、logo、css、js等）
├── templates
│   └──html模板文件
├── go.mod（依赖）
└── main.go
</code></pre>

<h2>2.相关功能实现简介</h2>

<h3>1、评论及回复功能</h3>

<p>comment的结构体属性如下</p>

<pre><code class="language-go">package model

type Comment struct {
    Id     int //评论id
    BlogId int //博文id
    ReCommentId    int    //父评论id
    CommentName string //评论人姓名
    ReCommentName  string //父评论人姓名
    CommentEmail   string
    Img            string
    CommentContent string `gorm:&#34;type:text&#34; form:&#34;CommentContent&#34; json:&#34;CommentContent&#34;` //评论内容
    CommentTime    string ` json:&#34;comment_time,omitempty&#34;`
    Parent         *Comment
    Comments       []Comment
}
</code></pre>

<h4>实现方法</h4>

<h5>1先通过查找父评论为-1的顶级评论</h5>

<p>父评论Id为-1说明他不是任何评论的子评论</p>

<h5>2在html上遍历所有的顶级评论</h5>

<p>在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论</p>

<h6>（1）递归存储每个顶级评论的子评论</h6>

<p>这里我用一个切片来储存一个顶级评论的所有子评论</p>

<pre><code class="language-go">var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
    var comments []model.Comment
    DB.Debug().Where(&#34;re_comment_id = -1 AND blog_id = ?&#34;, id).Find(&amp;comments)
    return &amp;comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
    if count != 0 {
        fmt.Println(&#34;if判断1&#34;)
        var comments []model.Comment
        DB.Debug().Where(&#34;re_comment_id = ?&#34;, id).Find(&amp;comments)
        count = len(comments)
        if count != 0 {
            fmt.Println(&#34;if判断2&#34;)
            for _, comment := range comments {
                fmt.Println(&#34;for判断1&#34;)
                Comments = append(Comments, comment)
                SelectCommentByComment(comment.Id, count)
            }
        }
    }
    fmt.Println(Comments)
    return &amp;Comments

}
</code></pre>

<p>ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来</p>

<h6>（2）出现问题的原因</h6>

<p>因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量</p>

<h6>（3）解决问题</h6>

<pre><code class="language-go">func ClearComments() bool {
    var comments []model.Comment
    Comments = comments
    return true
}

</code></pre>

<p>这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现</p>

<h4>这里我还加了一个小小的随机头像功能</h4>

<pre><code class="language-go">if  CommentName == user.Name &amp;&amp; CommentEmail == user.UserEmail {
        fmt.Println(&#34;进入了1&#34;)
        comment.Img =user.UserImg
        //找相同评论人
    }else if CommentName == one.CommentName &amp;&amp; CommentEmail == one.CommentEmail {
        fmt.Println(&#34;进入了2&#34;)
        comment.Img =one.Img
        //随机选头像
    }else{
        fmt.Println(&#34;进入了3&#34;)
        comment.Img =middleware.GetImg()
    }
</code></pre>

<h5>123分别代表三种不同的用户群体</h5>

<p>1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
<img src="/static/images/%e5%a4%b4%e5%83%8f1.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f2.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f3.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f4.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f5.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f6.png" alt=""/></p>

<h3>2、归档功能</h3>

<h4>blog的结构体属性如下</h4>

<pre><code class="language-go">package model

type Blog struct {
    Id           int
    Title        string    `form:&#34;title&#34; json:&#34;title&#34;`                          //标题
    Content      string    `gorm:&#34;type:longtext&#34; form:&#34;content&#34; json:&#34;content&#34;` //内容
    Image        string    `gorm:&#34;type:text&#34; form:&#34;image&#34; json:&#34;image&#34;`         //首图
    Numb         int       `form:&#34;numb&#34; json:&#34;numb&#34;`                            //次数
    Flag         string    `form:&#34;flag&#34; json:&#34;flag&#34;`                            //原创或者转载
    Appreciation string    `form:&#34;appreciation&#34; json:&#34;appreciation&#34;`            //打赏开关
    ShareInfo    string    `form:&#34;shareInfo&#34; json:&#34;shareInfo&#34;`                  //版权开关
    Comment      string    `form:&#34;comment&#34; json:&#34;comment&#34;`                      //评论开关
    Recommend    string    `form:&#34;recommend&#34; json:&#34;recommend&#34;`                  //推荐开关
    Description  string    `gorm:&#34;type:text&#34; form:&#34;description&#34; json:&#34;description&#34;`
    CreatTime    string    `form:&#34;creatTime&#34;  json:&#34;creat_time,omitempty&#34;`   //创建时间
    UpdateTime   string    `form:&#34;updateTime&#34;  json:&#34;update_time,omitempty&#34;` //更新时间
    Comments     []Comment `form:&#34;comments&#34; json:&#34;comments&#34;`
    TypeId       int       `form:&#34;typeId&#34; json:&#34;typeId&#34;`
    Type         Type      `form:&#34;type&#34; gorm:&#34;ForeignKey:TypeId&#34;`
    Year         int       `form:&#34;year&#34; json:&#34;year&#34;`
    Month        int       `form:&#34;month&#34; json:&#34;month&#34;`
    Day          int       `form:&#34;day&#34; json:&#34;day&#34;`
}

</code></pre>

<h4>实现方法</h4>

<p>我的思路是创建三个时间节点
year month day
利用sql分组查询</p>

<h5>Group By分组查询步骤</h5>

<h6>（1）先按照年份查询</h6>

<h6>（2）再按照年份遍历每个月份</h6>

<p>并将所有保存在一个切片中</p>

<h6>（3）按照月份遍历每个月的所有文章</h6>

<p>保存在一个Map中，key是对应的月份，value是每个月份的所有文章</p>

<h4>自此归档功能实现</h4>

<h2>3.已知BUG</h2>

<h3>后台退出功能</h3>

<p>后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧</p>

<p>开源地址
<a href="https://github.com/likewl/blog" title="github" rel="nofollow">github</a>
<a href="https://gitee.com/nculike/blog" title="gitee" rel="nofollow">gitee</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 15:02:18][0m  [36;1m[0.29ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 15:11:09][0m  [36;1m[0.62ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 15:11:09][0m  [36;1m[0.75ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 15:11:09][0m  [36;1m[0.22ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 15:11:09][0m  [36;1m[0.32ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 15:11:09][0m  [36;1m[0.29ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 15:11:09][0m  [36;1m[0.33ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 
2020/07/21 15:11:09 http: panic serving 42.120.73.179:61622: write tcp 172.16.13.169:80->42.120.73.179:61622: write: broken pipe
goroutine 4217 [running]:
net/http.(*conn).serve.func1(0xc0000be000)
	/usr/local/go/src/net/http/server.go:1772 +0x139
panic(0xb50ee0, 0xc000066690)
	/usr/local/go/src/runtime/panic.go:975 +0x3e3
github.com/gin-gonic/gin.(*Context).Render(0xc0005bc2d0, 0xc8, 0xd0e260, 0xc00028ca80)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:842 +0x173
github.com/gin-gonic/gin.(*Context).HTML(0xc0005bc2d0, 0xc8, 0xbf926d, 0x10, 0xb43d60, 0xc00063a180)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:851 +0x99
blog/controller/page.IndexHandler(0xc0005bc2d0)
	/usr/workspace/src/blog/controller/page/pagesController.go:22 +0x570
github.com/gin-gonic/gin.(*Context).Next(0xc0005bc2d0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:161 +0x3b
github.com/gin-contrib/sessions.Sessions.func1(0xc0005bc2d0)
	/usr/workspace/pkg/mod/github.com/gin-contrib/sessions@v0.0.3/sessions.go:52 +0x16d
github.com/gin-gonic/gin.(*Context).Next(0xc0005bc2d0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:161 +0x3b
github.com/gin-gonic/gin.(*Engine).handleHTTPRequest(0xc0003b8500, 0xc0005bc2d0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/gin.go:409 +0x666
github.com/gin-gonic/gin.(*Engine).ServeHTTP(0xc0003b8500, 0xd12a40, 0xc0000b80e0, 0xc0000f2000)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/gin.go:367 +0x14d
net/http.serverHandler.ServeHTTP(0xc0000b8380, 0xd12a40, 0xc0000b80e0, 0xc0000f2000)
	/usr/local/go/src/net/http/server.go:2807 +0xa3
net/http.(*conn).serve(0xc0000be000, 0xd15200, 0xc0001b2040)
	/usr/local/go/src/net/http/server.go:1895 +0x86c
created by net/http.(*Server).Serve
	/usr/local/go/src/net/http/server.go:2933 +0x35c

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 15:11:09][0m  [36;1m[0.61ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
2020/07/21 15:11:09 http: panic serving 42.120.73.179:15095: write tcp 172.16.13.169:80->42.120.73.179:15095: write: broken pipe
goroutine 4244 [running]:
net/http.(*conn).serve.func1(0xc0000bec80)
	/usr/local/go/src/net/http/server.go:1772 +0x139
panic(0xb50ee0, 0xc000066a00)
	/usr/local/go/src/runtime/panic.go:975 +0x3e3
github.com/gin-gonic/gin.(*Context).Render(0xc0005bc690, 0x194, 0xd0e260, 0xc000601cb0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:842 +0x173
github.com/gin-gonic/gin.(*Context).HTML(0xc0005bc690, 0x194, 0xbf193d, 0x8, 0xb43d60, 0xc000293890)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:851 +0x99
blog/controller/page.NotFoundHandler(0xc0005bc690)
	/usr/workspace/src/blog/controller/page/404.go:12 +0x120
github.com/gin-gonic/gin.(*Context).Next(0xc0005bc690)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:161 +0x3b
github.com/gin-contrib/sessions.Sessions.func1(0xc0005bc690)
	/usr/workspace/pkg/mod/github.com/gin-contrib/sessions@v0.0.3/sessions.go:52 +0x16d
github.com/gin-gonic/gin.(*Context).Next(0xc0005bc690)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:161 +0x3b
github.com/gin-gonic/gin.serveError(0xc0005bc690, 0x194, 0x1248dc0, 0x12, 0x12)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/gin.go:445 +0x38
github.com/gin-gonic/gin.(*Engine).handleHTTPRequest(0xc0003b8500, 0xc0005bc690)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/gin.go:438 +0x3d3
github.com/gin-gonic/gin.(*Engine).ServeHTTP(0xc0003b8500, 0xd12a40, 0xc0000b8540, 0xc000280500)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/gin.go:367 +0x14d
net/http.serverHandler.ServeHTTP(0xc0000b8380, 0xd12a40, 0xc0000b8540, 0xc000280500)
	/usr/local/go/src/net/http/server.go:2807 +0xa3
net/http.(*conn).serve(0xc0000bec80, 0xd15200, 0xc000290080)
	/usr/local/go/src/net/http/server.go:1895 +0x86c
created by net/http.(*Server).Serve
	/usr/local/go/src/net/http/server.go:2933 +0x35c

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 15:25:39][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 15:25:39][0m  [36;1m[0.77ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 15:25:39][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 15:25:39][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 15:25:39][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 15:25:39][0m  [36;1m[0.34ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-21 15:25:55][0m  [36;1m[0.37ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 4)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-21 15:25:55][0m  [36;1m[0.42ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=4  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-21 15:25:55][0m  [36;1m[0.44ms][0m  UPDATE `blogs` SET `title` = '本博客开源公告', `content` = '今天本博客评论功能发布
# 自今天起，本博客基本功能已经完成
## 发布V1.0版本并开源
## 博客语言说明
#### 本博客后端是用golang 的gin框架+gorm编写
前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的
#### 博客效果参考本站
#一、博客简介
## 1.博客目录

    blog
    ├────controller
	├────└───admin
	|	|	├──adminblog.go
	|	|	├───adminController.go
	|	|	├──adminTag.go
	|	|	├──adminType.go
	|	|	└──adminUser.go
	|	└──page
	|		├──404.go
	|		├───about.go
	|		├──archives.go
	|		├──blog.go
	|		├──comment.go
	|		├──pagesController.go
	|		├──researchController.go
	|		└──tagsController.go
    ├── dao
	│	├──blogs.go
	│	├──comment.go
	│	├──sql.go
	│	├──tags.go
	│	├──types.go
	│	└──user.go
    ├── logic
    │   └── user.go
    ├── middlerware
	│	├──function.go
	│	├──getImg.go
	│	├──getTime.go
	│	├──markdown.go
	│	├──select.go
	│	└──session.go
    ├── model
	│	├──blog.go
	│	├──commnent.go
	│	├──tag.go
	│	├──type.go
	│	└──user/go
    ├── static
	│	└──静态文件（头像、图片、logo、css、js等）
    ├── templates
	│	└──html模板文件
    ├── go.mod（依赖）
    └── main.go
    

## 2.相关功能实现简介
### 1、评论及回复功能
comment的结构体属性如下
```go
package model

type Comment struct {
	Id     int //评论id
	BlogId int //博文id
	ReCommentId    int    //父评论id
	CommentName string //评论人姓名
	ReCommentName  string //父评论人姓名
	CommentEmail   string
	Img            string
	CommentContent string `gorm:"type:text" form:"CommentContent" json:"CommentContent"` //评论内容
	CommentTime    string ` json:"comment_time,omitempty"`
	Parent         *Comment
	Comments       []Comment
}
```
#### 实现方法
##### 1先通过查找父评论为-1的顶级评论
父评论Id为-1说明他不是任何评论的子评论
##### 2在html上遍历所有的顶级评论
在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论
###### （1）递归存储每个顶级评论的子评论
这里我用一个切片来储存一个顶级评论的所有子评论
```go
var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
	var comments []model.Comment
	DB.Debug().Where("re_comment_id = -1 AND blog_id = ?", id).Find(&comments)
	return &comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
	if count != 0 {
		fmt.Println("if判断1")
		var comments []model.Comment
		DB.Debug().Where("re_comment_id = ?", id).Find(&comments)
		count = len(comments)
		if count != 0 {
			fmt.Println("if判断2")
			for _, comment := range comments {
				fmt.Println("for判断1")
				Comments = append(Comments, comment)
				SelectCommentByComment(comment.Id, count)
			}
		}
	}
	fmt.Println(Comments)
	return &Comments

}
```
ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来
###### （2）出现问题的原因
因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量
###### （3）解决问题
```go
func ClearComments() bool {
	var comments []model.Comment
	Comments = comments
	return true
}

```
这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现
#### 这里我还加了一个小小的随机头像功能
```go
if  CommentName == user.Name && CommentEmail == user.UserEmail {
		fmt.Println("进入了1")
		comment.Img =user.UserImg
		//找相同评论人
	}else if CommentName == one.CommentName && CommentEmail == one.CommentEmail {
		fmt.Println("进入了2")
		comment.Img =one.Img
		//随机选头像
	}else{
		fmt.Println("进入了3")
		comment.Img =middleware.GetImg()
	}
```
##### 123分别代表三种不同的用户群体
1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
![](/static/images/%e5%a4%b4%e5%83%8f1.png)![](/static/images/%e5%a4%b4%e5%83%8f2.png)![](/static/images/%e5%a4%b4%e5%83%8f3.png)![](/static/images/%e5%a4%b4%e5%83%8f4.png)![](/static/images/%e5%a4%b4%e5%83%8f5.png)![](/static/images/%e5%a4%b4%e5%83%8f6.png)
### 2、归档功能
#### blog的结构体属性如下
```go
package model

type Blog struct {
	Id           int
	Title        string    `form:"title" json:"title"`                          //标题
	Content      string    `gorm:"type:longtext" form:"content" json:"content"` //内容
	Image        string    `gorm:"type:text" form:"image" json:"image"`         //首图
	Numb         int       `form:"numb" json:"numb"`                            //次数
	Flag         string    `form:"flag" json:"flag"`                            //原创或者转载
	Appreciation string    `form:"appreciation" json:"appreciation"`            //打赏开关
	ShareInfo    string    `form:"shareInfo" json:"shareInfo"`                  //版权开关
	Comment      string    `form:"comment" json:"comment"`                      //评论开关
	Recommend    string    `form:"recommend" json:"recommend"`                  //推荐开关
	Description  string    `gorm:"type:text" form:"description" json:"description"`
	CreatTime    string    `form:"creatTime"  json:"creat_time,omitempty"`   //创建时间
	UpdateTime   string    `form:"updateTime"  json:"update_time,omitempty"` //更新时间
	Comments     []Comment `form:"comments" json:"comments"`
	TypeId       int       `form:"typeId" json:"typeId"`
	Type         Type      `form:"type" gorm:"ForeignKey:TypeId"`
	Year         int       `form:"year" json:"year"`
	Month        int       `form:"month" json:"month"`
	Day          int       `form:"day" json:"day"`
}

```
#### 实现方法
我的思路是创建三个时间节点
year month day 
利用sql分组查询
##### Group By分组查询步骤
###### （1）先按照年份查询
###### （2）再按照年份遍历每个月份
并将所有保存在一个切片中
###### （3）按照月份遍历每个月的所有文章
保存在一个Map中，key是对应的月份，value是每个月份的所有文章
#### 自此归档功能实现


## 3.已知BUG
### 后台退出功能
后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧

开源地址
[github](https://github.com/likewl/blog "github")
[gitee](https://gitee.com/nculike/blog "gitee")', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1535821573,4166447487&fm=26&gp=0.jpg', `numb` = 41, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '本博客后端是用golang 的gin框架+gorm编写', `creat_time` = '2020-07-20 15:24:23', `update_time` = '2020-07-20 15:24:23', `type_id` = 4, `year` = 2020, `month` = 7, `day` = 20  WHERE `blogs`.`id` = 4  
[36;31m[1 rows affected or returned ][0m 
<p>今天本博客评论功能发布</p>

<h1>自今天起，本博客基本功能已经完成</h1>

<h2>发布V1.0版本并开源</h2>

<h2>博客语言说明</h2>

<h4>本博客后端是用golang 的gin框架+gorm编写</h4>

<p>前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的</p>

<h4>博客效果参考本站</h4>

<p>#一、博客简介</p>

<h2>1.博客目录</h2>

<pre><code>blog
├────controller
├────└───admin
|   |   ├──adminblog.go
|   |   ├───adminController.go
|   |   ├──adminTag.go
|   |   ├──adminType.go
|   |   └──adminUser.go
|   └──page
|       ├──404.go
|       ├───about.go
|       ├──archives.go
|       ├──blog.go
|       ├──comment.go
|       ├──pagesController.go
|       ├──researchController.go
|       └──tagsController.go
├── dao
│   ├──blogs.go
│   ├──comment.go
│   ├──sql.go
│   ├──tags.go
│   ├──types.go
│   └──user.go
├── logic
│   └── user.go
├── middlerware
│   ├──function.go
│   ├──getImg.go
│   ├──getTime.go
│   ├──markdown.go
│   ├──select.go
│   └──session.go
├── model
│   ├──blog.go
│   ├──commnent.go
│   ├──tag.go
│   ├──type.go
│   └──user/go
├── static
│   └──静态文件（头像、图片、logo、css、js等）
├── templates
│   └──html模板文件
├── go.mod（依赖）
└── main.go
</code></pre>

<h2>2.相关功能实现简介</h2>

<h3>1、评论及回复功能</h3>

<p>comment的结构体属性如下</p>

<pre><code class="language-go">package model

type Comment struct {
    Id     int //评论id
    BlogId int //博文id
    ReCommentId    int    //父评论id
    CommentName string //评论人姓名
    ReCommentName  string //父评论人姓名
    CommentEmail   string
    Img            string
    CommentContent string `gorm:&#34;type:text&#34; form:&#34;CommentContent&#34; json:&#34;CommentContent&#34;` //评论内容
    CommentTime    string ` json:&#34;comment_time,omitempty&#34;`
    Parent         *Comment
    Comments       []Comment
}
</code></pre>

<h4>实现方法</h4>

<h5>1先通过查找父评论为-1的顶级评论</h5>

<p>父评论Id为-1说明他不是任何评论的子评论</p>

<h5>2在html上遍历所有的顶级评论</h5>

<p>在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论</p>

<h6>（1）递归存储每个顶级评论的子评论</h6>

<p>这里我用一个切片来储存一个顶级评论的所有子评论</p>

<pre><code class="language-go">var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
    var comments []model.Comment
    DB.Debug().Where(&#34;re_comment_id = -1 AND blog_id = ?&#34;, id).Find(&amp;comments)
    return &amp;comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
    if count != 0 {
        fmt.Println(&#34;if判断1&#34;)
        var comments []model.Comment
        DB.Debug().Where(&#34;re_comment_id = ?&#34;, id).Find(&amp;comments)
        count = len(comments)
        if count != 0 {
            fmt.Println(&#34;if判断2&#34;)
            for _, comment := range comments {
                fmt.Println(&#34;for判断1&#34;)
                Comments = append(Comments, comment)
                SelectCommentByComment(comment.Id, count)
            }
        }
    }
    fmt.Println(Comments)
    return &amp;Comments

}
</code></pre>

<p>ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来</p>

<h6>（2）出现问题的原因</h6>

<p>因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量</p>

<h6>（3）解决问题</h6>

<pre><code class="language-go">func ClearComments() bool {
    var comments []model.Comment
    Comments = comments
    return true
}

</code></pre>

<p>这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现</p>

<h4>这里我还加了一个小小的随机头像功能</h4>

<pre><code class="language-go">if  CommentName == user.Name &amp;&amp; CommentEmail == user.UserEmail {
        fmt.Println(&#34;进入了1&#34;)
        comment.Img =user.UserImg
        //找相同评论人
    }else if CommentName == one.CommentName &amp;&amp; CommentEmail == one.CommentEmail {
        fmt.Println(&#34;进入了2&#34;)
        comment.Img =one.Img
        //随机选头像
    }else{
        fmt.Println(&#34;进入了3&#34;)
        comment.Img =middleware.GetImg()
    }
</code></pre>

<h5>123分别代表三种不同的用户群体</h5>

<p>1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
<img src="/static/images/%e5%a4%b4%e5%83%8f1.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f2.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f3.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f4.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f5.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f6.png" alt=""/></p>

<h3>2、归档功能</h3>

<h4>blog的结构体属性如下</h4>

<pre><code class="language-go">package model

type Blog struct {
    Id           int
    Title        string    `form:&#34;title&#34; json:&#34;title&#34;`                          //标题
    Content      string    `gorm:&#34;type:longtext&#34; form:&#34;content&#34; json:&#34;content&#34;` //内容
    Image        string    `gorm:&#34;type:text&#34; form:&#34;image&#34; json:&#34;image&#34;`         //首图
    Numb         int       `form:&#34;numb&#34; json:&#34;numb&#34;`                            //次数
    Flag         string    `form:&#34;flag&#34; json:&#34;flag&#34;`                            //原创或者转载
    Appreciation string    `form:&#34;appreciation&#34; json:&#34;appreciation&#34;`            //打赏开关
    ShareInfo    string    `form:&#34;shareInfo&#34; json:&#34;shareInfo&#34;`                  //版权开关
    Comment      string    `form:&#34;comment&#34; json:&#34;comment&#34;`                      //评论开关
    Recommend    string    `form:&#34;recommend&#34; json:&#34;recommend&#34;`                  //推荐开关
    Description  string    `gorm:&#34;type:text&#34; form:&#34;description&#34; json:&#34;description&#34;`
    CreatTime    string    `form:&#34;creatTime&#34;  json:&#34;creat_time,omitempty&#34;`   //创建时间
    UpdateTime   string    `form:&#34;updateTime&#34;  json:&#34;update_time,omitempty&#34;` //更新时间
    Comments     []Comment `form:&#34;comments&#34; json:&#34;comments&#34;`
    TypeId       int       `form:&#34;typeId&#34; json:&#34;typeId&#34;`
    Type         Type      `form:&#34;type&#34; gorm:&#34;ForeignKey:TypeId&#34;`
    Year         int       `form:&#34;year&#34; json:&#34;year&#34;`
    Month        int       `form:&#34;month&#34; json:&#34;month&#34;`
    Day          int       `form:&#34;day&#34; json:&#34;day&#34;`
}

</code></pre>

<h4>实现方法</h4>

<p>我的思路是创建三个时间节点
year month day
利用sql分组查询</p>

<h5>Group By分组查询步骤</h5>

<h6>（1）先按照年份查询</h6>

<h6>（2）再按照年份遍历每个月份</h6>

<p>并将所有保存在一个切片中</p>

<h6>（3）按照月份遍历每个月的所有文章</h6>

<p>保存在一个Map中，key是对应的月份，value是每个月份的所有文章</p>

<h4>自此归档功能实现</h4>

<h2>3.已知BUG</h2>

<h3>后台退出功能</h3>

<p>后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧</p>

<p>开源地址
<a href="https://github.com/likewl/blog" title="github" rel="nofollow">github</a>
<a href="https://gitee.com/nculike/blog" title="gitee" rel="nofollow">gitee</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 15:25:55][0m  [36;1m[0.26ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 16:41:03][0m  [36;1m[0.53ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 16:41:03][0m  [36;1m[0.72ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 16:41:03][0m  [36;1m[0.23ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 16:41:03][0m  [36;1m[0.29ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 16:41:03][0m  [36;1m[0.35ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 16:41:03][0m  [36;1m[0.32ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 16:41:06][0m  [36;1m[0.58ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 16:41:06][0m  [36;1m[0.73ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 16:41:06][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 16:41:06][0m  [36;1m[0.34ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 16:41:06][0m  [36;1m[0.28ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 16:41:06][0m  [36;1m[0.37ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 16:41:09][0m  [36;1m[0.59ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 16:41:09][0m  [36;1m[0.75ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 16:41:09][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 16:41:09][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 16:41:09][0m  [36;1m[0.27ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 16:41:09][0m  [36;1m[0.35ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 16:41:10][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 16:41:10][0m  [36;1m[0.77ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 16:41:10][0m  [36;1m[0.22ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 16:41:10][0m  [36;1m[0.34ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 16:41:10][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 16:41:10][0m  [36;1m[0.35ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 16:49:51][0m  [36;1m[0.53ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 16:49:51][0m  [36;1m[0.72ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 16:49:51][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 16:49:51][0m  [36;1m[0.31ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 16:49:51][0m  [36;1m[0.25ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 16:49:51][0m  [36;1m[0.32ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 17:03:32][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 17:03:32][0m  [36;1m[0.67ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 17:03:32][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 17:03:32][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 17:03:32][0m  [36;1m[0.25ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 17:03:32][0m  [36;1m[0.34ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 17:37:58][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 17:37:58][0m  [36;1m[0.68ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 17:37:58][0m  [36;1m[0.24ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 17:37:58][0m  [36;1m[0.40ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 17:37:58][0m  [36;1m[0.25ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 17:37:58][0m  [36;1m[0.32ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-21 17:38:12][0m  [36;1m[0.92ms][0m  SELECT * FROM `tags`    
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 17:38:12][0m  [36;1m[1.75ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 17:38:12][0m  [36;1m[0.67ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:31)[0m 
[33m[2020-07-21 17:38:12][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `tags`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-21 17:38:14][0m  [36;1m[0.53ms][0m  SELECT * FROM `tags`    
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 17:38:14][0m  [36;1m[0.25ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:68)[0m 
[33m[2020-07-21 17:38:14][0m  [36;1m[0.40ms][0m  SELECT * FROM `tags`  WHERE (tag_name='项目部署') ORDER BY `tags`.`id` ASC LIMIT 1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:76)[0m 
[33m[2020-07-21 17:38:14][0m  [36;1m[0.86ms][0m   SELECT b.id,b.title,b.type_id,t.tag_name,b.description,b.recommend,b.numb,b.update_time,b.image,a.`type_name`  FROM `blogs` b LEFT JOIN `tag_blogs` tb ON b.id = tb.`blog_id` LEFT JOIN tags t ON tb.`tag_id`=t.`id` LEFT JOIN `types` a ON b.type_id = a.`id` WHERE t.`id`=1 ORDER BY b.id  DESC LIMIT 10 OFFSET 0  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:31)[0m 
[33m[2020-07-21 17:38:14][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `tags`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-21 17:38:15][0m  [36;1m[0.35ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 2)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-21 17:38:15][0m  [36;1m[0.42ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=2  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-21 17:38:15][0m  [36;1m[0.37ms][0m  UPDATE `blogs` SET `title` = '解决Linux关闭终端后运行的程序自动停止', `content` = '# 问题发现
  昨天博客发布，操作完关闭终端就睡了
  然而今天醒来突然发现终端不能访问了
  查看发现原来博客项目进程被杀死了
# 解决办法
    go build main.go
执行完后

    nohup ./main &
让程序在后台运行就可了


[========]
# ps:这个方法并不完美，因为我也是刚刚接触还不知道怎么切回来', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3696516981,3671280793&fm=26&gp=0.jpg', `numb` = 19, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '昨天博客发布，操作完关闭终端就睡了，然而今天醒来突然发现终端不能访问了，查看发现原来博客项目进程被杀死了', `creat_time` = '2020-07-19 19:05:36', `update_time` = '2020-07-19 19:05:36', `type_id` = 2, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 3  
[36;31m[1 rows affected or returned ][0m 
<h1>问题发现</h1>

<p>昨天博客发布，操作完关闭终端就睡了
  然而今天醒来突然发现终端不能访问了
  查看发现原来博客项目进程被杀死了</p>

<h1>解决办法</h1>

<pre><code>go build main.go
</code></pre>

<p>执行完后</p>

<pre><code>nohup ./main &amp;
</code></pre>

<p>让程序在后台运行就可了</p>

<p>[========]</p>

<h1>ps:这个方法并不完美，因为我也是刚刚接触还不知道怎么切回来</h1>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 17:38:15][0m  [36;1m[0.26ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 17:38:34][0m  [36;1m[0.49ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 17:38:34][0m  [36;1m[0.68ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 17:38:34][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 17:38:34][0m  [36;1m[0.28ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 17:38:34][0m  [36;1m[0.25ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 17:38:34][0m  [36;1m[0.31ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-21 17:38:36][0m  [36;1m[0.38ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 4)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-21 17:38:36][0m  [36;1m[0.45ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=4  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-21 17:38:36][0m  [36;1m[0.48ms][0m  UPDATE `blogs` SET `title` = '本博客开源公告', `content` = '今天本博客评论功能发布
# 自今天起，本博客基本功能已经完成
## 发布V1.0版本并开源
## 博客语言说明
#### 本博客后端是用golang 的gin框架+gorm编写
前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的
#### 博客效果参考本站
#一、博客简介
## 1.博客目录

    blog
    ├────controller
	├────└───admin
	|	|	├──adminblog.go
	|	|	├───adminController.go
	|	|	├──adminTag.go
	|	|	├──adminType.go
	|	|	└──adminUser.go
	|	└──page
	|		├──404.go
	|		├───about.go
	|		├──archives.go
	|		├──blog.go
	|		├──comment.go
	|		├──pagesController.go
	|		├──researchController.go
	|		└──tagsController.go
    ├── dao
	│	├──blogs.go
	│	├──comment.go
	│	├──sql.go
	│	├──tags.go
	│	├──types.go
	│	└──user.go
    ├── logic
    │   └── user.go
    ├── middlerware
	│	├──function.go
	│	├──getImg.go
	│	├──getTime.go
	│	├──markdown.go
	│	├──select.go
	│	└──session.go
    ├── model
	│	├──blog.go
	│	├──commnent.go
	│	├──tag.go
	│	├──type.go
	│	└──user/go
    ├── static
	│	└──静态文件（头像、图片、logo、css、js等）
    ├── templates
	│	└──html模板文件
    ├── go.mod（依赖）
    └── main.go
    

## 2.相关功能实现简介
### 1、评论及回复功能
comment的结构体属性如下
```go
package model

type Comment struct {
	Id     int //评论id
	BlogId int //博文id
	ReCommentId    int    //父评论id
	CommentName string //评论人姓名
	ReCommentName  string //父评论人姓名
	CommentEmail   string
	Img            string
	CommentContent string `gorm:"type:text" form:"CommentContent" json:"CommentContent"` //评论内容
	CommentTime    string ` json:"comment_time,omitempty"`
	Parent         *Comment
	Comments       []Comment
}
```
#### 实现方法
##### 1先通过查找父评论为-1的顶级评论
父评论Id为-1说明他不是任何评论的子评论
##### 2在html上遍历所有的顶级评论
在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论
###### （1）递归存储每个顶级评论的子评论
这里我用一个切片来储存一个顶级评论的所有子评论
```go
var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
	var comments []model.Comment
	DB.Debug().Where("re_comment_id = -1 AND blog_id = ?", id).Find(&comments)
	return &comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
	if count != 0 {
		fmt.Println("if判断1")
		var comments []model.Comment
		DB.Debug().Where("re_comment_id = ?", id).Find(&comments)
		count = len(comments)
		if count != 0 {
			fmt.Println("if判断2")
			for _, comment := range comments {
				fmt.Println("for判断1")
				Comments = append(Comments, comment)
				SelectCommentByComment(comment.Id, count)
			}
		}
	}
	fmt.Println(Comments)
	return &Comments

}
```
ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来
###### （2）出现问题的原因
因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量
###### （3）解决问题
```go
func ClearComments() bool {
	var comments []model.Comment
	Comments = comments
	return true
}

```
这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现
#### 这里我还加了一个小小的随机头像功能
```go
if  CommentName == user.Name && CommentEmail == user.UserEmail {
		fmt.Println("进入了1")
		comment.Img =user.UserImg
		//找相同评论人
	}else if CommentName == one.CommentName && CommentEmail == one.CommentEmail {
		fmt.Println("进入了2")
		comment.Img =one.Img
		//随机选头像
	}else{
		fmt.Println("进入了3")
		comment.Img =middleware.GetImg()
	}
```
##### 123分别代表三种不同的用户群体
1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
![](/static/images/%e5%a4%b4%e5%83%8f1.png)![](/static/images/%e5%a4%b4%e5%83%8f2.png)![](/static/images/%e5%a4%b4%e5%83%8f3.png)![](/static/images/%e5%a4%b4%e5%83%8f4.png)![](/static/images/%e5%a4%b4%e5%83%8f5.png)![](/static/images/%e5%a4%b4%e5%83%8f6.png)
### 2、归档功能
#### blog的结构体属性如下
```go
package model

type Blog struct {
	Id           int
	Title        string    `form:"title" json:"title"`                          //标题
	Content      string    `gorm:"type:longtext" form:"content" json:"content"` //内容
	Image        string    `gorm:"type:text" form:"image" json:"image"`         //首图
	Numb         int       `form:"numb" json:"numb"`                            //次数
	Flag         string    `form:"flag" json:"flag"`                            //原创或者转载
	Appreciation string    `form:"appreciation" json:"appreciation"`            //打赏开关
	ShareInfo    string    `form:"shareInfo" json:"shareInfo"`                  //版权开关
	Comment      string    `form:"comment" json:"comment"`                      //评论开关
	Recommend    string    `form:"recommend" json:"recommend"`                  //推荐开关
	Description  string    `gorm:"type:text" form:"description" json:"description"`
	CreatTime    string    `form:"creatTime"  json:"creat_time,omitempty"`   //创建时间
	UpdateTime   string    `form:"updateTime"  json:"update_time,omitempty"` //更新时间
	Comments     []Comment `form:"comments" json:"comments"`
	TypeId       int       `form:"typeId" json:"typeId"`
	Type         Type      `form:"type" gorm:"ForeignKey:TypeId"`
	Year         int       `form:"year" json:"year"`
	Month        int       `form:"month" json:"month"`
	Day          int       `form:"day" json:"day"`
}

```
#### 实现方法
我的思路是创建三个时间节点
year month day 
利用sql分组查询
##### Group By分组查询步骤
###### （1）先按照年份查询
###### （2）再按照年份遍历每个月份
并将所有保存在一个切片中
###### （3）按照月份遍历每个月的所有文章
保存在一个Map中，key是对应的月份，value是每个月份的所有文章
#### 自此归档功能实现


## 3.已知BUG
### 后台退出功能
后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧

开源地址
[github](https://github.com/likewl/blog "github")
[gitee](https://gitee.com/nculike/blog "gitee")', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1535821573,4166447487&fm=26&gp=0.jpg', `numb` = 42, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '本博客后端是用golang 的gin框架+gorm编写', `creat_time` = '2020-07-20 15:24:23', `update_time` = '2020-07-20 15:24:23', `type_id` = 4, `year` = 2020, `month` = 7, `day` = 20  WHERE `blogs`.`id` = 4  
[36;31m[1 rows affected or returned ][0m 
<p>今天本博客评论功能发布</p>

<h1>自今天起，本博客基本功能已经完成</h1>

<h2>发布V1.0版本并开源</h2>

<h2>博客语言说明</h2>

<h4>本博客后端是用golang 的gin框架+gorm编写</h4>

<p>前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的</p>

<h4>博客效果参考本站</h4>

<p>#一、博客简介</p>

<h2>1.博客目录</h2>

<pre><code>blog
├────controller
├────└───admin
|   |   ├──adminblog.go
|   |   ├───adminController.go
|   |   ├──adminTag.go
|   |   ├──adminType.go
|   |   └──adminUser.go
|   └──page
|       ├──404.go
|       ├───about.go
|       ├──archives.go
|       ├──blog.go
|       ├──comment.go
|       ├──pagesController.go
|       ├──researchController.go
|       └──tagsController.go
├── dao
│   ├──blogs.go
│   ├──comment.go
│   ├──sql.go
│   ├──tags.go
│   ├──types.go
│   └──user.go
├── logic
│   └── user.go
├── middlerware
│   ├──function.go
│   ├──getImg.go
│   ├──getTime.go
│   ├──markdown.go
│   ├──select.go
│   └──session.go
├── model
│   ├──blog.go
│   ├──commnent.go
│   ├──tag.go
│   ├──type.go
│   └──user/go
├── static
│   └──静态文件（头像、图片、logo、css、js等）
├── templates
│   └──html模板文件
├── go.mod（依赖）
└── main.go
</code></pre>

<h2>2.相关功能实现简介</h2>

<h3>1、评论及回复功能</h3>

<p>comment的结构体属性如下</p>

<pre><code class="language-go">package model

type Comment struct {
    Id     int //评论id
    BlogId int //博文id
    ReCommentId    int    //父评论id
    CommentName string //评论人姓名
    ReCommentName  string //父评论人姓名
    CommentEmail   string
    Img            string
    CommentContent string `gorm:&#34;type:text&#34; form:&#34;CommentContent&#34; json:&#34;CommentContent&#34;` //评论内容
    CommentTime    string ` json:&#34;comment_time,omitempty&#34;`
    Parent         *Comment
    Comments       []Comment
}
</code></pre>

<h4>实现方法</h4>

<h5>1先通过查找父评论为-1的顶级评论</h5>

<p>父评论Id为-1说明他不是任何评论的子评论</p>

<h5>2在html上遍历所有的顶级评论</h5>

<p>在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论</p>

<h6>（1）递归存储每个顶级评论的子评论</h6>

<p>这里我用一个切片来储存一个顶级评论的所有子评论</p>

<pre><code class="language-go">var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
    var comments []model.Comment
    DB.Debug().Where(&#34;re_comment_id = -1 AND blog_id = ?&#34;, id).Find(&amp;comments)
    return &amp;comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
    if count != 0 {
        fmt.Println(&#34;if判断1&#34;)
        var comments []model.Comment
        DB.Debug().Where(&#34;re_comment_id = ?&#34;, id).Find(&amp;comments)
        count = len(comments)
        if count != 0 {
            fmt.Println(&#34;if判断2&#34;)
            for _, comment := range comments {
                fmt.Println(&#34;for判断1&#34;)
                Comments = append(Comments, comment)
                SelectCommentByComment(comment.Id, count)
            }
        }
    }
    fmt.Println(Comments)
    return &amp;Comments

}
</code></pre>

<p>ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来</p>

<h6>（2）出现问题的原因</h6>

<p>因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量</p>

<h6>（3）解决问题</h6>

<pre><code class="language-go">func ClearComments() bool {
    var comments []model.Comment
    Comments = comments
    return true
}

</code></pre>

<p>这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现</p>

<h4>这里我还加了一个小小的随机头像功能</h4>

<pre><code class="language-go">if  CommentName == user.Name &amp;&amp; CommentEmail == user.UserEmail {
        fmt.Println(&#34;进入了1&#34;)
        comment.Img =user.UserImg
        //找相同评论人
    }else if CommentName == one.CommentName &amp;&amp; CommentEmail == one.CommentEmail {
        fmt.Println(&#34;进入了2&#34;)
        comment.Img =one.Img
        //随机选头像
    }else{
        fmt.Println(&#34;进入了3&#34;)
        comment.Img =middleware.GetImg()
    }
</code></pre>

<h5>123分别代表三种不同的用户群体</h5>

<p>1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
<img src="/static/images/%e5%a4%b4%e5%83%8f1.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f2.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f3.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f4.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f5.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f6.png" alt=""/></p>

<h3>2、归档功能</h3>

<h4>blog的结构体属性如下</h4>

<pre><code class="language-go">package model

type Blog struct {
    Id           int
    Title        string    `form:&#34;title&#34; json:&#34;title&#34;`                          //标题
    Content      string    `gorm:&#34;type:longtext&#34; form:&#34;content&#34; json:&#34;content&#34;` //内容
    Image        string    `gorm:&#34;type:text&#34; form:&#34;image&#34; json:&#34;image&#34;`         //首图
    Numb         int       `form:&#34;numb&#34; json:&#34;numb&#34;`                            //次数
    Flag         string    `form:&#34;flag&#34; json:&#34;flag&#34;`                            //原创或者转载
    Appreciation string    `form:&#34;appreciation&#34; json:&#34;appreciation&#34;`            //打赏开关
    ShareInfo    string    `form:&#34;shareInfo&#34; json:&#34;shareInfo&#34;`                  //版权开关
    Comment      string    `form:&#34;comment&#34; json:&#34;comment&#34;`                      //评论开关
    Recommend    string    `form:&#34;recommend&#34; json:&#34;recommend&#34;`                  //推荐开关
    Description  string    `gorm:&#34;type:text&#34; form:&#34;description&#34; json:&#34;description&#34;`
    CreatTime    string    `form:&#34;creatTime&#34;  json:&#34;creat_time,omitempty&#34;`   //创建时间
    UpdateTime   string    `form:&#34;updateTime&#34;  json:&#34;update_time,omitempty&#34;` //更新时间
    Comments     []Comment `form:&#34;comments&#34; json:&#34;comments&#34;`
    TypeId       int       `form:&#34;typeId&#34; json:&#34;typeId&#34;`
    Type         Type      `form:&#34;type&#34; gorm:&#34;ForeignKey:TypeId&#34;`
    Year         int       `form:&#34;year&#34; json:&#34;year&#34;`
    Month        int       `form:&#34;month&#34; json:&#34;month&#34;`
    Day          int       `form:&#34;day&#34; json:&#34;day&#34;`
}

</code></pre>

<h4>实现方法</h4>

<p>我的思路是创建三个时间节点
year month day
利用sql分组查询</p>

<h5>Group By分组查询步骤</h5>

<h6>（1）先按照年份查询</h6>

<h6>（2）再按照年份遍历每个月份</h6>

<p>并将所有保存在一个切片中</p>

<h6>（3）按照月份遍历每个月的所有文章</h6>

<p>保存在一个Map中，key是对应的月份，value是每个月份的所有文章</p>

<h4>自此归档功能实现</h4>

<h2>3.已知BUG</h2>

<h3>后台退出功能</h3>

<p>后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧</p>

<p>开源地址
<a href="https://github.com/likewl/blog" title="github" rel="nofollow">github</a>
<a href="https://gitee.com/nculike/blog" title="gitee" rel="nofollow">gitee</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 17:38:36][0m  [36;1m[0.28ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-21 17:39:02][0m  [36;1m[0.54ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 17:39:02][0m  [36;1m[0.25ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 17:39:02][0m  [36;1m[0.70ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-21 17:39:02][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 17:39:03][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 17:39:03][0m  [36;1m[0.70ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 17:39:03][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 17:39:03][0m  [36;1m[0.31ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 17:39:03][0m  [36;1m[0.25ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 17:39:03][0m  [36;1m[0.35ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-21 17:39:06][0m  [36;1m[0.53ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 17:39:06][0m  [36;1m[0.25ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 17:39:06][0m  [36;1m[0.67ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-21 17:39:06][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-21 17:39:07][0m  [36;1m[0.54ms][0m  SELECT * FROM `tags`    
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 17:39:07][0m  [36;1m[0.25ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 17:39:07][0m  [36;1m[0.69ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:31)[0m 
[33m[2020-07-21 17:39:07][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `tags`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 17:39:08][0m  [36;1m[0.58ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 17:39:08][0m  [36;1m[0.78ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 17:39:08][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 17:39:08][0m  [36;1m[0.37ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 17:39:08][0m  [36;1m[0.30ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 17:39:08][0m  [36;1m[0.36ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-21 17:39:10][0m  [36;1m[0.57ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 17:39:10][0m  [36;1m[0.27ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 17:39:10][0m  [36;1m[0.74ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-21 17:39:10][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-21 17:39:11][0m  [36;1m[0.56ms][0m  SELECT * FROM `tags`    
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 17:39:11][0m  [36;1m[0.28ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 17:39:11][0m  [36;1m[0.74ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:31)[0m 
[33m[2020-07-21 17:39:11][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `tags`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-21 17:39:12][0m  [36;1m[0.56ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 17:39:12][0m  [36;1m[0.33ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 17:39:12][0m  [36;1m[0.68ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-21 17:39:12][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 17:39:12][0m  [36;1m[0.53ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 17:39:12][0m  [36;1m[0.69ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 17:39:12][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 17:39:12][0m  [36;1m[0.29ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 17:39:12][0m  [36;1m[0.24ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 17:39:12][0m  [36;1m[0.30ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-21 17:39:13][0m  [36;1m[0.57ms][0m  SELECT * FROM `tags`    
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 17:39:13][0m  [36;1m[0.31ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 17:39:13][0m  [36;1m[0.76ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:31)[0m 
[33m[2020-07-21 17:39:13][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `tags`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-21 17:39:14][0m  [36;1m[0.58ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 17:39:14][0m  [36;1m[0.31ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 17:39:14][0m  [36;1m[0.71ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-21 17:39:14][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 17:39:14][0m  [36;1m[0.50ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 17:39:14][0m  [36;1m[0.69ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 17:39:14][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 17:39:14][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 17:39:14][0m  [36;1m[0.28ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 17:39:14][0m  [36;1m[0.33ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 17:39:20][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-21 17:39:20][0m  [36;1m[0.23ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-21 17:39:20][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 
1

[35m(/usr/workspace/src/blog/dao/types.go:52)[0m 
[33m[2020-07-21 17:39:20][0m  [36;1m[0.46ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id WHERE (type_id = 1) ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 17:40:46][0m  [36;1m[0.50ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 17:40:46][0m  [36;1m[0.76ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 17:40:46][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 17:40:46][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 17:40:46][0m  [36;1m[0.25ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 17:40:46][0m  [36;1m[0.31ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 
2020/07/21 17:40:46 http: panic serving 42.120.73.177:27876: write tcp 172.16.13.169:80->42.120.73.177:27876: write: broken pipe
goroutine 5076 [running]:
net/http.(*conn).serve.func1(0xc0003b7720)
	/usr/local/go/src/net/http/server.go:1772 +0x139
panic(0xb50ee0, 0xc000066be0)
	/usr/local/go/src/runtime/panic.go:975 +0x3e3
github.com/gin-gonic/gin.(*Context).Render(0xc0005bc2d0, 0xc8, 0xd0e260, 0xc0000efe30)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:842 +0x173
github.com/gin-gonic/gin.(*Context).HTML(0xc0005bc2d0, 0xc8, 0xbf926d, 0x10, 0xb43d60, 0xc00069ee10)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:851 +0x99
blog/controller/page.IndexHandler(0xc0005bc2d0)
	/usr/workspace/src/blog/controller/page/pagesController.go:22 +0x570
github.com/gin-gonic/gin.(*Context).Next(0xc0005bc2d0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:161 +0x3b
github.com/gin-contrib/sessions.Sessions.func1(0xc0005bc2d0)
	/usr/workspace/pkg/mod/github.com/gin-contrib/sessions@v0.0.3/sessions.go:52 +0x16d
github.com/gin-gonic/gin.(*Context).Next(0xc0005bc2d0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:161 +0x3b
github.com/gin-gonic/gin.(*Engine).handleHTTPRequest(0xc0003b8500, 0xc0005bc2d0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/gin.go:409 +0x666
github.com/gin-gonic/gin.(*Engine).ServeHTTP(0xc0003b8500, 0xd12a40, 0xc0000b8540, 0xc00070e500)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/gin.go:367 +0x14d
net/http.serverHandler.ServeHTTP(0xc0000b8380, 0xd12a40, 0xc0000b8540, 0xc00070e500)
	/usr/local/go/src/net/http/server.go:2807 +0xa3
net/http.(*conn).serve(0xc0003b7720, 0xd15200, 0xc00005a840)
	/usr/local/go/src/net/http/server.go:1895 +0x86c
created by net/http.(*Server).Serve
	/usr/local/go/src/net/http/server.go:2933 +0x35c

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 17:40:46][0m  [36;1m[0.53ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
2020/07/21 17:40:46 http: panic serving 42.120.73.177:65277: write tcp 172.16.13.169:80->42.120.73.177:65277: write: broken pipe
goroutine 5103 [running]:
net/http.(*conn).serve.func1(0xc0003b7ea0)
	/usr/local/go/src/net/http/server.go:1772 +0x139
panic(0xb50ee0, 0xc000066f50)
	/usr/local/go/src/runtime/panic.go:975 +0x3e3
github.com/gin-gonic/gin.(*Context).Render(0xc0005bd2c0, 0x194, 0xd0e260, 0xc0005dd020)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:842 +0x173
github.com/gin-gonic/gin.(*Context).HTML(0xc0005bd2c0, 0x194, 0xbf193d, 0x8, 0xb43d60, 0xc000142c00)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:851 +0x99
blog/controller/page.NotFoundHandler(0xc0005bd2c0)
	/usr/workspace/src/blog/controller/page/404.go:12 +0x120
github.com/gin-gonic/gin.(*Context).Next(0xc0005bd2c0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:161 +0x3b
github.com/gin-contrib/sessions.Sessions.func1(0xc0005bd2c0)
	/usr/workspace/pkg/mod/github.com/gin-contrib/sessions@v0.0.3/sessions.go:52 +0x16d
github.com/gin-gonic/gin.(*Context).Next(0xc0005bd2c0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:161 +0x3b
github.com/gin-gonic/gin.serveError(0xc0005bd2c0, 0x194, 0x1248dc0, 0x12, 0x12)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/gin.go:445 +0x38
github.com/gin-gonic/gin.(*Engine).handleHTTPRequest(0xc0003b8500, 0xc0005bd2c0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/gin.go:438 +0x3d3
github.com/gin-gonic/gin.(*Engine).ServeHTTP(0xc0003b8500, 0xd12a40, 0xc0000b88c0, 0xc00078fb00)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/gin.go:367 +0x14d
net/http.serverHandler.ServeHTTP(0xc0000b8380, 0xd12a40, 0xc0000b88c0, 0xc00078fb00)
	/usr/local/go/src/net/http/server.go:2807 +0xa3
net/http.(*conn).serve(0xc0003b7ea0, 0xd15200, 0xc0006cf900)
	/usr/local/go/src/net/http/server.go:1895 +0x86c
created by net/http.(*Server).Serve
	/usr/local/go/src/net/http/server.go:2933 +0x35c

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 17:43:33][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 17:43:33][0m  [36;1m[0.81ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 17:43:33][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 17:43:33][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 17:43:33][0m  [36;1m[0.28ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 17:43:33][0m  [36;1m[0.35ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 
2020/07/21 17:43:33 http: panic serving 42.120.73.177:64325: write tcp 172.16.13.169:80->42.120.73.177:64325: write: broken pipe
goroutine 5130 [running]:
net/http.(*conn).serve.func1(0xc0003b66e0)
	/usr/local/go/src/net/http/server.go:1772 +0x139
panic(0xb50ee0, 0xc000066690)
	/usr/local/go/src/runtime/panic.go:975 +0x3e3
github.com/gin-gonic/gin.(*Context).Render(0xc0005bc2d0, 0xc8, 0xd0e260, 0xc000343110)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:842 +0x173
github.com/gin-gonic/gin.(*Context).HTML(0xc0005bc2d0, 0xc8, 0xbf926d, 0x10, 0xb43d60, 0xc00074e120)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:851 +0x99
blog/controller/page.IndexHandler(0xc0005bc2d0)
	/usr/workspace/src/blog/controller/page/pagesController.go:22 +0x570
github.com/gin-gonic/gin.(*Context).Next(0xc0005bc2d0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:161 +0x3b
github.com/gin-contrib/sessions.Sessions.func1(0xc0005bc2d0)
	/usr/workspace/pkg/mod/github.com/gin-contrib/sessions@v0.0.3/sessions.go:52 +0x16d
github.com/gin-gonic/gin.(*Context).Next(0xc0005bc2d0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:161 +0x3b
github.com/gin-gonic/gin.(*Engine).handleHTTPRequest(0xc0003b8500, 0xc0005bc2d0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/gin.go:409 +0x666
github.com/gin-gonic/gin.(*Engine).ServeHTTP(0xc0003b8500, 0xd12a40, 0xc0000b80e0, 0xc00070e000)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/gin.go:367 +0x14d
net/http.serverHandler.ServeHTTP(0xc0000b8380, 0xd12a40, 0xc0000b80e0, 0xc00070e000)
	/usr/local/go/src/net/http/server.go:2807 +0xa3
net/http.(*conn).serve(0xc0003b66e0, 0xd15200, 0xc000612000)
	/usr/local/go/src/net/http/server.go:1895 +0x86c
created by net/http.(*Server).Serve
	/usr/local/go/src/net/http/server.go:2933 +0x35c

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 17:48:36][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 17:48:36][0m  [36;1m[0.75ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 17:48:36][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 17:48:36][0m  [36;1m[0.35ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 17:48:36][0m  [36;1m[0.30ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 17:48:36][0m  [36;1m[0.34ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-21 17:48:43][0m  [36;1m[0.37ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 4)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-21 17:48:43][0m  [36;1m[0.49ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=4  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-21 17:48:43][0m  [36;1m[0.45ms][0m  UPDATE `blogs` SET `title` = '本博客开源公告', `content` = '今天本博客评论功能发布
# 自今天起，本博客基本功能已经完成
## 发布V1.0版本并开源
## 博客语言说明
#### 本博客后端是用golang 的gin框架+gorm编写
前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的
#### 博客效果参考本站
#一、博客简介
## 1.博客目录

    blog
    ├────controller
	├────└───admin
	|	|	├──adminblog.go
	|	|	├───adminController.go
	|	|	├──adminTag.go
	|	|	├──adminType.go
	|	|	└──adminUser.go
	|	└──page
	|		├──404.go
	|		├───about.go
	|		├──archives.go
	|		├──blog.go
	|		├──comment.go
	|		├──pagesController.go
	|		├──researchController.go
	|		└──tagsController.go
    ├── dao
	│	├──blogs.go
	│	├──comment.go
	│	├──sql.go
	│	├──tags.go
	│	├──types.go
	│	└──user.go
    ├── logic
    │   └── user.go
    ├── middlerware
	│	├──function.go
	│	├──getImg.go
	│	├──getTime.go
	│	├──markdown.go
	│	├──select.go
	│	└──session.go
    ├── model
	│	├──blog.go
	│	├──commnent.go
	│	├──tag.go
	│	├──type.go
	│	└──user/go
    ├── static
	│	└──静态文件（头像、图片、logo、css、js等）
    ├── templates
	│	└──html模板文件
    ├── go.mod（依赖）
    └── main.go
    

## 2.相关功能实现简介
### 1、评论及回复功能
comment的结构体属性如下
```go
package model

type Comment struct {
	Id     int //评论id
	BlogId int //博文id
	ReCommentId    int    //父评论id
	CommentName string //评论人姓名
	ReCommentName  string //父评论人姓名
	CommentEmail   string
	Img            string
	CommentContent string `gorm:"type:text" form:"CommentContent" json:"CommentContent"` //评论内容
	CommentTime    string ` json:"comment_time,omitempty"`
	Parent         *Comment
	Comments       []Comment
}
```
#### 实现方法
##### 1先通过查找父评论为-1的顶级评论
父评论Id为-1说明他不是任何评论的子评论
##### 2在html上遍历所有的顶级评论
在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论
###### （1）递归存储每个顶级评论的子评论
这里我用一个切片来储存一个顶级评论的所有子评论
```go
var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
	var comments []model.Comment
	DB.Debug().Where("re_comment_id = -1 AND blog_id = ?", id).Find(&comments)
	return &comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
	if count != 0 {
		fmt.Println("if判断1")
		var comments []model.Comment
		DB.Debug().Where("re_comment_id = ?", id).Find(&comments)
		count = len(comments)
		if count != 0 {
			fmt.Println("if判断2")
			for _, comment := range comments {
				fmt.Println("for判断1")
				Comments = append(Comments, comment)
				SelectCommentByComment(comment.Id, count)
			}
		}
	}
	fmt.Println(Comments)
	return &Comments

}
```
ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来
###### （2）出现问题的原因
因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量
###### （3）解决问题
```go
func ClearComments() bool {
	var comments []model.Comment
	Comments = comments
	return true
}

```
这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现
#### 这里我还加了一个小小的随机头像功能
```go
if  CommentName == user.Name && CommentEmail == user.UserEmail {
		fmt.Println("进入了1")
		comment.Img =user.UserImg
		//找相同评论人
	}else if CommentName == one.CommentName && CommentEmail == one.CommentEmail {
		fmt.Println("进入了2")
		comment.Img =one.Img
		//随机选头像
	}else{
		fmt.Println("进入了3")
		comment.Img =middleware.GetImg()
	}
```
##### 123分别代表三种不同的用户群体
1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
![](/static/images/%e5%a4%b4%e5%83%8f1.png)![](/static/images/%e5%a4%b4%e5%83%8f2.png)![](/static/images/%e5%a4%b4%e5%83%8f3.png)![](/static/images/%e5%a4%b4%e5%83%8f4.png)![](/static/images/%e5%a4%b4%e5%83%8f5.png)![](/static/images/%e5%a4%b4%e5%83%8f6.png)
### 2、归档功能
#### blog的结构体属性如下
```go
package model

type Blog struct {
	Id           int
	Title        string    `form:"title" json:"title"`                          //标题
	Content      string    `gorm:"type:longtext" form:"content" json:"content"` //内容
	Image        string    `gorm:"type:text" form:"image" json:"image"`         //首图
	Numb         int       `form:"numb" json:"numb"`                            //次数
	Flag         string    `form:"flag" json:"flag"`                            //原创或者转载
	Appreciation string    `form:"appreciation" json:"appreciation"`            //打赏开关
	ShareInfo    string    `form:"shareInfo" json:"shareInfo"`                  //版权开关
	Comment      string    `form:"comment" json:"comment"`                      //评论开关
	Recommend    string    `form:"recommend" json:"recommend"`                  //推荐开关
	Description  string    `gorm:"type:text" form:"description" json:"description"`
	CreatTime    string    `form:"creatTime"  json:"creat_time,omitempty"`   //创建时间
	UpdateTime   string    `form:"updateTime"  json:"update_time,omitempty"` //更新时间
	Comments     []Comment `form:"comments" json:"comments"`
	TypeId       int       `form:"typeId" json:"typeId"`
	Type         Type      `form:"type" gorm:"ForeignKey:TypeId"`
	Year         int       `form:"year" json:"year"`
	Month        int       `form:"month" json:"month"`
	Day          int       `form:"day" json:"day"`
}

```
#### 实现方法
我的思路是创建三个时间节点
year month day 
利用sql分组查询
##### Group By分组查询步骤
###### （1）先按照年份查询
###### （2）再按照年份遍历每个月份
并将所有保存在一个切片中
###### （3）按照月份遍历每个月的所有文章
保存在一个Map中，key是对应的月份，value是每个月份的所有文章
#### 自此归档功能实现


## 3.已知BUG
### 后台退出功能
后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧

开源地址
[github](https://github.com/likewl/blog "github")
[gitee](https://gitee.com/nculike/blog "gitee")', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1535821573,4166447487&fm=26&gp=0.jpg', `numb` = 43, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '本博客后端是用golang 的gin框架+gorm编写', `creat_time` = '2020-07-20 15:24:23', `update_time` = '2020-07-20 15:24:23', `type_id` = 4, `year` = 2020, `month` = 7, `day` = 20  WHERE `blogs`.`id` = 4  
[36;31m[1 rows affected or returned ][0m 
<p>今天本博客评论功能发布</p>

<h1>自今天起，本博客基本功能已经完成</h1>

<h2>发布V1.0版本并开源</h2>

<h2>博客语言说明</h2>

<h4>本博客后端是用golang 的gin框架+gorm编写</h4>

<p>前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的</p>

<h4>博客效果参考本站</h4>

<p>#一、博客简介</p>

<h2>1.博客目录</h2>

<pre><code>blog
├────controller
├────└───admin
|   |   ├──adminblog.go
|   |   ├───adminController.go
|   |   ├──adminTag.go
|   |   ├──adminType.go
|   |   └──adminUser.go
|   └──page
|       ├──404.go
|       ├───about.go
|       ├──archives.go
|       ├──blog.go
|       ├──comment.go
|       ├──pagesController.go
|       ├──researchController.go
|       └──tagsController.go
├── dao
│   ├──blogs.go
│   ├──comment.go
│   ├──sql.go
│   ├──tags.go
│   ├──types.go
│   └──user.go
├── logic
│   └── user.go
├── middlerware
│   ├──function.go
│   ├──getImg.go
│   ├──getTime.go
│   ├──markdown.go
│   ├──select.go
│   └──session.go
├── model
│   ├──blog.go
│   ├──commnent.go
│   ├──tag.go
│   ├──type.go
│   └──user/go
├── static
│   └──静态文件（头像、图片、logo、css、js等）
├── templates
│   └──html模板文件
├── go.mod（依赖）
└── main.go
</code></pre>

<h2>2.相关功能实现简介</h2>

<h3>1、评论及回复功能</h3>

<p>comment的结构体属性如下</p>

<pre><code class="language-go">package model

type Comment struct {
    Id     int //评论id
    BlogId int //博文id
    ReCommentId    int    //父评论id
    CommentName string //评论人姓名
    ReCommentName  string //父评论人姓名
    CommentEmail   string
    Img            string
    CommentContent string `gorm:&#34;type:text&#34; form:&#34;CommentContent&#34; json:&#34;CommentContent&#34;` //评论内容
    CommentTime    string ` json:&#34;comment_time,omitempty&#34;`
    Parent         *Comment
    Comments       []Comment
}
</code></pre>

<h4>实现方法</h4>

<h5>1先通过查找父评论为-1的顶级评论</h5>

<p>父评论Id为-1说明他不是任何评论的子评论</p>

<h5>2在html上遍历所有的顶级评论</h5>

<p>在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论</p>

<h6>（1）递归存储每个顶级评论的子评论</h6>

<p>这里我用一个切片来储存一个顶级评论的所有子评论</p>

<pre><code class="language-go">var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
    var comments []model.Comment
    DB.Debug().Where(&#34;re_comment_id = -1 AND blog_id = ?&#34;, id).Find(&amp;comments)
    return &amp;comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
    if count != 0 {
        fmt.Println(&#34;if判断1&#34;)
        var comments []model.Comment
        DB.Debug().Where(&#34;re_comment_id = ?&#34;, id).Find(&amp;comments)
        count = len(comments)
        if count != 0 {
            fmt.Println(&#34;if判断2&#34;)
            for _, comment := range comments {
                fmt.Println(&#34;for判断1&#34;)
                Comments = append(Comments, comment)
                SelectCommentByComment(comment.Id, count)
            }
        }
    }
    fmt.Println(Comments)
    return &amp;Comments

}
</code></pre>

<p>ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来</p>

<h6>（2）出现问题的原因</h6>

<p>因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量</p>

<h6>（3）解决问题</h6>

<pre><code class="language-go">func ClearComments() bool {
    var comments []model.Comment
    Comments = comments
    return true
}

</code></pre>

<p>这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现</p>

<h4>这里我还加了一个小小的随机头像功能</h4>

<pre><code class="language-go">if  CommentName == user.Name &amp;&amp; CommentEmail == user.UserEmail {
        fmt.Println(&#34;进入了1&#34;)
        comment.Img =user.UserImg
        //找相同评论人
    }else if CommentName == one.CommentName &amp;&amp; CommentEmail == one.CommentEmail {
        fmt.Println(&#34;进入了2&#34;)
        comment.Img =one.Img
        //随机选头像
    }else{
        fmt.Println(&#34;进入了3&#34;)
        comment.Img =middleware.GetImg()
    }
</code></pre>

<h5>123分别代表三种不同的用户群体</h5>

<p>1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
<img src="/static/images/%e5%a4%b4%e5%83%8f1.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f2.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f3.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f4.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f5.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f6.png" alt=""/></p>

<h3>2、归档功能</h3>

<h4>blog的结构体属性如下</h4>

<pre><code class="language-go">package model

type Blog struct {
    Id           int
    Title        string    `form:&#34;title&#34; json:&#34;title&#34;`                          //标题
    Content      string    `gorm:&#34;type:longtext&#34; form:&#34;content&#34; json:&#34;content&#34;` //内容
    Image        string    `gorm:&#34;type:text&#34; form:&#34;image&#34; json:&#34;image&#34;`         //首图
    Numb         int       `form:&#34;numb&#34; json:&#34;numb&#34;`                            //次数
    Flag         string    `form:&#34;flag&#34; json:&#34;flag&#34;`                            //原创或者转载
    Appreciation string    `form:&#34;appreciation&#34; json:&#34;appreciation&#34;`            //打赏开关
    ShareInfo    string    `form:&#34;shareInfo&#34; json:&#34;shareInfo&#34;`                  //版权开关
    Comment      string    `form:&#34;comment&#34; json:&#34;comment&#34;`                      //评论开关
    Recommend    string    `form:&#34;recommend&#34; json:&#34;recommend&#34;`                  //推荐开关
    Description  string    `gorm:&#34;type:text&#34; form:&#34;description&#34; json:&#34;description&#34;`
    CreatTime    string    `form:&#34;creatTime&#34;  json:&#34;creat_time,omitempty&#34;`   //创建时间
    UpdateTime   string    `form:&#34;updateTime&#34;  json:&#34;update_time,omitempty&#34;` //更新时间
    Comments     []Comment `form:&#34;comments&#34; json:&#34;comments&#34;`
    TypeId       int       `form:&#34;typeId&#34; json:&#34;typeId&#34;`
    Type         Type      `form:&#34;type&#34; gorm:&#34;ForeignKey:TypeId&#34;`
    Year         int       `form:&#34;year&#34; json:&#34;year&#34;`
    Month        int       `form:&#34;month&#34; json:&#34;month&#34;`
    Day          int       `form:&#34;day&#34; json:&#34;day&#34;`
}

</code></pre>

<h4>实现方法</h4>

<p>我的思路是创建三个时间节点
year month day
利用sql分组查询</p>

<h5>Group By分组查询步骤</h5>

<h6>（1）先按照年份查询</h6>

<h6>（2）再按照年份遍历每个月份</h6>

<p>并将所有保存在一个切片中</p>

<h6>（3）按照月份遍历每个月的所有文章</h6>

<p>保存在一个Map中，key是对应的月份，value是每个月份的所有文章</p>

<h4>自此归档功能实现</h4>

<h2>3.已知BUG</h2>

<h3>后台退出功能</h3>

<p>后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧</p>

<p>开源地址
<a href="https://github.com/likewl/blog" title="github" rel="nofollow">github</a>
<a href="https://gitee.com/nculike/blog" title="gitee" rel="nofollow">gitee</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 17:48:43][0m  [36;1m[0.35ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 17:51:59][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 17:58:48][0m  [36;1m[0.57ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 17:58:48][0m  [36;1m[0.72ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 17:58:48][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 17:58:48][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 17:58:48][0m  [36;1m[0.25ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 17:58:48][0m  [36;1m[0.35ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 17:59:46][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 17:59:46][0m  [36;1m[0.71ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 17:59:46][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 17:59:46][0m  [36;1m[0.39ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 17:59:46][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 17:59:46][0m  [36;1m[0.34ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 17:59:58][0m  [36;1m[0.52ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 17:59:58][0m  [36;1m[0.68ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 17:59:58][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 17:59:58][0m  [36;1m[0.28ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 17:59:58][0m  [36;1m[0.25ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 17:59:58][0m  [36;1m[0.33ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 18:00:21][0m  [36;1m[0.51ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-21 18:00:23][0m  [36;1m[0.48ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 18:00:23][0m  [36;1m[0.25ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 18:00:23][0m  [36;1m[0.69ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-21 18:00:23][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-21 18:00:23][0m  [36;1m[0.37ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 2)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-21 18:00:23][0m  [36;1m[0.46ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=2  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-21 18:00:23][0m  [36;1m[0.37ms][0m  UPDATE `blogs` SET `title` = '解决Linux关闭终端后运行的程序自动停止', `content` = '# 问题发现
  昨天博客发布，操作完关闭终端就睡了
  然而今天醒来突然发现终端不能访问了
  查看发现原来博客项目进程被杀死了
# 解决办法
    go build main.go
执行完后

    nohup ./main &
让程序在后台运行就可了


[========]
# ps:这个方法并不完美，因为我也是刚刚接触还不知道怎么切回来', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3696516981,3671280793&fm=26&gp=0.jpg', `numb` = 20, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '昨天博客发布，操作完关闭终端就睡了，然而今天醒来突然发现终端不能访问了，查看发现原来博客项目进程被杀死了', `creat_time` = '2020-07-19 19:05:36', `update_time` = '2020-07-19 19:05:36', `type_id` = 2, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 3  
[36;31m[1 rows affected or returned ][0m 
<h1>问题发现</h1>

<p>昨天博客发布，操作完关闭终端就睡了
  然而今天醒来突然发现终端不能访问了
  查看发现原来博客项目进程被杀死了</p>

<h1>解决办法</h1>

<pre><code>go build main.go
</code></pre>

<p>执行完后</p>

<pre><code>nohup ./main &amp;
</code></pre>

<p>让程序在后台运行就可了</p>

<p>[========]</p>

<h1>ps:这个方法并不完美，因为我也是刚刚接触还不知道怎么切回来</h1>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 18:00:23][0m  [36;1m[0.25ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 18:00:26][0m  [36;1m[0.73ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 18:00:26][0m  [36;1m[1.02ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 18:00:26][0m  [36;1m[0.25ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 18:00:26][0m  [36;1m[0.29ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 18:00:26][0m  [36;1m[0.34ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 18:00:26][0m  [36;1m[0.43ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-21 18:00:28][0m  [36;1m[0.36ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 4)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-21 18:00:28][0m  [36;1m[0.46ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=4  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-21 18:00:28][0m  [36;1m[0.43ms][0m  UPDATE `blogs` SET `title` = '本博客开源公告', `content` = '今天本博客评论功能发布
# 自今天起，本博客基本功能已经完成
## 发布V1.0版本并开源
## 博客语言说明
#### 本博客后端是用golang 的gin框架+gorm编写
前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的
#### 博客效果参考本站
#一、博客简介
## 1.博客目录

    blog
    ├────controller
	├────└───admin
	|	|	├──adminblog.go
	|	|	├───adminController.go
	|	|	├──adminTag.go
	|	|	├──adminType.go
	|	|	└──adminUser.go
	|	└──page
	|		├──404.go
	|		├───about.go
	|		├──archives.go
	|		├──blog.go
	|		├──comment.go
	|		├──pagesController.go
	|		├──researchController.go
	|		└──tagsController.go
    ├── dao
	│	├──blogs.go
	│	├──comment.go
	│	├──sql.go
	│	├──tags.go
	│	├──types.go
	│	└──user.go
    ├── logic
    │   └── user.go
    ├── middlerware
	│	├──function.go
	│	├──getImg.go
	│	├──getTime.go
	│	├──markdown.go
	│	├──select.go
	│	└──session.go
    ├── model
	│	├──blog.go
	│	├──commnent.go
	│	├──tag.go
	│	├──type.go
	│	└──user/go
    ├── static
	│	└──静态文件（头像、图片、logo、css、js等）
    ├── templates
	│	└──html模板文件
    ├── go.mod（依赖）
    └── main.go
    

## 2.相关功能实现简介
### 1、评论及回复功能
comment的结构体属性如下
```go
package model

type Comment struct {
	Id     int //评论id
	BlogId int //博文id
	ReCommentId    int    //父评论id
	CommentName string //评论人姓名
	ReCommentName  string //父评论人姓名
	CommentEmail   string
	Img            string
	CommentContent string `gorm:"type:text" form:"CommentContent" json:"CommentContent"` //评论内容
	CommentTime    string ` json:"comment_time,omitempty"`
	Parent         *Comment
	Comments       []Comment
}
```
#### 实现方法
##### 1先通过查找父评论为-1的顶级评论
父评论Id为-1说明他不是任何评论的子评论
##### 2在html上遍历所有的顶级评论
在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论
###### （1）递归存储每个顶级评论的子评论
这里我用一个切片来储存一个顶级评论的所有子评论
```go
var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
	var comments []model.Comment
	DB.Debug().Where("re_comment_id = -1 AND blog_id = ?", id).Find(&comments)
	return &comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
	if count != 0 {
		fmt.Println("if判断1")
		var comments []model.Comment
		DB.Debug().Where("re_comment_id = ?", id).Find(&comments)
		count = len(comments)
		if count != 0 {
			fmt.Println("if判断2")
			for _, comment := range comments {
				fmt.Println("for判断1")
				Comments = append(Comments, comment)
				SelectCommentByComment(comment.Id, count)
			}
		}
	}
	fmt.Println(Comments)
	return &Comments

}
```
ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来
###### （2）出现问题的原因
因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量
###### （3）解决问题
```go
func ClearComments() bool {
	var comments []model.Comment
	Comments = comments
	return true
}

```
这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现
#### 这里我还加了一个小小的随机头像功能
```go
if  CommentName == user.Name && CommentEmail == user.UserEmail {
		fmt.Println("进入了1")
		comment.Img =user.UserImg
		//找相同评论人
	}else if CommentName == one.CommentName && CommentEmail == one.CommentEmail {
		fmt.Println("进入了2")
		comment.Img =one.Img
		//随机选头像
	}else{
		fmt.Println("进入了3")
		comment.Img =middleware.GetImg()
	}
```
##### 123分别代表三种不同的用户群体
1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
![](/static/images/%e5%a4%b4%e5%83%8f1.png)![](/static/images/%e5%a4%b4%e5%83%8f2.png)![](/static/images/%e5%a4%b4%e5%83%8f3.png)![](/static/images/%e5%a4%b4%e5%83%8f4.png)![](/static/images/%e5%a4%b4%e5%83%8f5.png)![](/static/images/%e5%a4%b4%e5%83%8f6.png)
### 2、归档功能
#### blog的结构体属性如下
```go
package model

type Blog struct {
	Id           int
	Title        string    `form:"title" json:"title"`                          //标题
	Content      string    `gorm:"type:longtext" form:"content" json:"content"` //内容
	Image        string    `gorm:"type:text" form:"image" json:"image"`         //首图
	Numb         int       `form:"numb" json:"numb"`                            //次数
	Flag         string    `form:"flag" json:"flag"`                            //原创或者转载
	Appreciation string    `form:"appreciation" json:"appreciation"`            //打赏开关
	ShareInfo    string    `form:"shareInfo" json:"shareInfo"`                  //版权开关
	Comment      string    `form:"comment" json:"comment"`                      //评论开关
	Recommend    string    `form:"recommend" json:"recommend"`                  //推荐开关
	Description  string    `gorm:"type:text" form:"description" json:"description"`
	CreatTime    string    `form:"creatTime"  json:"creat_time,omitempty"`   //创建时间
	UpdateTime   string    `form:"updateTime"  json:"update_time,omitempty"` //更新时间
	Comments     []Comment `form:"comments" json:"comments"`
	TypeId       int       `form:"typeId" json:"typeId"`
	Type         Type      `form:"type" gorm:"ForeignKey:TypeId"`
	Year         int       `form:"year" json:"year"`
	Month        int       `form:"month" json:"month"`
	Day          int       `form:"day" json:"day"`
}

```
#### 实现方法
我的思路是创建三个时间节点
year month day 
利用sql分组查询
##### Group By分组查询步骤
###### （1）先按照年份查询
###### （2）再按照年份遍历每个月份
并将所有保存在一个切片中
###### （3）按照月份遍历每个月的所有文章
保存在一个Map中，key是对应的月份，value是每个月份的所有文章
#### 自此归档功能实现


## 3.已知BUG
### 后台退出功能
后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧

开源地址
[github](https://github.com/likewl/blog "github")
[gitee](https://gitee.com/nculike/blog "gitee")', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1535821573,4166447487&fm=26&gp=0.jpg', `numb` = 44, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '本博客后端是用golang 的gin框架+gorm编写', `creat_time` = '2020-07-20 15:24:23', `update_time` = '2020-07-20 15:24:23', `type_id` = 4, `year` = 2020, `month` = 7, `day` = 20  WHERE `blogs`.`id` = 4  
[36;31m[1 rows affected or returned ][0m 
<p>今天本博客评论功能发布</p>

<h1>自今天起，本博客基本功能已经完成</h1>

<h2>发布V1.0版本并开源</h2>

<h2>博客语言说明</h2>

<h4>本博客后端是用golang 的gin框架+gorm编写</h4>

<p>前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的</p>

<h4>博客效果参考本站</h4>

<p>#一、博客简介</p>

<h2>1.博客目录</h2>

<pre><code>blog
├────controller
├────└───admin
|   |   ├──adminblog.go
|   |   ├───adminController.go
|   |   ├──adminTag.go
|   |   ├──adminType.go
|   |   └──adminUser.go
|   └──page
|       ├──404.go
|       ├───about.go
|       ├──archives.go
|       ├──blog.go
|       ├──comment.go
|       ├──pagesController.go
|       ├──researchController.go
|       └──tagsController.go
├── dao
│   ├──blogs.go
│   ├──comment.go
│   ├──sql.go
│   ├──tags.go
│   ├──types.go
│   └──user.go
├── logic
│   └── user.go
├── middlerware
│   ├──function.go
│   ├──getImg.go
│   ├──getTime.go
│   ├──markdown.go
│   ├──select.go
│   └──session.go
├── model
│   ├──blog.go
│   ├──commnent.go
│   ├──tag.go
│   ├──type.go
│   └──user/go
├── static
│   └──静态文件（头像、图片、logo、css、js等）
├── templates
│   └──html模板文件
├── go.mod（依赖）
└── main.go
</code></pre>

<h2>2.相关功能实现简介</h2>

<h3>1、评论及回复功能</h3>

<p>comment的结构体属性如下</p>

<pre><code class="language-go">package model

type Comment struct {
    Id     int //评论id
    BlogId int //博文id
    ReCommentId    int    //父评论id
    CommentName string //评论人姓名
    ReCommentName  string //父评论人姓名
    CommentEmail   string
    Img            string
    CommentContent string `gorm:&#34;type:text&#34; form:&#34;CommentContent&#34; json:&#34;CommentContent&#34;` //评论内容
    CommentTime    string ` json:&#34;comment_time,omitempty&#34;`
    Parent         *Comment
    Comments       []Comment
}
</code></pre>

<h4>实现方法</h4>

<h5>1先通过查找父评论为-1的顶级评论</h5>

<p>父评论Id为-1说明他不是任何评论的子评论</p>

<h5>2在html上遍历所有的顶级评论</h5>

<p>在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论</p>

<h6>（1）递归存储每个顶级评论的子评论</h6>

<p>这里我用一个切片来储存一个顶级评论的所有子评论</p>

<pre><code class="language-go">var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
    var comments []model.Comment
    DB.Debug().Where(&#34;re_comment_id = -1 AND blog_id = ?&#34;, id).Find(&amp;comments)
    return &amp;comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
    if count != 0 {
        fmt.Println(&#34;if判断1&#34;)
        var comments []model.Comment
        DB.Debug().Where(&#34;re_comment_id = ?&#34;, id).Find(&amp;comments)
        count = len(comments)
        if count != 0 {
            fmt.Println(&#34;if判断2&#34;)
            for _, comment := range comments {
                fmt.Println(&#34;for判断1&#34;)
                Comments = append(Comments, comment)
                SelectCommentByComment(comment.Id, count)
            }
        }
    }
    fmt.Println(Comments)
    return &amp;Comments

}
</code></pre>

<p>ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来</p>

<h6>（2）出现问题的原因</h6>

<p>因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量</p>

<h6>（3）解决问题</h6>

<pre><code class="language-go">func ClearComments() bool {
    var comments []model.Comment
    Comments = comments
    return true
}

</code></pre>

<p>这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现</p>

<h4>这里我还加了一个小小的随机头像功能</h4>

<pre><code class="language-go">if  CommentName == user.Name &amp;&amp; CommentEmail == user.UserEmail {
        fmt.Println(&#34;进入了1&#34;)
        comment.Img =user.UserImg
        //找相同评论人
    }else if CommentName == one.CommentName &amp;&amp; CommentEmail == one.CommentEmail {
        fmt.Println(&#34;进入了2&#34;)
        comment.Img =one.Img
        //随机选头像
    }else{
        fmt.Println(&#34;进入了3&#34;)
        comment.Img =middleware.GetImg()
    }
</code></pre>

<h5>123分别代表三种不同的用户群体</h5>

<p>1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
<img src="/static/images/%e5%a4%b4%e5%83%8f1.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f2.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f3.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f4.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f5.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f6.png" alt=""/></p>

<h3>2、归档功能</h3>

<h4>blog的结构体属性如下</h4>

<pre><code class="language-go">package model

type Blog struct {
    Id           int
    Title        string    `form:&#34;title&#34; json:&#34;title&#34;`                          //标题
    Content      string    `gorm:&#34;type:longtext&#34; form:&#34;content&#34; json:&#34;content&#34;` //内容
    Image        string    `gorm:&#34;type:text&#34; form:&#34;image&#34; json:&#34;image&#34;`         //首图
    Numb         int       `form:&#34;numb&#34; json:&#34;numb&#34;`                            //次数
    Flag         string    `form:&#34;flag&#34; json:&#34;flag&#34;`                            //原创或者转载
    Appreciation string    `form:&#34;appreciation&#34; json:&#34;appreciation&#34;`            //打赏开关
    ShareInfo    string    `form:&#34;shareInfo&#34; json:&#34;shareInfo&#34;`                  //版权开关
    Comment      string    `form:&#34;comment&#34; json:&#34;comment&#34;`                      //评论开关
    Recommend    string    `form:&#34;recommend&#34; json:&#34;recommend&#34;`                  //推荐开关
    Description  string    `gorm:&#34;type:text&#34; form:&#34;description&#34; json:&#34;description&#34;`
    CreatTime    string    `form:&#34;creatTime&#34;  json:&#34;creat_time,omitempty&#34;`   //创建时间
    UpdateTime   string    `form:&#34;updateTime&#34;  json:&#34;update_time,omitempty&#34;` //更新时间
    Comments     []Comment `form:&#34;comments&#34; json:&#34;comments&#34;`
    TypeId       int       `form:&#34;typeId&#34; json:&#34;typeId&#34;`
    Type         Type      `form:&#34;type&#34; gorm:&#34;ForeignKey:TypeId&#34;`
    Year         int       `form:&#34;year&#34; json:&#34;year&#34;`
    Month        int       `form:&#34;month&#34; json:&#34;month&#34;`
    Day          int       `form:&#34;day&#34; json:&#34;day&#34;`
}

</code></pre>

<h4>实现方法</h4>

<p>我的思路是创建三个时间节点
year month day
利用sql分组查询</p>

<h5>Group By分组查询步骤</h5>

<h6>（1）先按照年份查询</h6>

<h6>（2）再按照年份遍历每个月份</h6>

<p>并将所有保存在一个切片中</p>

<h6>（3）按照月份遍历每个月的所有文章</h6>

<p>保存在一个Map中，key是对应的月份，value是每个月份的所有文章</p>

<h4>自此归档功能实现</h4>

<h2>3.已知BUG</h2>

<h3>后台退出功能</h3>

<p>后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧</p>

<p>开源地址
<a href="https://github.com/likewl/blog" title="github" rel="nofollow">github</a>
<a href="https://gitee.com/nculike/blog" title="gitee" rel="nofollow">gitee</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 18:00:28][0m  [36;1m[0.29ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-21 18:00:29][0m  [36;1m[0.53ms][0m  SELECT * FROM `tags`    
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 18:00:29][0m  [36;1m[0.31ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 18:00:29][0m  [36;1m[0.73ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:31)[0m 
[33m[2020-07-21 18:00:29][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `tags`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 18:00:34][0m  [36;1m[0.57ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-21 18:00:37][0m  [36;1m[0.35ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 2)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-21 18:00:37][0m  [36;1m[0.44ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=2  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-21 18:00:37][0m  [36;1m[0.35ms][0m  UPDATE `blogs` SET `title` = '解决Linux关闭终端后运行的程序自动停止', `content` = '# 问题发现
  昨天博客发布，操作完关闭终端就睡了
  然而今天醒来突然发现终端不能访问了
  查看发现原来博客项目进程被杀死了
# 解决办法
    go build main.go
执行完后

    nohup ./main &
让程序在后台运行就可了


[========]
# ps:这个方法并不完美，因为我也是刚刚接触还不知道怎么切回来', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3696516981,3671280793&fm=26&gp=0.jpg', `numb` = 21, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '昨天博客发布，操作完关闭终端就睡了，然而今天醒来突然发现终端不能访问了，查看发现原来博客项目进程被杀死了', `creat_time` = '2020-07-19 19:05:36', `update_time` = '2020-07-19 19:05:36', `type_id` = 2, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 3  
[36;31m[1 rows affected or returned ][0m 
<h1>问题发现</h1>

<p>昨天博客发布，操作完关闭终端就睡了
  然而今天醒来突然发现终端不能访问了
  查看发现原来博客项目进程被杀死了</p>

<h1>解决办法</h1>

<pre><code>go build main.go
</code></pre>

<p>执行完后</p>

<pre><code>nohup ./main &amp;
</code></pre>

<p>让程序在后台运行就可了</p>

<p>[========]</p>

<h1>ps:这个方法并不完美，因为我也是刚刚接触还不知道怎么切回来</h1>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 18:00:37][0m  [36;1m[0.27ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 18:00:39][0m  [36;1m[0.52ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-21 18:00:41][0m  [36;1m[0.56ms][0m  SELECT * FROM `tags`    
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 18:00:41][0m  [36;1m[0.29ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 18:00:41][0m  [36;1m[0.71ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:31)[0m 
[33m[2020-07-21 18:00:41][0m  [36;1m[0.22ms][0m  SELECT count(*) FROM `tags`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-21 18:00:42][0m  [36;1m[0.38ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 2)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-21 18:00:42][0m  [36;1m[0.45ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=2  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-21 18:00:42][0m  [36;1m[0.38ms][0m  UPDATE `blogs` SET `title` = '解决Linux关闭终端后运行的程序自动停止', `content` = '# 问题发现
  昨天博客发布，操作完关闭终端就睡了
  然而今天醒来突然发现终端不能访问了
  查看发现原来博客项目进程被杀死了
# 解决办法
    go build main.go
执行完后

    nohup ./main &
让程序在后台运行就可了


[========]
# ps:这个方法并不完美，因为我也是刚刚接触还不知道怎么切回来', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3696516981,3671280793&fm=26&gp=0.jpg', `numb` = 22, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '昨天博客发布，操作完关闭终端就睡了，然而今天醒来突然发现终端不能访问了，查看发现原来博客项目进程被杀死了', `creat_time` = '2020-07-19 19:05:36', `update_time` = '2020-07-19 19:05:36', `type_id` = 2, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 3  
[36;31m[1 rows affected or returned ][0m 
<h1>问题发现</h1>

<p>昨天博客发布，操作完关闭终端就睡了
  然而今天醒来突然发现终端不能访问了
  查看发现原来博客项目进程被杀死了</p>

<h1>解决办法</h1>

<pre><code>go build main.go
</code></pre>

<p>执行完后</p>

<pre><code>nohup ./main &amp;
</code></pre>

<p>让程序在后台运行就可了</p>

<p>[========]</p>

<h1>ps:这个方法并不完美，因为我也是刚刚接触还不知道怎么切回来</h1>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 18:00:42][0m  [36;1m[0.33ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-21 18:00:50][0m  [36;1m[0.58ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 18:00:50][0m  [36;1m[0.26ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 18:00:50][0m  [36;1m[0.69ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-21 18:00:50][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 18:00:54][0m  [36;1m[0.59ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 18:00:54][0m  [36;1m[0.82ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 18:00:54][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 18:00:54][0m  [36;1m[0.29ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 18:00:54][0m  [36;1m[0.25ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 18:00:54][0m  [36;1m[0.34ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-21 18:00:54][0m  [36;1m[0.57ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 18:00:54][0m  [36;1m[0.24ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 18:00:54][0m  [36;1m[0.73ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-21 18:00:54][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-21 18:00:55][0m  [36;1m[0.39ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 4)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-21 18:00:55][0m  [36;1m[0.55ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=4  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-21 18:00:55][0m  [36;1m[0.45ms][0m  UPDATE `blogs` SET `title` = '本博客开源公告', `content` = '今天本博客评论功能发布
# 自今天起，本博客基本功能已经完成
## 发布V1.0版本并开源
## 博客语言说明
#### 本博客后端是用golang 的gin框架+gorm编写
前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的
#### 博客效果参考本站
#一、博客简介
## 1.博客目录

    blog
    ├────controller
	├────└───admin
	|	|	├──adminblog.go
	|	|	├───adminController.go
	|	|	├──adminTag.go
	|	|	├──adminType.go
	|	|	└──adminUser.go
	|	└──page
	|		├──404.go
	|		├───about.go
	|		├──archives.go
	|		├──blog.go
	|		├──comment.go
	|		├──pagesController.go
	|		├──researchController.go
	|		└──tagsController.go
    ├── dao
	│	├──blogs.go
	│	├──comment.go
	│	├──sql.go
	│	├──tags.go
	│	├──types.go
	│	└──user.go
    ├── logic
    │   └── user.go
    ├── middlerware
	│	├──function.go
	│	├──getImg.go
	│	├──getTime.go
	│	├──markdown.go
	│	├──select.go
	│	└──session.go
    ├── model
	│	├──blog.go
	│	├──commnent.go
	│	├──tag.go
	│	├──type.go
	│	└──user/go
    ├── static
	│	└──静态文件（头像、图片、logo、css、js等）
    ├── templates
	│	└──html模板文件
    ├── go.mod（依赖）
    └── main.go
    

## 2.相关功能实现简介
### 1、评论及回复功能
comment的结构体属性如下
```go
package model

type Comment struct {
	Id     int //评论id
	BlogId int //博文id
	ReCommentId    int    //父评论id
	CommentName string //评论人姓名
	ReCommentName  string //父评论人姓名
	CommentEmail   string
	Img            string
	CommentContent string `gorm:"type:text" form:"CommentContent" json:"CommentContent"` //评论内容
	CommentTime    string ` json:"comment_time,omitempty"`
	Parent         *Comment
	Comments       []Comment
}
```
#### 实现方法
##### 1先通过查找父评论为-1的顶级评论
父评论Id为-1说明他不是任何评论的子评论
##### 2在html上遍历所有的顶级评论
在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论
###### （1）递归存储每个顶级评论的子评论
这里我用一个切片来储存一个顶级评论的所有子评论
```go
var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
	var comments []model.Comment
	DB.Debug().Where("re_comment_id = -1 AND blog_id = ?", id).Find(&comments)
	return &comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
	if count != 0 {
		fmt.Println("if判断1")
		var comments []model.Comment
		DB.Debug().Where("re_comment_id = ?", id).Find(&comments)
		count = len(comments)
		if count != 0 {
			fmt.Println("if判断2")
			for _, comment := range comments {
				fmt.Println("for判断1")
				Comments = append(Comments, comment)
				SelectCommentByComment(comment.Id, count)
			}
		}
	}
	fmt.Println(Comments)
	return &Comments

}
```
ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来
###### （2）出现问题的原因
因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量
###### （3）解决问题
```go
func ClearComments() bool {
	var comments []model.Comment
	Comments = comments
	return true
}

```
这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现
#### 这里我还加了一个小小的随机头像功能
```go
if  CommentName == user.Name && CommentEmail == user.UserEmail {
		fmt.Println("进入了1")
		comment.Img =user.UserImg
		//找相同评论人
	}else if CommentName == one.CommentName && CommentEmail == one.CommentEmail {
		fmt.Println("进入了2")
		comment.Img =one.Img
		//随机选头像
	}else{
		fmt.Println("进入了3")
		comment.Img =middleware.GetImg()
	}
```
##### 123分别代表三种不同的用户群体
1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
![](/static/images/%e5%a4%b4%e5%83%8f1.png)![](/static/images/%e5%a4%b4%e5%83%8f2.png)![](/static/images/%e5%a4%b4%e5%83%8f3.png)![](/static/images/%e5%a4%b4%e5%83%8f4.png)![](/static/images/%e5%a4%b4%e5%83%8f5.png)![](/static/images/%e5%a4%b4%e5%83%8f6.png)
### 2、归档功能
#### blog的结构体属性如下
```go
package model

type Blog struct {
	Id           int
	Title        string    `form:"title" json:"title"`                          //标题
	Content      string    `gorm:"type:longtext" form:"content" json:"content"` //内容
	Image        string    `gorm:"type:text" form:"image" json:"image"`         //首图
	Numb         int       `form:"numb" json:"numb"`                            //次数
	Flag         string    `form:"flag" json:"flag"`                            //原创或者转载
	Appreciation string    `form:"appreciation" json:"appreciation"`            //打赏开关
	ShareInfo    string    `form:"shareInfo" json:"shareInfo"`                  //版权开关
	Comment      string    `form:"comment" json:"comment"`                      //评论开关
	Recommend    string    `form:"recommend" json:"recommend"`                  //推荐开关
	Description  string    `gorm:"type:text" form:"description" json:"description"`
	CreatTime    string    `form:"creatTime"  json:"creat_time,omitempty"`   //创建时间
	UpdateTime   string    `form:"updateTime"  json:"update_time,omitempty"` //更新时间
	Comments     []Comment `form:"comments" json:"comments"`
	TypeId       int       `form:"typeId" json:"typeId"`
	Type         Type      `form:"type" gorm:"ForeignKey:TypeId"`
	Year         int       `form:"year" json:"year"`
	Month        int       `form:"month" json:"month"`
	Day          int       `form:"day" json:"day"`
}

```
#### 实现方法
我的思路是创建三个时间节点
year month day 
利用sql分组查询
##### Group By分组查询步骤
###### （1）先按照年份查询
###### （2）再按照年份遍历每个月份
并将所有保存在一个切片中
###### （3）按照月份遍历每个月的所有文章
保存在一个Map中，key是对应的月份，value是每个月份的所有文章
#### 自此归档功能实现


## 3.已知BUG
### 后台退出功能
后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧

开源地址
[github](https://github.com/likewl/blog "github")
[gitee](https://gitee.com/nculike/blog "gitee")', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1535821573,4166447487&fm=26&gp=0.jpg', `numb` = 45, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '本博客后端是用golang 的gin框架+gorm编写', `creat_time` = '2020-07-20 15:24:23', `update_time` = '2020-07-20 15:24:23', `type_id` = 4, `year` = 2020, `month` = 7, `day` = 20  WHERE `blogs`.`id` = 4  
[36;31m[1 rows affected or returned ][0m 
<p>今天本博客评论功能发布</p>

<h1>自今天起，本博客基本功能已经完成</h1>

<h2>发布V1.0版本并开源</h2>

<h2>博客语言说明</h2>

<h4>本博客后端是用golang 的gin框架+gorm编写</h4>

<p>前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的</p>

<h4>博客效果参考本站</h4>

<p>#一、博客简介</p>

<h2>1.博客目录</h2>

<pre><code>blog
├────controller
├────└───admin
|   |   ├──adminblog.go
|   |   ├───adminController.go
|   |   ├──adminTag.go
|   |   ├──adminType.go
|   |   └──adminUser.go
|   └──page
|       ├──404.go
|       ├───about.go
|       ├──archives.go
|       ├──blog.go
|       ├──comment.go
|       ├──pagesController.go
|       ├──researchController.go
|       └──tagsController.go
├── dao
│   ├──blogs.go
│   ├──comment.go
│   ├──sql.go
│   ├──tags.go
│   ├──types.go
│   └──user.go
├── logic
│   └── user.go
├── middlerware
│   ├──function.go
│   ├──getImg.go
│   ├──getTime.go
│   ├──markdown.go
│   ├──select.go
│   └──session.go
├── model
│   ├──blog.go
│   ├──commnent.go
│   ├──tag.go
│   ├──type.go
│   └──user/go
├── static
│   └──静态文件（头像、图片、logo、css、js等）
├── templates
│   └──html模板文件
├── go.mod（依赖）
└── main.go
</code></pre>

<h2>2.相关功能实现简介</h2>

<h3>1、评论及回复功能</h3>

<p>comment的结构体属性如下</p>

<pre><code class="language-go">package model

type Comment struct {
    Id     int //评论id
    BlogId int //博文id
    ReCommentId    int    //父评论id
    CommentName string //评论人姓名
    ReCommentName  string //父评论人姓名
    CommentEmail   string
    Img            string
    CommentContent string `gorm:&#34;type:text&#34; form:&#34;CommentContent&#34; json:&#34;CommentContent&#34;` //评论内容
    CommentTime    string ` json:&#34;comment_time,omitempty&#34;`
    Parent         *Comment
    Comments       []Comment
}
</code></pre>

<h4>实现方法</h4>

<h5>1先通过查找父评论为-1的顶级评论</h5>

<p>父评论Id为-1说明他不是任何评论的子评论</p>

<h5>2在html上遍历所有的顶级评论</h5>

<p>在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论</p>

<h6>（1）递归存储每个顶级评论的子评论</h6>

<p>这里我用一个切片来储存一个顶级评论的所有子评论</p>

<pre><code class="language-go">var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
    var comments []model.Comment
    DB.Debug().Where(&#34;re_comment_id = -1 AND blog_id = ?&#34;, id).Find(&amp;comments)
    return &amp;comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
    if count != 0 {
        fmt.Println(&#34;if判断1&#34;)
        var comments []model.Comment
        DB.Debug().Where(&#34;re_comment_id = ?&#34;, id).Find(&amp;comments)
        count = len(comments)
        if count != 0 {
            fmt.Println(&#34;if判断2&#34;)
            for _, comment := range comments {
                fmt.Println(&#34;for判断1&#34;)
                Comments = append(Comments, comment)
                SelectCommentByComment(comment.Id, count)
            }
        }
    }
    fmt.Println(Comments)
    return &amp;Comments

}
</code></pre>

<p>ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来</p>

<h6>（2）出现问题的原因</h6>

<p>因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量</p>

<h6>（3）解决问题</h6>

<pre><code class="language-go">func ClearComments() bool {
    var comments []model.Comment
    Comments = comments
    return true
}

</code></pre>

<p>这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现</p>

<h4>这里我还加了一个小小的随机头像功能</h4>

<pre><code class="language-go">if  CommentName == user.Name &amp;&amp; CommentEmail == user.UserEmail {
        fmt.Println(&#34;进入了1&#34;)
        comment.Img =user.UserImg
        //找相同评论人
    }else if CommentName == one.CommentName &amp;&amp; CommentEmail == one.CommentEmail {
        fmt.Println(&#34;进入了2&#34;)
        comment.Img =one.Img
        //随机选头像
    }else{
        fmt.Println(&#34;进入了3&#34;)
        comment.Img =middleware.GetImg()
    }
</code></pre>

<h5>123分别代表三种不同的用户群体</h5>

<p>1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
<img src="/static/images/%e5%a4%b4%e5%83%8f1.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f2.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f3.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f4.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f5.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f6.png" alt=""/></p>

<h3>2、归档功能</h3>

<h4>blog的结构体属性如下</h4>

<pre><code class="language-go">package model

type Blog struct {
    Id           int
    Title        string    `form:&#34;title&#34; json:&#34;title&#34;`                          //标题
    Content      string    `gorm:&#34;type:longtext&#34; form:&#34;content&#34; json:&#34;content&#34;` //内容
    Image        string    `gorm:&#34;type:text&#34; form:&#34;image&#34; json:&#34;image&#34;`         //首图
    Numb         int       `form:&#34;numb&#34; json:&#34;numb&#34;`                            //次数
    Flag         string    `form:&#34;flag&#34; json:&#34;flag&#34;`                            //原创或者转载
    Appreciation string    `form:&#34;appreciation&#34; json:&#34;appreciation&#34;`            //打赏开关
    ShareInfo    string    `form:&#34;shareInfo&#34; json:&#34;shareInfo&#34;`                  //版权开关
    Comment      string    `form:&#34;comment&#34; json:&#34;comment&#34;`                      //评论开关
    Recommend    string    `form:&#34;recommend&#34; json:&#34;recommend&#34;`                  //推荐开关
    Description  string    `gorm:&#34;type:text&#34; form:&#34;description&#34; json:&#34;description&#34;`
    CreatTime    string    `form:&#34;creatTime&#34;  json:&#34;creat_time,omitempty&#34;`   //创建时间
    UpdateTime   string    `form:&#34;updateTime&#34;  json:&#34;update_time,omitempty&#34;` //更新时间
    Comments     []Comment `form:&#34;comments&#34; json:&#34;comments&#34;`
    TypeId       int       `form:&#34;typeId&#34; json:&#34;typeId&#34;`
    Type         Type      `form:&#34;type&#34; gorm:&#34;ForeignKey:TypeId&#34;`
    Year         int       `form:&#34;year&#34; json:&#34;year&#34;`
    Month        int       `form:&#34;month&#34; json:&#34;month&#34;`
    Day          int       `form:&#34;day&#34; json:&#34;day&#34;`
}

</code></pre>

<h4>实现方法</h4>

<p>我的思路是创建三个时间节点
year month day
利用sql分组查询</p>

<h5>Group By分组查询步骤</h5>

<h6>（1）先按照年份查询</h6>

<h6>（2）再按照年份遍历每个月份</h6>

<p>并将所有保存在一个切片中</p>

<h6>（3）按照月份遍历每个月的所有文章</h6>

<p>保存在一个Map中，key是对应的月份，value是每个月份的所有文章</p>

<h4>自此归档功能实现</h4>

<h2>3.已知BUG</h2>

<h3>后台退出功能</h3>

<p>后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧</p>

<p>开源地址
<a href="https://github.com/likewl/blog" title="github" rel="nofollow">github</a>
<a href="https://gitee.com/nculike/blog" title="gitee" rel="nofollow">gitee</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 18:00:55][0m  [36;1m[0.33ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-21 18:00:59][0m  [36;1m[0.40ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 4)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-21 18:00:59][0m  [36;1m[0.51ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=4  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-21 18:00:59][0m  [36;1m[0.47ms][0m  UPDATE `blogs` SET `title` = '本博客开源公告', `content` = '今天本博客评论功能发布
# 自今天起，本博客基本功能已经完成
## 发布V1.0版本并开源
## 博客语言说明
#### 本博客后端是用golang 的gin框架+gorm编写
前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的
#### 博客效果参考本站
#一、博客简介
## 1.博客目录

    blog
    ├────controller
	├────└───admin
	|	|	├──adminblog.go
	|	|	├───adminController.go
	|	|	├──adminTag.go
	|	|	├──adminType.go
	|	|	└──adminUser.go
	|	└──page
	|		├──404.go
	|		├───about.go
	|		├──archives.go
	|		├──blog.go
	|		├──comment.go
	|		├──pagesController.go
	|		├──researchController.go
	|		└──tagsController.go
    ├── dao
	│	├──blogs.go
	│	├──comment.go
	│	├──sql.go
	│	├──tags.go
	│	├──types.go
	│	└──user.go
    ├── logic
    │   └── user.go
    ├── middlerware
	│	├──function.go
	│	├──getImg.go
	│	├──getTime.go
	│	├──markdown.go
	│	├──select.go
	│	└──session.go
    ├── model
	│	├──blog.go
	│	├──commnent.go
	│	├──tag.go
	│	├──type.go
	│	└──user/go
    ├── static
	│	└──静态文件（头像、图片、logo、css、js等）
    ├── templates
	│	└──html模板文件
    ├── go.mod（依赖）
    └── main.go
    

## 2.相关功能实现简介
### 1、评论及回复功能
comment的结构体属性如下
```go
package model

type Comment struct {
	Id     int //评论id
	BlogId int //博文id
	ReCommentId    int    //父评论id
	CommentName string //评论人姓名
	ReCommentName  string //父评论人姓名
	CommentEmail   string
	Img            string
	CommentContent string `gorm:"type:text" form:"CommentContent" json:"CommentContent"` //评论内容
	CommentTime    string ` json:"comment_time,omitempty"`
	Parent         *Comment
	Comments       []Comment
}
```
#### 实现方法
##### 1先通过查找父评论为-1的顶级评论
父评论Id为-1说明他不是任何评论的子评论
##### 2在html上遍历所有的顶级评论
在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论
###### （1）递归存储每个顶级评论的子评论
这里我用一个切片来储存一个顶级评论的所有子评论
```go
var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
	var comments []model.Comment
	DB.Debug().Where("re_comment_id = -1 AND blog_id = ?", id).Find(&comments)
	return &comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
	if count != 0 {
		fmt.Println("if判断1")
		var comments []model.Comment
		DB.Debug().Where("re_comment_id = ?", id).Find(&comments)
		count = len(comments)
		if count != 0 {
			fmt.Println("if判断2")
			for _, comment := range comments {
				fmt.Println("for判断1")
				Comments = append(Comments, comment)
				SelectCommentByComment(comment.Id, count)
			}
		}
	}
	fmt.Println(Comments)
	return &Comments

}
```
ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来
###### （2）出现问题的原因
因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量
###### （3）解决问题
```go
func ClearComments() bool {
	var comments []model.Comment
	Comments = comments
	return true
}

```
这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现
#### 这里我还加了一个小小的随机头像功能
```go
if  CommentName == user.Name && CommentEmail == user.UserEmail {
		fmt.Println("进入了1")
		comment.Img =user.UserImg
		//找相同评论人
	}else if CommentName == one.CommentName && CommentEmail == one.CommentEmail {
		fmt.Println("进入了2")
		comment.Img =one.Img
		//随机选头像
	}else{
		fmt.Println("进入了3")
		comment.Img =middleware.GetImg()
	}
```
##### 123分别代表三种不同的用户群体
1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
![](/static/images/%e5%a4%b4%e5%83%8f1.png)![](/static/images/%e5%a4%b4%e5%83%8f2.png)![](/static/images/%e5%a4%b4%e5%83%8f3.png)![](/static/images/%e5%a4%b4%e5%83%8f4.png)![](/static/images/%e5%a4%b4%e5%83%8f5.png)![](/static/images/%e5%a4%b4%e5%83%8f6.png)
### 2、归档功能
#### blog的结构体属性如下
```go
package model

type Blog struct {
	Id           int
	Title        string    `form:"title" json:"title"`                          //标题
	Content      string    `gorm:"type:longtext" form:"content" json:"content"` //内容
	Image        string    `gorm:"type:text" form:"image" json:"image"`         //首图
	Numb         int       `form:"numb" json:"numb"`                            //次数
	Flag         string    `form:"flag" json:"flag"`                            //原创或者转载
	Appreciation string    `form:"appreciation" json:"appreciation"`            //打赏开关
	ShareInfo    string    `form:"shareInfo" json:"shareInfo"`                  //版权开关
	Comment      string    `form:"comment" json:"comment"`                      //评论开关
	Recommend    string    `form:"recommend" json:"recommend"`                  //推荐开关
	Description  string    `gorm:"type:text" form:"description" json:"description"`
	CreatTime    string    `form:"creatTime"  json:"creat_time,omitempty"`   //创建时间
	UpdateTime   string    `form:"updateTime"  json:"update_time,omitempty"` //更新时间
	Comments     []Comment `form:"comments" json:"comments"`
	TypeId       int       `form:"typeId" json:"typeId"`
	Type         Type      `form:"type" gorm:"ForeignKey:TypeId"`
	Year         int       `form:"year" json:"year"`
	Month        int       `form:"month" json:"month"`
	Day          int       `form:"day" json:"day"`
}

```
#### 实现方法
我的思路是创建三个时间节点
year month day 
利用sql分组查询
##### Group By分组查询步骤
###### （1）先按照年份查询
###### （2）再按照年份遍历每个月份
并将所有保存在一个切片中
###### （3）按照月份遍历每个月的所有文章
保存在一个Map中，key是对应的月份，value是每个月份的所有文章
#### 自此归档功能实现


## 3.已知BUG
### 后台退出功能
后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧

开源地址
[github](https://github.com/likewl/blog "github")
[gitee](https://gitee.com/nculike/blog "gitee")', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1535821573,4166447487&fm=26&gp=0.jpg', `numb` = 46, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '本博客后端是用golang 的gin框架+gorm编写', `creat_time` = '2020-07-20 15:24:23', `update_time` = '2020-07-20 15:24:23', `type_id` = 4, `year` = 2020, `month` = 7, `day` = 20  WHERE `blogs`.`id` = 4  
[36;31m[1 rows affected or returned ][0m 
<p>今天本博客评论功能发布</p>

<h1>自今天起，本博客基本功能已经完成</h1>

<h2>发布V1.0版本并开源</h2>

<h2>博客语言说明</h2>

<h4>本博客后端是用golang 的gin框架+gorm编写</h4>

<p>前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的</p>

<h4>博客效果参考本站</h4>

<p>#一、博客简介</p>

<h2>1.博客目录</h2>

<pre><code>blog
├────controller
├────└───admin
|   |   ├──adminblog.go
|   |   ├───adminController.go
|   |   ├──adminTag.go
|   |   ├──adminType.go
|   |   └──adminUser.go
|   └──page
|       ├──404.go
|       ├───about.go
|       ├──archives.go
|       ├──blog.go
|       ├──comment.go
|       ├──pagesController.go
|       ├──researchController.go
|       └──tagsController.go
├── dao
│   ├──blogs.go
│   ├──comment.go
│   ├──sql.go
│   ├──tags.go
│   ├──types.go
│   └──user.go
├── logic
│   └── user.go
├── middlerware
│   ├──function.go
│   ├──getImg.go
│   ├──getTime.go
│   ├──markdown.go
│   ├──select.go
│   └──session.go
├── model
│   ├──blog.go
│   ├──commnent.go
│   ├──tag.go
│   ├──type.go
│   └──user/go
├── static
│   └──静态文件（头像、图片、logo、css、js等）
├── templates
│   └──html模板文件
├── go.mod（依赖）
└── main.go
</code></pre>

<h2>2.相关功能实现简介</h2>

<h3>1、评论及回复功能</h3>

<p>comment的结构体属性如下</p>

<pre><code class="language-go">package model

type Comment struct {
    Id     int //评论id
    BlogId int //博文id
    ReCommentId    int    //父评论id
    CommentName string //评论人姓名
    ReCommentName  string //父评论人姓名
    CommentEmail   string
    Img            string
    CommentContent string `gorm:&#34;type:text&#34; form:&#34;CommentContent&#34; json:&#34;CommentContent&#34;` //评论内容
    CommentTime    string ` json:&#34;comment_time,omitempty&#34;`
    Parent         *Comment
    Comments       []Comment
}
</code></pre>

<h4>实现方法</h4>

<h5>1先通过查找父评论为-1的顶级评论</h5>

<p>父评论Id为-1说明他不是任何评论的子评论</p>

<h5>2在html上遍历所有的顶级评论</h5>

<p>在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论</p>

<h6>（1）递归存储每个顶级评论的子评论</h6>

<p>这里我用一个切片来储存一个顶级评论的所有子评论</p>

<pre><code class="language-go">var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
    var comments []model.Comment
    DB.Debug().Where(&#34;re_comment_id = -1 AND blog_id = ?&#34;, id).Find(&amp;comments)
    return &amp;comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
    if count != 0 {
        fmt.Println(&#34;if判断1&#34;)
        var comments []model.Comment
        DB.Debug().Where(&#34;re_comment_id = ?&#34;, id).Find(&amp;comments)
        count = len(comments)
        if count != 0 {
            fmt.Println(&#34;if判断2&#34;)
            for _, comment := range comments {
                fmt.Println(&#34;for判断1&#34;)
                Comments = append(Comments, comment)
                SelectCommentByComment(comment.Id, count)
            }
        }
    }
    fmt.Println(Comments)
    return &amp;Comments

}
</code></pre>

<p>ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来</p>

<h6>（2）出现问题的原因</h6>

<p>因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量</p>

<h6>（3）解决问题</h6>

<pre><code class="language-go">func ClearComments() bool {
    var comments []model.Comment
    Comments = comments
    return true
}

</code></pre>

<p>这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现</p>

<h4>这里我还加了一个小小的随机头像功能</h4>

<pre><code class="language-go">if  CommentName == user.Name &amp;&amp; CommentEmail == user.UserEmail {
        fmt.Println(&#34;进入了1&#34;)
        comment.Img =user.UserImg
        //找相同评论人
    }else if CommentName == one.CommentName &amp;&amp; CommentEmail == one.CommentEmail {
        fmt.Println(&#34;进入了2&#34;)
        comment.Img =one.Img
        //随机选头像
    }else{
        fmt.Println(&#34;进入了3&#34;)
        comment.Img =middleware.GetImg()
    }
</code></pre>

<h5>123分别代表三种不同的用户群体</h5>

<p>1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
<img src="/static/images/%e5%a4%b4%e5%83%8f1.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f2.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f3.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f4.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f5.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f6.png" alt=""/></p>

<h3>2、归档功能</h3>

<h4>blog的结构体属性如下</h4>

<pre><code class="language-go">package model

type Blog struct {
    Id           int
    Title        string    `form:&#34;title&#34; json:&#34;title&#34;`                          //标题
    Content      string    `gorm:&#34;type:longtext&#34; form:&#34;content&#34; json:&#34;content&#34;` //内容
    Image        string    `gorm:&#34;type:text&#34; form:&#34;image&#34; json:&#34;image&#34;`         //首图
    Numb         int       `form:&#34;numb&#34; json:&#34;numb&#34;`                            //次数
    Flag         string    `form:&#34;flag&#34; json:&#34;flag&#34;`                            //原创或者转载
    Appreciation string    `form:&#34;appreciation&#34; json:&#34;appreciation&#34;`            //打赏开关
    ShareInfo    string    `form:&#34;shareInfo&#34; json:&#34;shareInfo&#34;`                  //版权开关
    Comment      string    `form:&#34;comment&#34; json:&#34;comment&#34;`                      //评论开关
    Recommend    string    `form:&#34;recommend&#34; json:&#34;recommend&#34;`                  //推荐开关
    Description  string    `gorm:&#34;type:text&#34; form:&#34;description&#34; json:&#34;description&#34;`
    CreatTime    string    `form:&#34;creatTime&#34;  json:&#34;creat_time,omitempty&#34;`   //创建时间
    UpdateTime   string    `form:&#34;updateTime&#34;  json:&#34;update_time,omitempty&#34;` //更新时间
    Comments     []Comment `form:&#34;comments&#34; json:&#34;comments&#34;`
    TypeId       int       `form:&#34;typeId&#34; json:&#34;typeId&#34;`
    Type         Type      `form:&#34;type&#34; gorm:&#34;ForeignKey:TypeId&#34;`
    Year         int       `form:&#34;year&#34; json:&#34;year&#34;`
    Month        int       `form:&#34;month&#34; json:&#34;month&#34;`
    Day          int       `form:&#34;day&#34; json:&#34;day&#34;`
}

</code></pre>

<h4>实现方法</h4>

<p>我的思路是创建三个时间节点
year month day
利用sql分组查询</p>

<h5>Group By分组查询步骤</h5>

<h6>（1）先按照年份查询</h6>

<h6>（2）再按照年份遍历每个月份</h6>

<p>并将所有保存在一个切片中</p>

<h6>（3）按照月份遍历每个月的所有文章</h6>

<p>保存在一个Map中，key是对应的月份，value是每个月份的所有文章</p>

<h4>自此归档功能实现</h4>

<h2>3.已知BUG</h2>

<h3>后台退出功能</h3>

<p>后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧</p>

<p>开源地址
<a href="https://github.com/likewl/blog" title="github" rel="nofollow">github</a>
<a href="https://gitee.com/nculike/blog" title="gitee" rel="nofollow">gitee</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 18:00:59][0m  [36;1m[2.21ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 18:00:59][0m  [36;1m[0.59ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 18:00:59][0m  [36;1m[0.69ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 18:00:59][0m  [36;1m[0.22ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 18:00:59][0m  [36;1m[0.31ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 18:00:59][0m  [36;1m[0.25ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 18:00:59][0m  [36;1m[0.35ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 18:01:43][0m  [36;1m[0.53ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-21 18:01:43][0m  [36;1m[0.27ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-21 18:01:43][0m  [36;1m[0.18ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/types.go:52)[0m 
[33m[2020-07-21 18:01:43][0m  [36;1m[0.46ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id WHERE (type_id = 4) ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 18:02:14][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-21 18:02:14][0m  [36;1m[0.25ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-21 18:02:14][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/types.go:52)[0m 
[33m[2020-07-21 18:02:14][0m  [36;1m[0.50ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id WHERE (type_id = 4) ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 18:02:19][0m  [36;1m[0.53ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-21 18:02:19][0m  [36;1m[0.23ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-21 18:02:19][0m  [36;1m[0.18ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/types.go:52)[0m 
[33m[2020-07-21 18:02:19][0m  [36;1m[0.46ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id WHERE (type_id = 4) ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 18:10:08][0m  [36;1m[0.52ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 18:10:08][0m  [36;1m[0.67ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 18:10:08][0m  [36;1m[0.18ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 18:10:08][0m  [36;1m[0.31ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 18:10:08][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 18:10:08][0m  [36;1m[0.31ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 18:10:17][0m  [36;1m[0.52ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 18:10:17][0m  [36;1m[0.73ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 18:10:17][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 18:10:17][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 18:10:17][0m  [36;1m[0.29ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 18:10:17][0m  [36;1m[0.34ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 18:10:58][0m  [36;1m[0.62ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 18:10:58][0m  [36;1m[0.77ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 18:10:58][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 18:10:58][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 18:10:58][0m  [36;1m[0.27ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 18:10:58][0m  [36;1m[0.35ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-21 18:11:14][0m  [36;1m[0.39ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 4)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-21 18:11:14][0m  [36;1m[0.42ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=4  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-21 18:11:14][0m  [36;1m[0.45ms][0m  UPDATE `blogs` SET `title` = '本博客开源公告', `content` = '今天本博客评论功能发布
# 自今天起，本博客基本功能已经完成
## 发布V1.0版本并开源
## 博客语言说明
#### 本博客后端是用golang 的gin框架+gorm编写
前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的
#### 博客效果参考本站
#一、博客简介
## 1.博客目录

    blog
    ├────controller
	├────└───admin
	|	|	├──adminblog.go
	|	|	├───adminController.go
	|	|	├──adminTag.go
	|	|	├──adminType.go
	|	|	└──adminUser.go
	|	└──page
	|		├──404.go
	|		├───about.go
	|		├──archives.go
	|		├──blog.go
	|		├──comment.go
	|		├──pagesController.go
	|		├──researchController.go
	|		└──tagsController.go
    ├── dao
	│	├──blogs.go
	│	├──comment.go
	│	├──sql.go
	│	├──tags.go
	│	├──types.go
	│	└──user.go
    ├── logic
    │   └── user.go
    ├── middlerware
	│	├──function.go
	│	├──getImg.go
	│	├──getTime.go
	│	├──markdown.go
	│	├──select.go
	│	└──session.go
    ├── model
	│	├──blog.go
	│	├──commnent.go
	│	├──tag.go
	│	├──type.go
	│	└──user/go
    ├── static
	│	└──静态文件（头像、图片、logo、css、js等）
    ├── templates
	│	└──html模板文件
    ├── go.mod（依赖）
    └── main.go
    

## 2.相关功能实现简介
### 1、评论及回复功能
comment的结构体属性如下
```go
package model

type Comment struct {
	Id     int //评论id
	BlogId int //博文id
	ReCommentId    int    //父评论id
	CommentName string //评论人姓名
	ReCommentName  string //父评论人姓名
	CommentEmail   string
	Img            string
	CommentContent string `gorm:"type:text" form:"CommentContent" json:"CommentContent"` //评论内容
	CommentTime    string ` json:"comment_time,omitempty"`
	Parent         *Comment
	Comments       []Comment
}
```
#### 实现方法
##### 1先通过查找父评论为-1的顶级评论
父评论Id为-1说明他不是任何评论的子评论
##### 2在html上遍历所有的顶级评论
在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论
###### （1）递归存储每个顶级评论的子评论
这里我用一个切片来储存一个顶级评论的所有子评论
```go
var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
	var comments []model.Comment
	DB.Debug().Where("re_comment_id = -1 AND blog_id = ?", id).Find(&comments)
	return &comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
	if count != 0 {
		fmt.Println("if判断1")
		var comments []model.Comment
		DB.Debug().Where("re_comment_id = ?", id).Find(&comments)
		count = len(comments)
		if count != 0 {
			fmt.Println("if判断2")
			for _, comment := range comments {
				fmt.Println("for判断1")
				Comments = append(Comments, comment)
				SelectCommentByComment(comment.Id, count)
			}
		}
	}
	fmt.Println(Comments)
	return &Comments

}
```
ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来
###### （2）出现问题的原因
因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量
###### （3）解决问题
```go
func ClearComments() bool {
	var comments []model.Comment
	Comments = comments
	return true
}

```
这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现
#### 这里我还加了一个小小的随机头像功能
```go
if  CommentName == user.Name && CommentEmail == user.UserEmail {
		fmt.Println("进入了1")
		comment.Img =user.UserImg
		//找相同评论人
	}else if CommentName == one.CommentName && CommentEmail == one.CommentEmail {
		fmt.Println("进入了2")
		comment.Img =one.Img
		//随机选头像
	}else{
		fmt.Println("进入了3")
		comment.Img =middleware.GetImg()
	}
```
##### 123分别代表三种不同的用户群体
1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
![](/static/images/%e5%a4%b4%e5%83%8f1.png)![](/static/images/%e5%a4%b4%e5%83%8f2.png)![](/static/images/%e5%a4%b4%e5%83%8f3.png)![](/static/images/%e5%a4%b4%e5%83%8f4.png)![](/static/images/%e5%a4%b4%e5%83%8f5.png)![](/static/images/%e5%a4%b4%e5%83%8f6.png)
### 2、归档功能
#### blog的结构体属性如下
```go
package model

type Blog struct {
	Id           int
	Title        string    `form:"title" json:"title"`                          //标题
	Content      string    `gorm:"type:longtext" form:"content" json:"content"` //内容
	Image        string    `gorm:"type:text" form:"image" json:"image"`         //首图
	Numb         int       `form:"numb" json:"numb"`                            //次数
	Flag         string    `form:"flag" json:"flag"`                            //原创或者转载
	Appreciation string    `form:"appreciation" json:"appreciation"`            //打赏开关
	ShareInfo    string    `form:"shareInfo" json:"shareInfo"`                  //版权开关
	Comment      string    `form:"comment" json:"comment"`                      //评论开关
	Recommend    string    `form:"recommend" json:"recommend"`                  //推荐开关
	Description  string    `gorm:"type:text" form:"description" json:"description"`
	CreatTime    string    `form:"creatTime"  json:"creat_time,omitempty"`   //创建时间
	UpdateTime   string    `form:"updateTime"  json:"update_time,omitempty"` //更新时间
	Comments     []Comment `form:"comments" json:"comments"`
	TypeId       int       `form:"typeId" json:"typeId"`
	Type         Type      `form:"type" gorm:"ForeignKey:TypeId"`
	Year         int       `form:"year" json:"year"`
	Month        int       `form:"month" json:"month"`
	Day          int       `form:"day" json:"day"`
}

```
#### 实现方法
我的思路是创建三个时间节点
year month day 
利用sql分组查询
##### Group By分组查询步骤
###### （1）先按照年份查询
###### （2）再按照年份遍历每个月份
并将所有保存在一个切片中
###### （3）按照月份遍历每个月的所有文章
保存在一个Map中，key是对应的月份，value是每个月份的所有文章
#### 自此归档功能实现


## 3.已知BUG
### 后台退出功能
后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧

开源地址
[github](https://github.com/likewl/blog "github")
[gitee](https://gitee.com/nculike/blog "gitee")', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1535821573,4166447487&fm=26&gp=0.jpg', `numb` = 47, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '本博客后端是用golang 的gin框架+gorm编写', `creat_time` = '2020-07-20 15:24:23', `update_time` = '2020-07-20 15:24:23', `type_id` = 4, `year` = 2020, `month` = 7, `day` = 20  WHERE `blogs`.`id` = 4  
[36;31m[1 rows affected or returned ][0m 
<p>今天本博客评论功能发布</p>

<h1>自今天起，本博客基本功能已经完成</h1>

<h2>发布V1.0版本并开源</h2>

<h2>博客语言说明</h2>

<h4>本博客后端是用golang 的gin框架+gorm编写</h4>

<p>前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的</p>

<h4>博客效果参考本站</h4>

<p>#一、博客简介</p>

<h2>1.博客目录</h2>

<pre><code>blog
├────controller
├────└───admin
|   |   ├──adminblog.go
|   |   ├───adminController.go
|   |   ├──adminTag.go
|   |   ├──adminType.go
|   |   └──adminUser.go
|   └──page
|       ├──404.go
|       ├───about.go
|       ├──archives.go
|       ├──blog.go
|       ├──comment.go
|       ├──pagesController.go
|       ├──researchController.go
|       └──tagsController.go
├── dao
│   ├──blogs.go
│   ├──comment.go
│   ├──sql.go
│   ├──tags.go
│   ├──types.go
│   └──user.go
├── logic
│   └── user.go
├── middlerware
│   ├──function.go
│   ├──getImg.go
│   ├──getTime.go
│   ├──markdown.go
│   ├──select.go
│   └──session.go
├── model
│   ├──blog.go
│   ├──commnent.go
│   ├──tag.go
│   ├──type.go
│   └──user/go
├── static
│   └──静态文件（头像、图片、logo、css、js等）
├── templates
│   └──html模板文件
├── go.mod（依赖）
└── main.go
</code></pre>

<h2>2.相关功能实现简介</h2>

<h3>1、评论及回复功能</h3>

<p>comment的结构体属性如下</p>

<pre><code class="language-go">package model

type Comment struct {
    Id     int //评论id
    BlogId int //博文id
    ReCommentId    int    //父评论id
    CommentName string //评论人姓名
    ReCommentName  string //父评论人姓名
    CommentEmail   string
    Img            string
    CommentContent string `gorm:&#34;type:text&#34; form:&#34;CommentContent&#34; json:&#34;CommentContent&#34;` //评论内容
    CommentTime    string ` json:&#34;comment_time,omitempty&#34;`
    Parent         *Comment
    Comments       []Comment
}
</code></pre>

<h4>实现方法</h4>

<h5>1先通过查找父评论为-1的顶级评论</h5>

<p>父评论Id为-1说明他不是任何评论的子评论</p>

<h5>2在html上遍历所有的顶级评论</h5>

<p>在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论</p>

<h6>（1）递归存储每个顶级评论的子评论</h6>

<p>这里我用一个切片来储存一个顶级评论的所有子评论</p>

<pre><code class="language-go">var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
    var comments []model.Comment
    DB.Debug().Where(&#34;re_comment_id = -1 AND blog_id = ?&#34;, id).Find(&amp;comments)
    return &amp;comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
    if count != 0 {
        fmt.Println(&#34;if判断1&#34;)
        var comments []model.Comment
        DB.Debug().Where(&#34;re_comment_id = ?&#34;, id).Find(&amp;comments)
        count = len(comments)
        if count != 0 {
            fmt.Println(&#34;if判断2&#34;)
            for _, comment := range comments {
                fmt.Println(&#34;for判断1&#34;)
                Comments = append(Comments, comment)
                SelectCommentByComment(comment.Id, count)
            }
        }
    }
    fmt.Println(Comments)
    return &amp;Comments

}
</code></pre>

<p>ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来</p>

<h6>（2）出现问题的原因</h6>

<p>因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量</p>

<h6>（3）解决问题</h6>

<pre><code class="language-go">func ClearComments() bool {
    var comments []model.Comment
    Comments = comments
    return true
}

</code></pre>

<p>这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现</p>

<h4>这里我还加了一个小小的随机头像功能</h4>

<pre><code class="language-go">if  CommentName == user.Name &amp;&amp; CommentEmail == user.UserEmail {
        fmt.Println(&#34;进入了1&#34;)
        comment.Img =user.UserImg
        //找相同评论人
    }else if CommentName == one.CommentName &amp;&amp; CommentEmail == one.CommentEmail {
        fmt.Println(&#34;进入了2&#34;)
        comment.Img =one.Img
        //随机选头像
    }else{
        fmt.Println(&#34;进入了3&#34;)
        comment.Img =middleware.GetImg()
    }
</code></pre>

<h5>123分别代表三种不同的用户群体</h5>

<p>1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
<img src="/static/images/%e5%a4%b4%e5%83%8f1.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f2.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f3.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f4.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f5.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f6.png" alt=""/></p>

<h3>2、归档功能</h3>

<h4>blog的结构体属性如下</h4>

<pre><code class="language-go">package model

type Blog struct {
    Id           int
    Title        string    `form:&#34;title&#34; json:&#34;title&#34;`                          //标题
    Content      string    `gorm:&#34;type:longtext&#34; form:&#34;content&#34; json:&#34;content&#34;` //内容
    Image        string    `gorm:&#34;type:text&#34; form:&#34;image&#34; json:&#34;image&#34;`         //首图
    Numb         int       `form:&#34;numb&#34; json:&#34;numb&#34;`                            //次数
    Flag         string    `form:&#34;flag&#34; json:&#34;flag&#34;`                            //原创或者转载
    Appreciation string    `form:&#34;appreciation&#34; json:&#34;appreciation&#34;`            //打赏开关
    ShareInfo    string    `form:&#34;shareInfo&#34; json:&#34;shareInfo&#34;`                  //版权开关
    Comment      string    `form:&#34;comment&#34; json:&#34;comment&#34;`                      //评论开关
    Recommend    string    `form:&#34;recommend&#34; json:&#34;recommend&#34;`                  //推荐开关
    Description  string    `gorm:&#34;type:text&#34; form:&#34;description&#34; json:&#34;description&#34;`
    CreatTime    string    `form:&#34;creatTime&#34;  json:&#34;creat_time,omitempty&#34;`   //创建时间
    UpdateTime   string    `form:&#34;updateTime&#34;  json:&#34;update_time,omitempty&#34;` //更新时间
    Comments     []Comment `form:&#34;comments&#34; json:&#34;comments&#34;`
    TypeId       int       `form:&#34;typeId&#34; json:&#34;typeId&#34;`
    Type         Type      `form:&#34;type&#34; gorm:&#34;ForeignKey:TypeId&#34;`
    Year         int       `form:&#34;year&#34; json:&#34;year&#34;`
    Month        int       `form:&#34;month&#34; json:&#34;month&#34;`
    Day          int       `form:&#34;day&#34; json:&#34;day&#34;`
}

</code></pre>

<h4>实现方法</h4>

<p>我的思路是创建三个时间节点
year month day
利用sql分组查询</p>

<h5>Group By分组查询步骤</h5>

<h6>（1）先按照年份查询</h6>

<h6>（2）再按照年份遍历每个月份</h6>

<p>并将所有保存在一个切片中</p>

<h6>（3）按照月份遍历每个月的所有文章</h6>

<p>保存在一个Map中，key是对应的月份，value是每个月份的所有文章</p>

<h4>自此归档功能实现</h4>

<h2>3.已知BUG</h2>

<h3>后台退出功能</h3>

<p>后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧</p>

<p>开源地址
<a href="https://github.com/likewl/blog" title="github" rel="nofollow">github</a>
<a href="https://gitee.com/nculike/blog" title="gitee" rel="nofollow">gitee</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 18:11:14][0m  [36;1m[0.27ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-21 18:11:18][0m  [36;1m[0.46ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 4)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-21 18:11:18][0m  [36;1m[0.57ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=4  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-21 18:11:18][0m  [36;1m[0.53ms][0m  UPDATE `blogs` SET `title` = '本博客开源公告', `content` = '今天本博客评论功能发布
# 自今天起，本博客基本功能已经完成
## 发布V1.0版本并开源
## 博客语言说明
#### 本博客后端是用golang 的gin框架+gorm编写
前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的
#### 博客效果参考本站
#一、博客简介
## 1.博客目录

    blog
    ├────controller
	├────└───admin
	|	|	├──adminblog.go
	|	|	├───adminController.go
	|	|	├──adminTag.go
	|	|	├──adminType.go
	|	|	└──adminUser.go
	|	└──page
	|		├──404.go
	|		├───about.go
	|		├──archives.go
	|		├──blog.go
	|		├──comment.go
	|		├──pagesController.go
	|		├──researchController.go
	|		└──tagsController.go
    ├── dao
	│	├──blogs.go
	│	├──comment.go
	│	├──sql.go
	│	├──tags.go
	│	├──types.go
	│	└──user.go
    ├── logic
    │   └── user.go
    ├── middlerware
	│	├──function.go
	│	├──getImg.go
	│	├──getTime.go
	│	├──markdown.go
	│	├──select.go
	│	└──session.go
    ├── model
	│	├──blog.go
	│	├──commnent.go
	│	├──tag.go
	│	├──type.go
	│	└──user/go
    ├── static
	│	└──静态文件（头像、图片、logo、css、js等）
    ├── templates
	│	└──html模板文件
    ├── go.mod（依赖）
    └── main.go
    

## 2.相关功能实现简介
### 1、评论及回复功能
comment的结构体属性如下
```go
package model

type Comment struct {
	Id     int //评论id
	BlogId int //博文id
	ReCommentId    int    //父评论id
	CommentName string //评论人姓名
	ReCommentName  string //父评论人姓名
	CommentEmail   string
	Img            string
	CommentContent string `gorm:"type:text" form:"CommentContent" json:"CommentContent"` //评论内容
	CommentTime    string ` json:"comment_time,omitempty"`
	Parent         *Comment
	Comments       []Comment
}
```
#### 实现方法
##### 1先通过查找父评论为-1的顶级评论
父评论Id为-1说明他不是任何评论的子评论
##### 2在html上遍历所有的顶级评论
在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论
###### （1）递归存储每个顶级评论的子评论
这里我用一个切片来储存一个顶级评论的所有子评论
```go
var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
	var comments []model.Comment
	DB.Debug().Where("re_comment_id = -1 AND blog_id = ?", id).Find(&comments)
	return &comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
	if count != 0 {
		fmt.Println("if判断1")
		var comments []model.Comment
		DB.Debug().Where("re_comment_id = ?", id).Find(&comments)
		count = len(comments)
		if count != 0 {
			fmt.Println("if判断2")
			for _, comment := range comments {
				fmt.Println("for判断1")
				Comments = append(Comments, comment)
				SelectCommentByComment(comment.Id, count)
			}
		}
	}
	fmt.Println(Comments)
	return &Comments

}
```
ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来
###### （2）出现问题的原因
因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量
###### （3）解决问题
```go
func ClearComments() bool {
	var comments []model.Comment
	Comments = comments
	return true
}

```
这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现
#### 这里我还加了一个小小的随机头像功能
```go
if  CommentName == user.Name && CommentEmail == user.UserEmail {
		fmt.Println("进入了1")
		comment.Img =user.UserImg
		//找相同评论人
	}else if CommentName == one.CommentName && CommentEmail == one.CommentEmail {
		fmt.Println("进入了2")
		comment.Img =one.Img
		//随机选头像
	}else{
		fmt.Println("进入了3")
		comment.Img =middleware.GetImg()
	}
```
##### 123分别代表三种不同的用户群体
1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
![](/static/images/%e5%a4%b4%e5%83%8f1.png)![](/static/images/%e5%a4%b4%e5%83%8f2.png)![](/static/images/%e5%a4%b4%e5%83%8f3.png)![](/static/images/%e5%a4%b4%e5%83%8f4.png)![](/static/images/%e5%a4%b4%e5%83%8f5.png)![](/static/images/%e5%a4%b4%e5%83%8f6.png)
### 2、归档功能
#### blog的结构体属性如下
```go
package model

type Blog struct {
	Id           int
	Title        string    `form:"title" json:"title"`                          //标题
	Content      string    `gorm:"type:longtext" form:"content" json:"content"` //内容
	Image        string    `gorm:"type:text" form:"image" json:"image"`         //首图
	Numb         int       `form:"numb" json:"numb"`                            //次数
	Flag         string    `form:"flag" json:"flag"`                            //原创或者转载
	Appreciation string    `form:"appreciation" json:"appreciation"`            //打赏开关
	ShareInfo    string    `form:"shareInfo" json:"shareInfo"`                  //版权开关
	Comment      string    `form:"comment" json:"comment"`                      //评论开关
	Recommend    string    `form:"recommend" json:"recommend"`                  //推荐开关
	Description  string    `gorm:"type:text" form:"description" json:"description"`
	CreatTime    string    `form:"creatTime"  json:"creat_time,omitempty"`   //创建时间
	UpdateTime   string    `form:"updateTime"  json:"update_time,omitempty"` //更新时间
	Comments     []Comment `form:"comments" json:"comments"`
	TypeId       int       `form:"typeId" json:"typeId"`
	Type         Type      `form:"type" gorm:"ForeignKey:TypeId"`
	Year         int       `form:"year" json:"year"`
	Month        int       `form:"month" json:"month"`
	Day          int       `form:"day" json:"day"`
}

```
#### 实现方法
我的思路是创建三个时间节点
year month day 
利用sql分组查询
##### Group By分组查询步骤
###### （1）先按照年份查询
###### （2）再按照年份遍历每个月份
并将所有保存在一个切片中
###### （3）按照月份遍历每个月的所有文章
保存在一个Map中，key是对应的月份，value是每个月份的所有文章
#### 自此归档功能实现


## 3.已知BUG
### 后台退出功能
后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧

开源地址
[github](https://github.com/likewl/blog "github")
[gitee](https://gitee.com/nculike/blog "gitee")', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1535821573,4166447487&fm=26&gp=0.jpg', `numb` = 48, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '本博客后端是用golang 的gin框架+gorm编写', `creat_time` = '2020-07-20 15:24:23', `update_time` = '2020-07-20 15:24:23', `type_id` = 4, `year` = 2020, `month` = 7, `day` = 20  WHERE `blogs`.`id` = 4  
[36;31m[1 rows affected or returned ][0m 
<p>今天本博客评论功能发布</p>

<h1>自今天起，本博客基本功能已经完成</h1>

<h2>发布V1.0版本并开源</h2>

<h2>博客语言说明</h2>

<h4>本博客后端是用golang 的gin框架+gorm编写</h4>

<p>前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的</p>

<h4>博客效果参考本站</h4>

<p>#一、博客简介</p>

<h2>1.博客目录</h2>

<pre><code>blog
├────controller
├────└───admin
|   |   ├──adminblog.go
|   |   ├───adminController.go
|   |   ├──adminTag.go
|   |   ├──adminType.go
|   |   └──adminUser.go
|   └──page
|       ├──404.go
|       ├───about.go
|       ├──archives.go
|       ├──blog.go
|       ├──comment.go
|       ├──pagesController.go
|       ├──researchController.go
|       └──tagsController.go
├── dao
│   ├──blogs.go
│   ├──comment.go
│   ├──sql.go
│   ├──tags.go
│   ├──types.go
│   └──user.go
├── logic
│   └── user.go
├── middlerware
│   ├──function.go
│   ├──getImg.go
│   ├──getTime.go
│   ├──markdown.go
│   ├──select.go
│   └──session.go
├── model
│   ├──blog.go
│   ├──commnent.go
│   ├──tag.go
│   ├──type.go
│   └──user/go
├── static
│   └──静态文件（头像、图片、logo、css、js等）
├── templates
│   └──html模板文件
├── go.mod（依赖）
└── main.go
</code></pre>

<h2>2.相关功能实现简介</h2>

<h3>1、评论及回复功能</h3>

<p>comment的结构体属性如下</p>

<pre><code class="language-go">package model

type Comment struct {
    Id     int //评论id
    BlogId int //博文id
    ReCommentId    int    //父评论id
    CommentName string //评论人姓名
    ReCommentName  string //父评论人姓名
    CommentEmail   string
    Img            string
    CommentContent string `gorm:&#34;type:text&#34; form:&#34;CommentContent&#34; json:&#34;CommentContent&#34;` //评论内容
    CommentTime    string ` json:&#34;comment_time,omitempty&#34;`
    Parent         *Comment
    Comments       []Comment
}
</code></pre>

<h4>实现方法</h4>

<h5>1先通过查找父评论为-1的顶级评论</h5>

<p>父评论Id为-1说明他不是任何评论的子评论</p>

<h5>2在html上遍历所有的顶级评论</h5>

<p>在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论</p>

<h6>（1）递归存储每个顶级评论的子评论</h6>

<p>这里我用一个切片来储存一个顶级评论的所有子评论</p>

<pre><code class="language-go">var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
    var comments []model.Comment
    DB.Debug().Where(&#34;re_comment_id = -1 AND blog_id = ?&#34;, id).Find(&amp;comments)
    return &amp;comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
    if count != 0 {
        fmt.Println(&#34;if判断1&#34;)
        var comments []model.Comment
        DB.Debug().Where(&#34;re_comment_id = ?&#34;, id).Find(&amp;comments)
        count = len(comments)
        if count != 0 {
            fmt.Println(&#34;if判断2&#34;)
            for _, comment := range comments {
                fmt.Println(&#34;for判断1&#34;)
                Comments = append(Comments, comment)
                SelectCommentByComment(comment.Id, count)
            }
        }
    }
    fmt.Println(Comments)
    return &amp;Comments

}
</code></pre>

<p>ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来</p>

<h6>（2）出现问题的原因</h6>

<p>因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量</p>

<h6>（3）解决问题</h6>

<pre><code class="language-go">func ClearComments() bool {
    var comments []model.Comment
    Comments = comments
    return true
}

</code></pre>

<p>这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现</p>

<h4>这里我还加了一个小小的随机头像功能</h4>

<pre><code class="language-go">if  CommentName == user.Name &amp;&amp; CommentEmail == user.UserEmail {
        fmt.Println(&#34;进入了1&#34;)
        comment.Img =user.UserImg
        //找相同评论人
    }else if CommentName == one.CommentName &amp;&amp; CommentEmail == one.CommentEmail {
        fmt.Println(&#34;进入了2&#34;)
        comment.Img =one.Img
        //随机选头像
    }else{
        fmt.Println(&#34;进入了3&#34;)
        comment.Img =middleware.GetImg()
    }
</code></pre>

<h5>123分别代表三种不同的用户群体</h5>

<p>1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
<img src="/static/images/%e5%a4%b4%e5%83%8f1.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f2.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f3.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f4.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f5.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f6.png" alt=""/></p>

<h3>2、归档功能</h3>

<h4>blog的结构体属性如下</h4>

<pre><code class="language-go">package model

type Blog struct {
    Id           int
    Title        string    `form:&#34;title&#34; json:&#34;title&#34;`                          //标题
    Content      string    `gorm:&#34;type:longtext&#34; form:&#34;content&#34; json:&#34;content&#34;` //内容
    Image        string    `gorm:&#34;type:text&#34; form:&#34;image&#34; json:&#34;image&#34;`         //首图
    Numb         int       `form:&#34;numb&#34; json:&#34;numb&#34;`                            //次数
    Flag         string    `form:&#34;flag&#34; json:&#34;flag&#34;`                            //原创或者转载
    Appreciation string    `form:&#34;appreciation&#34; json:&#34;appreciation&#34;`            //打赏开关
    ShareInfo    string    `form:&#34;shareInfo&#34; json:&#34;shareInfo&#34;`                  //版权开关
    Comment      string    `form:&#34;comment&#34; json:&#34;comment&#34;`                      //评论开关
    Recommend    string    `form:&#34;recommend&#34; json:&#34;recommend&#34;`                  //推荐开关
    Description  string    `gorm:&#34;type:text&#34; form:&#34;description&#34; json:&#34;description&#34;`
    CreatTime    string    `form:&#34;creatTime&#34;  json:&#34;creat_time,omitempty&#34;`   //创建时间
    UpdateTime   string    `form:&#34;updateTime&#34;  json:&#34;update_time,omitempty&#34;` //更新时间
    Comments     []Comment `form:&#34;comments&#34; json:&#34;comments&#34;`
    TypeId       int       `form:&#34;typeId&#34; json:&#34;typeId&#34;`
    Type         Type      `form:&#34;type&#34; gorm:&#34;ForeignKey:TypeId&#34;`
    Year         int       `form:&#34;year&#34; json:&#34;year&#34;`
    Month        int       `form:&#34;month&#34; json:&#34;month&#34;`
    Day          int       `form:&#34;day&#34; json:&#34;day&#34;`
}

</code></pre>

<h4>实现方法</h4>

<p>我的思路是创建三个时间节点
year month day
利用sql分组查询</p>

<h5>Group By分组查询步骤</h5>

<h6>（1）先按照年份查询</h6>

<h6>（2）再按照年份遍历每个月份</h6>

<p>并将所有保存在一个切片中</p>

<h6>（3）按照月份遍历每个月的所有文章</h6>

<p>保存在一个Map中，key是对应的月份，value是每个月份的所有文章</p>

<h4>自此归档功能实现</h4>

<h2>3.已知BUG</h2>

<h3>后台退出功能</h3>

<p>后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧</p>

<p>开源地址
<a href="https://github.com/likewl/blog" title="github" rel="nofollow">github</a>
<a href="https://gitee.com/nculike/blog" title="gitee" rel="nofollow">gitee</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 18:11:18][0m  [36;1m[0.29ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-21 18:11:20][0m  [36;1m[0.37ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 4)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-21 18:11:20][0m  [36;1m[0.45ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=4  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-21 18:11:20][0m  [36;1m[0.44ms][0m  UPDATE `blogs` SET `title` = '本博客开源公告', `content` = '今天本博客评论功能发布
# 自今天起，本博客基本功能已经完成
## 发布V1.0版本并开源
## 博客语言说明
#### 本博客后端是用golang 的gin框架+gorm编写
前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的
#### 博客效果参考本站
#一、博客简介
## 1.博客目录

    blog
    ├────controller
	├────└───admin
	|	|	├──adminblog.go
	|	|	├───adminController.go
	|	|	├──adminTag.go
	|	|	├──adminType.go
	|	|	└──adminUser.go
	|	└──page
	|		├──404.go
	|		├───about.go
	|		├──archives.go
	|		├──blog.go
	|		├──comment.go
	|		├──pagesController.go
	|		├──researchController.go
	|		└──tagsController.go
    ├── dao
	│	├──blogs.go
	│	├──comment.go
	│	├──sql.go
	│	├──tags.go
	│	├──types.go
	│	└──user.go
    ├── logic
    │   └── user.go
    ├── middlerware
	│	├──function.go
	│	├──getImg.go
	│	├──getTime.go
	│	├──markdown.go
	│	├──select.go
	│	└──session.go
    ├── model
	│	├──blog.go
	│	├──commnent.go
	│	├──tag.go
	│	├──type.go
	│	└──user/go
    ├── static
	│	└──静态文件（头像、图片、logo、css、js等）
    ├── templates
	│	└──html模板文件
    ├── go.mod（依赖）
    └── main.go
    

## 2.相关功能实现简介
### 1、评论及回复功能
comment的结构体属性如下
```go
package model

type Comment struct {
	Id     int //评论id
	BlogId int //博文id
	ReCommentId    int    //父评论id
	CommentName string //评论人姓名
	ReCommentName  string //父评论人姓名
	CommentEmail   string
	Img            string
	CommentContent string `gorm:"type:text" form:"CommentContent" json:"CommentContent"` //评论内容
	CommentTime    string ` json:"comment_time,omitempty"`
	Parent         *Comment
	Comments       []Comment
}
```
#### 实现方法
##### 1先通过查找父评论为-1的顶级评论
父评论Id为-1说明他不是任何评论的子评论
##### 2在html上遍历所有的顶级评论
在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论
###### （1）递归存储每个顶级评论的子评论
这里我用一个切片来储存一个顶级评论的所有子评论
```go
var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
	var comments []model.Comment
	DB.Debug().Where("re_comment_id = -1 AND blog_id = ?", id).Find(&comments)
	return &comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
	if count != 0 {
		fmt.Println("if判断1")
		var comments []model.Comment
		DB.Debug().Where("re_comment_id = ?", id).Find(&comments)
		count = len(comments)
		if count != 0 {
			fmt.Println("if判断2")
			for _, comment := range comments {
				fmt.Println("for判断1")
				Comments = append(Comments, comment)
				SelectCommentByComment(comment.Id, count)
			}
		}
	}
	fmt.Println(Comments)
	return &Comments

}
```
ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来
###### （2）出现问题的原因
因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量
###### （3）解决问题
```go
func ClearComments() bool {
	var comments []model.Comment
	Comments = comments
	return true
}

```
这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现
#### 这里我还加了一个小小的随机头像功能
```go
if  CommentName == user.Name && CommentEmail == user.UserEmail {
		fmt.Println("进入了1")
		comment.Img =user.UserImg
		//找相同评论人
	}else if CommentName == one.CommentName && CommentEmail == one.CommentEmail {
		fmt.Println("进入了2")
		comment.Img =one.Img
		//随机选头像
	}else{
		fmt.Println("进入了3")
		comment.Img =middleware.GetImg()
	}
```
##### 123分别代表三种不同的用户群体
1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
![](/static/images/%e5%a4%b4%e5%83%8f1.png)![](/static/images/%e5%a4%b4%e5%83%8f2.png)![](/static/images/%e5%a4%b4%e5%83%8f3.png)![](/static/images/%e5%a4%b4%e5%83%8f4.png)![](/static/images/%e5%a4%b4%e5%83%8f5.png)![](/static/images/%e5%a4%b4%e5%83%8f6.png)
### 2、归档功能
#### blog的结构体属性如下
```go
package model

type Blog struct {
	Id           int
	Title        string    `form:"title" json:"title"`                          //标题
	Content      string    `gorm:"type:longtext" form:"content" json:"content"` //内容
	Image        string    `gorm:"type:text" form:"image" json:"image"`         //首图
	Numb         int       `form:"numb" json:"numb"`                            //次数
	Flag         string    `form:"flag" json:"flag"`                            //原创或者转载
	Appreciation string    `form:"appreciation" json:"appreciation"`            //打赏开关
	ShareInfo    string    `form:"shareInfo" json:"shareInfo"`                  //版权开关
	Comment      string    `form:"comment" json:"comment"`                      //评论开关
	Recommend    string    `form:"recommend" json:"recommend"`                  //推荐开关
	Description  string    `gorm:"type:text" form:"description" json:"description"`
	CreatTime    string    `form:"creatTime"  json:"creat_time,omitempty"`   //创建时间
	UpdateTime   string    `form:"updateTime"  json:"update_time,omitempty"` //更新时间
	Comments     []Comment `form:"comments" json:"comments"`
	TypeId       int       `form:"typeId" json:"typeId"`
	Type         Type      `form:"type" gorm:"ForeignKey:TypeId"`
	Year         int       `form:"year" json:"year"`
	Month        int       `form:"month" json:"month"`
	Day          int       `form:"day" json:"day"`
}

```
#### 实现方法
我的思路是创建三个时间节点
year month day 
利用sql分组查询
##### Group By分组查询步骤
###### （1）先按照年份查询
###### （2）再按照年份遍历每个月份
并将所有保存在一个切片中
###### （3）按照月份遍历每个月的所有文章
保存在一个Map中，key是对应的月份，value是每个月份的所有文章
#### 自此归档功能实现


## 3.已知BUG
### 后台退出功能
后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧

开源地址
[github](https://github.com/likewl/blog "github")
[gitee](https://gitee.com/nculike/blog "gitee")', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1535821573,4166447487&fm=26&gp=0.jpg', `numb` = 49, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '本博客后端是用golang 的gin框架+gorm编写', `creat_time` = '2020-07-20 15:24:23', `update_time` = '2020-07-20 15:24:23', `type_id` = 4, `year` = 2020, `month` = 7, `day` = 20  WHERE `blogs`.`id` = 4  
[36;31m[1 rows affected or returned ][0m 
<p>今天本博客评论功能发布</p>

<h1>自今天起，本博客基本功能已经完成</h1>

<h2>发布V1.0版本并开源</h2>

<h2>博客语言说明</h2>

<h4>本博客后端是用golang 的gin框架+gorm编写</h4>

<p>前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的</p>

<h4>博客效果参考本站</h4>

<p>#一、博客简介</p>

<h2>1.博客目录</h2>

<pre><code>blog
├────controller
├────└───admin
|   |   ├──adminblog.go
|   |   ├───adminController.go
|   |   ├──adminTag.go
|   |   ├──adminType.go
|   |   └──adminUser.go
|   └──page
|       ├──404.go
|       ├───about.go
|       ├──archives.go
|       ├──blog.go
|       ├──comment.go
|       ├──pagesController.go
|       ├──researchController.go
|       └──tagsController.go
├── dao
│   ├──blogs.go
│   ├──comment.go
│   ├──sql.go
│   ├──tags.go
│   ├──types.go
│   └──user.go
├── logic
│   └── user.go
├── middlerware
│   ├──function.go
│   ├──getImg.go
│   ├──getTime.go
│   ├──markdown.go
│   ├──select.go
│   └──session.go
├── model
│   ├──blog.go
│   ├──commnent.go
│   ├──tag.go
│   ├──type.go
│   └──user/go
├── static
│   └──静态文件（头像、图片、logo、css、js等）
├── templates
│   └──html模板文件
├── go.mod（依赖）
└── main.go
</code></pre>

<h2>2.相关功能实现简介</h2>

<h3>1、评论及回复功能</h3>

<p>comment的结构体属性如下</p>

<pre><code class="language-go">package model

type Comment struct {
    Id     int //评论id
    BlogId int //博文id
    ReCommentId    int    //父评论id
    CommentName string //评论人姓名
    ReCommentName  string //父评论人姓名
    CommentEmail   string
    Img            string
    CommentContent string `gorm:&#34;type:text&#34; form:&#34;CommentContent&#34; json:&#34;CommentContent&#34;` //评论内容
    CommentTime    string ` json:&#34;comment_time,omitempty&#34;`
    Parent         *Comment
    Comments       []Comment
}
</code></pre>

<h4>实现方法</h4>

<h5>1先通过查找父评论为-1的顶级评论</h5>

<p>父评论Id为-1说明他不是任何评论的子评论</p>

<h5>2在html上遍历所有的顶级评论</h5>

<p>在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论</p>

<h6>（1）递归存储每个顶级评论的子评论</h6>

<p>这里我用一个切片来储存一个顶级评论的所有子评论</p>

<pre><code class="language-go">var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
    var comments []model.Comment
    DB.Debug().Where(&#34;re_comment_id = -1 AND blog_id = ?&#34;, id).Find(&amp;comments)
    return &amp;comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
    if count != 0 {
        fmt.Println(&#34;if判断1&#34;)
        var comments []model.Comment
        DB.Debug().Where(&#34;re_comment_id = ?&#34;, id).Find(&amp;comments)
        count = len(comments)
        if count != 0 {
            fmt.Println(&#34;if判断2&#34;)
            for _, comment := range comments {
                fmt.Println(&#34;for判断1&#34;)
                Comments = append(Comments, comment)
                SelectCommentByComment(comment.Id, count)
            }
        }
    }
    fmt.Println(Comments)
    return &amp;Comments

}
</code></pre>

<p>ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来</p>

<h6>（2）出现问题的原因</h6>

<p>因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量</p>

<h6>（3）解决问题</h6>

<pre><code class="language-go">func ClearComments() bool {
    var comments []model.Comment
    Comments = comments
    return true
}

</code></pre>

<p>这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现</p>

<h4>这里我还加了一个小小的随机头像功能</h4>

<pre><code class="language-go">if  CommentName == user.Name &amp;&amp; CommentEmail == user.UserEmail {
        fmt.Println(&#34;进入了1&#34;)
        comment.Img =user.UserImg
        //找相同评论人
    }else if CommentName == one.CommentName &amp;&amp; CommentEmail == one.CommentEmail {
        fmt.Println(&#34;进入了2&#34;)
        comment.Img =one.Img
        //随机选头像
    }else{
        fmt.Println(&#34;进入了3&#34;)
        comment.Img =middleware.GetImg()
    }
</code></pre>

<h5>123分别代表三种不同的用户群体</h5>

<p>1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
<img src="/static/images/%e5%a4%b4%e5%83%8f1.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f2.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f3.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f4.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f5.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f6.png" alt=""/></p>

<h3>2、归档功能</h3>

<h4>blog的结构体属性如下</h4>

<pre><code class="language-go">package model

type Blog struct {
    Id           int
    Title        string    `form:&#34;title&#34; json:&#34;title&#34;`                          //标题
    Content      string    `gorm:&#34;type:longtext&#34; form:&#34;content&#34; json:&#34;content&#34;` //内容
    Image        string    `gorm:&#34;type:text&#34; form:&#34;image&#34; json:&#34;image&#34;`         //首图
    Numb         int       `form:&#34;numb&#34; json:&#34;numb&#34;`                            //次数
    Flag         string    `form:&#34;flag&#34; json:&#34;flag&#34;`                            //原创或者转载
    Appreciation string    `form:&#34;appreciation&#34; json:&#34;appreciation&#34;`            //打赏开关
    ShareInfo    string    `form:&#34;shareInfo&#34; json:&#34;shareInfo&#34;`                  //版权开关
    Comment      string    `form:&#34;comment&#34; json:&#34;comment&#34;`                      //评论开关
    Recommend    string    `form:&#34;recommend&#34; json:&#34;recommend&#34;`                  //推荐开关
    Description  string    `gorm:&#34;type:text&#34; form:&#34;description&#34; json:&#34;description&#34;`
    CreatTime    string    `form:&#34;creatTime&#34;  json:&#34;creat_time,omitempty&#34;`   //创建时间
    UpdateTime   string    `form:&#34;updateTime&#34;  json:&#34;update_time,omitempty&#34;` //更新时间
    Comments     []Comment `form:&#34;comments&#34; json:&#34;comments&#34;`
    TypeId       int       `form:&#34;typeId&#34; json:&#34;typeId&#34;`
    Type         Type      `form:&#34;type&#34; gorm:&#34;ForeignKey:TypeId&#34;`
    Year         int       `form:&#34;year&#34; json:&#34;year&#34;`
    Month        int       `form:&#34;month&#34; json:&#34;month&#34;`
    Day          int       `form:&#34;day&#34; json:&#34;day&#34;`
}

</code></pre>

<h4>实现方法</h4>

<p>我的思路是创建三个时间节点
year month day
利用sql分组查询</p>

<h5>Group By分组查询步骤</h5>

<h6>（1）先按照年份查询</h6>

<h6>（2）再按照年份遍历每个月份</h6>

<p>并将所有保存在一个切片中</p>

<h6>（3）按照月份遍历每个月的所有文章</h6>

<p>保存在一个Map中，key是对应的月份，value是每个月份的所有文章</p>

<h4>自此归档功能实现</h4>

<h2>3.已知BUG</h2>

<h3>后台退出功能</h3>

<p>后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧</p>

<p>开源地址
<a href="https://github.com/likewl/blog" title="github" rel="nofollow">github</a>
<a href="https://gitee.com/nculike/blog" title="gitee" rel="nofollow">gitee</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 18:11:20][0m  [36;1m[1.64ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-21 18:11:21][0m  [36;1m[0.45ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 4)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-21 18:11:21][0m  [36;1m[0.50ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=4  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-21 18:11:21][0m  [36;1m[0.47ms][0m  UPDATE `blogs` SET `title` = '本博客开源公告', `content` = '今天本博客评论功能发布
# 自今天起，本博客基本功能已经完成
## 发布V1.0版本并开源
## 博客语言说明
#### 本博客后端是用golang 的gin框架+gorm编写
前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的
#### 博客效果参考本站
#一、博客简介
## 1.博客目录

    blog
    ├────controller
	├────└───admin
	|	|	├──adminblog.go
	|	|	├───adminController.go
	|	|	├──adminTag.go
	|	|	├──adminType.go
	|	|	└──adminUser.go
	|	└──page
	|		├──404.go
	|		├───about.go
	|		├──archives.go
	|		├──blog.go
	|		├──comment.go
	|		├──pagesController.go
	|		├──researchController.go
	|		└──tagsController.go
    ├── dao
	│	├──blogs.go
	│	├──comment.go
	│	├──sql.go
	│	├──tags.go
	│	├──types.go
	│	└──user.go
    ├── logic
    │   └── user.go
    ├── middlerware
	│	├──function.go
	│	├──getImg.go
	│	├──getTime.go
	│	├──markdown.go
	│	├──select.go
	│	└──session.go
    ├── model
	│	├──blog.go
	│	├──commnent.go
	│	├──tag.go
	│	├──type.go
	│	└──user/go
    ├── static
	│	└──静态文件（头像、图片、logo、css、js等）
    ├── templates
	│	└──html模板文件
    ├── go.mod（依赖）
    └── main.go
    

## 2.相关功能实现简介
### 1、评论及回复功能
comment的结构体属性如下
```go
package model

type Comment struct {
	Id     int //评论id
	BlogId int //博文id
	ReCommentId    int    //父评论id
	CommentName string //评论人姓名
	ReCommentName  string //父评论人姓名
	CommentEmail   string
	Img            string
	CommentContent string `gorm:"type:text" form:"CommentContent" json:"CommentContent"` //评论内容
	CommentTime    string ` json:"comment_time,omitempty"`
	Parent         *Comment
	Comments       []Comment
}
```
#### 实现方法
##### 1先通过查找父评论为-1的顶级评论
父评论Id为-1说明他不是任何评论的子评论
##### 2在html上遍历所有的顶级评论
在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论
###### （1）递归存储每个顶级评论的子评论
这里我用一个切片来储存一个顶级评论的所有子评论
```go
var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
	var comments []model.Comment
	DB.Debug().Where("re_comment_id = -1 AND blog_id = ?", id).Find(&comments)
	return &comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
	if count != 0 {
		fmt.Println("if判断1")
		var comments []model.Comment
		DB.Debug().Where("re_comment_id = ?", id).Find(&comments)
		count = len(comments)
		if count != 0 {
			fmt.Println("if判断2")
			for _, comment := range comments {
				fmt.Println("for判断1")
				Comments = append(Comments, comment)
				SelectCommentByComment(comment.Id, count)
			}
		}
	}
	fmt.Println(Comments)
	return &Comments

}
```
ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来
###### （2）出现问题的原因
因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量
###### （3）解决问题
```go
func ClearComments() bool {
	var comments []model.Comment
	Comments = comments
	return true
}

```
这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现
#### 这里我还加了一个小小的随机头像功能
```go
if  CommentName == user.Name && CommentEmail == user.UserEmail {
		fmt.Println("进入了1")
		comment.Img =user.UserImg
		//找相同评论人
	}else if CommentName == one.CommentName && CommentEmail == one.CommentEmail {
		fmt.Println("进入了2")
		comment.Img =one.Img
		//随机选头像
	}else{
		fmt.Println("进入了3")
		comment.Img =middleware.GetImg()
	}
```
##### 123分别代表三种不同的用户群体
1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
![](/static/images/%e5%a4%b4%e5%83%8f1.png)![](/static/images/%e5%a4%b4%e5%83%8f2.png)![](/static/images/%e5%a4%b4%e5%83%8f3.png)![](/static/images/%e5%a4%b4%e5%83%8f4.png)![](/static/images/%e5%a4%b4%e5%83%8f5.png)![](/static/images/%e5%a4%b4%e5%83%8f6.png)
### 2、归档功能
#### blog的结构体属性如下
```go
package model

type Blog struct {
	Id           int
	Title        string    `form:"title" json:"title"`                          //标题
	Content      string    `gorm:"type:longtext" form:"content" json:"content"` //内容
	Image        string    `gorm:"type:text" form:"image" json:"image"`         //首图
	Numb         int       `form:"numb" json:"numb"`                            //次数
	Flag         string    `form:"flag" json:"flag"`                            //原创或者转载
	Appreciation string    `form:"appreciation" json:"appreciation"`            //打赏开关
	ShareInfo    string    `form:"shareInfo" json:"shareInfo"`                  //版权开关
	Comment      string    `form:"comment" json:"comment"`                      //评论开关
	Recommend    string    `form:"recommend" json:"recommend"`                  //推荐开关
	Description  string    `gorm:"type:text" form:"description" json:"description"`
	CreatTime    string    `form:"creatTime"  json:"creat_time,omitempty"`   //创建时间
	UpdateTime   string    `form:"updateTime"  json:"update_time,omitempty"` //更新时间
	Comments     []Comment `form:"comments" json:"comments"`
	TypeId       int       `form:"typeId" json:"typeId"`
	Type         Type      `form:"type" gorm:"ForeignKey:TypeId"`
	Year         int       `form:"year" json:"year"`
	Month        int       `form:"month" json:"month"`
	Day          int       `form:"day" json:"day"`
}

```
#### 实现方法
我的思路是创建三个时间节点
year month day 
利用sql分组查询
##### Group By分组查询步骤
###### （1）先按照年份查询
###### （2）再按照年份遍历每个月份
并将所有保存在一个切片中
###### （3）按照月份遍历每个月的所有文章
保存在一个Map中，key是对应的月份，value是每个月份的所有文章
#### 自此归档功能实现


## 3.已知BUG
### 后台退出功能
后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧

开源地址
[github](https://github.com/likewl/blog "github")
[gitee](https://gitee.com/nculike/blog "gitee")', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1535821573,4166447487&fm=26&gp=0.jpg', `numb` = 50, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '本博客后端是用golang 的gin框架+gorm编写', `creat_time` = '2020-07-20 15:24:23', `update_time` = '2020-07-20 15:24:23', `type_id` = 4, `year` = 2020, `month` = 7, `day` = 20  WHERE `blogs`.`id` = 4  
[36;31m[1 rows affected or returned ][0m 
<p>今天本博客评论功能发布</p>

<h1>自今天起，本博客基本功能已经完成</h1>

<h2>发布V1.0版本并开源</h2>

<h2>博客语言说明</h2>

<h4>本博客后端是用golang 的gin框架+gorm编写</h4>

<p>前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的</p>

<h4>博客效果参考本站</h4>

<p>#一、博客简介</p>

<h2>1.博客目录</h2>

<pre><code>blog
├────controller
├────└───admin
|   |   ├──adminblog.go
|   |   ├───adminController.go
|   |   ├──adminTag.go
|   |   ├──adminType.go
|   |   └──adminUser.go
|   └──page
|       ├──404.go
|       ├───about.go
|       ├──archives.go
|       ├──blog.go
|       ├──comment.go
|       ├──pagesController.go
|       ├──researchController.go
|       └──tagsController.go
├── dao
│   ├──blogs.go
│   ├──comment.go
│   ├──sql.go
│   ├──tags.go
│   ├──types.go
│   └──user.go
├── logic
│   └── user.go
├── middlerware
│   ├──function.go
│   ├──getImg.go
│   ├──getTime.go
│   ├──markdown.go
│   ├──select.go
│   └──session.go
├── model
│   ├──blog.go
│   ├──commnent.go
│   ├──tag.go
│   ├──type.go
│   └──user/go
├── static
│   └──静态文件（头像、图片、logo、css、js等）
├── templates
│   └──html模板文件
├── go.mod（依赖）
└── main.go
</code></pre>

<h2>2.相关功能实现简介</h2>

<h3>1、评论及回复功能</h3>

<p>comment的结构体属性如下</p>

<pre><code class="language-go">package model

type Comment struct {
    Id     int //评论id
    BlogId int //博文id
    ReCommentId    int    //父评论id
    CommentName string //评论人姓名
    ReCommentName  string //父评论人姓名
    CommentEmail   string
    Img            string
    CommentContent string `gorm:&#34;type:text&#34; form:&#34;CommentContent&#34; json:&#34;CommentContent&#34;` //评论内容
    CommentTime    string ` json:&#34;comment_time,omitempty&#34;`
    Parent         *Comment
    Comments       []Comment
}
</code></pre>

<h4>实现方法</h4>

<h5>1先通过查找父评论为-1的顶级评论</h5>

<p>父评论Id为-1说明他不是任何评论的子评论</p>

<h5>2在html上遍历所有的顶级评论</h5>

<p>在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论</p>

<h6>（1）递归存储每个顶级评论的子评论</h6>

<p>这里我用一个切片来储存一个顶级评论的所有子评论</p>

<pre><code class="language-go">var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
    var comments []model.Comment
    DB.Debug().Where(&#34;re_comment_id = -1 AND blog_id = ?&#34;, id).Find(&amp;comments)
    return &amp;comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
    if count != 0 {
        fmt.Println(&#34;if判断1&#34;)
        var comments []model.Comment
        DB.Debug().Where(&#34;re_comment_id = ?&#34;, id).Find(&amp;comments)
        count = len(comments)
        if count != 0 {
            fmt.Println(&#34;if判断2&#34;)
            for _, comment := range comments {
                fmt.Println(&#34;for判断1&#34;)
                Comments = append(Comments, comment)
                SelectCommentByComment(comment.Id, count)
            }
        }
    }
    fmt.Println(Comments)
    return &amp;Comments

}
</code></pre>

<p>ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来</p>

<h6>（2）出现问题的原因</h6>

<p>因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量</p>

<h6>（3）解决问题</h6>

<pre><code class="language-go">func ClearComments() bool {
    var comments []model.Comment
    Comments = comments
    return true
}

</code></pre>

<p>这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现</p>

<h4>这里我还加了一个小小的随机头像功能</h4>

<pre><code class="language-go">if  CommentName == user.Name &amp;&amp; CommentEmail == user.UserEmail {
        fmt.Println(&#34;进入了1&#34;)
        comment.Img =user.UserImg
        //找相同评论人
    }else if CommentName == one.CommentName &amp;&amp; CommentEmail == one.CommentEmail {
        fmt.Println(&#34;进入了2&#34;)
        comment.Img =one.Img
        //随机选头像
    }else{
        fmt.Println(&#34;进入了3&#34;)
        comment.Img =middleware.GetImg()
    }
</code></pre>

<h5>123分别代表三种不同的用户群体</h5>

<p>1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
<img src="/static/images/%e5%a4%b4%e5%83%8f1.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f2.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f3.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f4.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f5.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f6.png" alt=""/></p>

<h3>2、归档功能</h3>

<h4>blog的结构体属性如下</h4>

<pre><code class="language-go">package model

type Blog struct {
    Id           int
    Title        string    `form:&#34;title&#34; json:&#34;title&#34;`                          //标题
    Content      string    `gorm:&#34;type:longtext&#34; form:&#34;content&#34; json:&#34;content&#34;` //内容
    Image        string    `gorm:&#34;type:text&#34; form:&#34;image&#34; json:&#34;image&#34;`         //首图
    Numb         int       `form:&#34;numb&#34; json:&#34;numb&#34;`                            //次数
    Flag         string    `form:&#34;flag&#34; json:&#34;flag&#34;`                            //原创或者转载
    Appreciation string    `form:&#34;appreciation&#34; json:&#34;appreciation&#34;`            //打赏开关
    ShareInfo    string    `form:&#34;shareInfo&#34; json:&#34;shareInfo&#34;`                  //版权开关
    Comment      string    `form:&#34;comment&#34; json:&#34;comment&#34;`                      //评论开关
    Recommend    string    `form:&#34;recommend&#34; json:&#34;recommend&#34;`                  //推荐开关
    Description  string    `gorm:&#34;type:text&#34; form:&#34;description&#34; json:&#34;description&#34;`
    CreatTime    string    `form:&#34;creatTime&#34;  json:&#34;creat_time,omitempty&#34;`   //创建时间
    UpdateTime   string    `form:&#34;updateTime&#34;  json:&#34;update_time,omitempty&#34;` //更新时间
    Comments     []Comment `form:&#34;comments&#34; json:&#34;comments&#34;`
    TypeId       int       `form:&#34;typeId&#34; json:&#34;typeId&#34;`
    Type         Type      `form:&#34;type&#34; gorm:&#34;ForeignKey:TypeId&#34;`
    Year         int       `form:&#34;year&#34; json:&#34;year&#34;`
    Month        int       `form:&#34;month&#34; json:&#34;month&#34;`
    Day          int       `form:&#34;day&#34; json:&#34;day&#34;`
}

</code></pre>

<h4>实现方法</h4>

<p>我的思路是创建三个时间节点
year month day
利用sql分组查询</p>

<h5>Group By分组查询步骤</h5>

<h6>（1）先按照年份查询</h6>

<h6>（2）再按照年份遍历每个月份</h6>

<p>并将所有保存在一个切片中</p>

<h6>（3）按照月份遍历每个月的所有文章</h6>

<p>保存在一个Map中，key是对应的月份，value是每个月份的所有文章</p>

<h4>自此归档功能实现</h4>

<h2>3.已知BUG</h2>

<h3>后台退出功能</h3>

<p>后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧</p>

<p>开源地址
<a href="https://github.com/likewl/blog" title="github" rel="nofollow">github</a>
<a href="https://gitee.com/nculike/blog" title="gitee" rel="nofollow">gitee</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 18:11:21][0m  [36;1m[0.30ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 18:11:32][0m  [36;1m[0.50ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 18:11:32][0m  [36;1m[0.68ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 18:11:32][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 18:11:32][0m  [36;1m[0.34ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 18:11:32][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 18:11:32][0m  [36;1m[0.34ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-21 18:12:22][0m  [36;1m[0.35ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 2)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-21 18:12:22][0m  [36;1m[0.46ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=2  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-21 18:12:22][0m  [36;1m[0.35ms][0m  UPDATE `blogs` SET `title` = '解决Linux关闭终端后运行的程序自动停止', `content` = '# 问题发现
  昨天博客发布，操作完关闭终端就睡了
  然而今天醒来突然发现终端不能访问了
  查看发现原来博客项目进程被杀死了
# 解决办法
    go build main.go
执行完后

    nohup ./main &
让程序在后台运行就可了


[========]
# ps:这个方法并不完美，因为我也是刚刚接触还不知道怎么切回来', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3696516981,3671280793&fm=26&gp=0.jpg', `numb` = 23, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '昨天博客发布，操作完关闭终端就睡了，然而今天醒来突然发现终端不能访问了，查看发现原来博客项目进程被杀死了', `creat_time` = '2020-07-19 19:05:36', `update_time` = '2020-07-19 19:05:36', `type_id` = 2, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 3  
[36;31m[1 rows affected or returned ][0m 
<h1>问题发现</h1>

<p>昨天博客发布，操作完关闭终端就睡了
  然而今天醒来突然发现终端不能访问了
  查看发现原来博客项目进程被杀死了</p>

<h1>解决办法</h1>

<pre><code>go build main.go
</code></pre>

<p>执行完后</p>

<pre><code>nohup ./main &amp;
</code></pre>

<p>让程序在后台运行就可了</p>

<p>[========]</p>

<h1>ps:这个方法并不完美，因为我也是刚刚接触还不知道怎么切回来</h1>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 18:12:22][0m  [36;1m[0.30ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 18:13:58][0m  [36;1m[0.85ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 18:13:58][0m  [36;1m[2.42ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 18:13:58][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 18:13:58][0m  [36;1m[0.29ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 18:13:58][0m  [36;1m[0.25ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 18:13:58][0m  [36;1m[0.35ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 18:14:55][0m  [36;1m[0.52ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 18:14:55][0m  [36;1m[0.77ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 18:14:55][0m  [36;1m[0.23ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 18:14:55][0m  [36;1m[0.33ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 18:14:55][0m  [36;1m[0.30ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 18:14:55][0m  [36;1m[0.41ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 
2020/07/21 18:14:55 http: panic serving 116.238.210.229:65199: write tcp 172.16.13.169:80->116.238.210.229:65199: write: broken pipe
goroutine 6426 [running]:
net/http.(*conn).serve.func1(0xc00021cdc0)
	/usr/local/go/src/net/http/server.go:1772 +0x139
panic(0xb50ee0, 0xc0001db4f0)
	/usr/local/go/src/runtime/panic.go:975 +0x3e3
github.com/gin-gonic/gin.(*Context).Render(0xc0005bc3c0, 0xc8, 0xd0e260, 0xc000673e00)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:842 +0x173
github.com/gin-gonic/gin.(*Context).HTML(0xc0005bc3c0, 0xc8, 0xbf926d, 0x10, 0xb43d60, 0xc00065b860)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:851 +0x99
blog/controller/page.IndexHandler(0xc0005bc3c0)
	/usr/workspace/src/blog/controller/page/pagesController.go:22 +0x570
github.com/gin-gonic/gin.(*Context).Next(0xc0005bc3c0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:161 +0x3b
github.com/gin-contrib/sessions.Sessions.func1(0xc0005bc3c0)
	/usr/workspace/pkg/mod/github.com/gin-contrib/sessions@v0.0.3/sessions.go:52 +0x16d
github.com/gin-gonic/gin.(*Context).Next(0xc0005bc3c0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:161 +0x3b
github.com/gin-gonic/gin.(*Engine).handleHTTPRequest(0xc0003b8500, 0xc0005bc3c0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/gin.go:409 +0x666
github.com/gin-gonic/gin.(*Engine).ServeHTTP(0xc0003b8500, 0xd12a40, 0xc0000b8d20, 0xc000722300)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/gin.go:367 +0x14d
net/http.serverHandler.ServeHTTP(0xc0000b8380, 0xd12a40, 0xc0000b8d20, 0xc000722300)
	/usr/local/go/src/net/http/server.go:2807 +0xa3
net/http.(*conn).serve(0xc00021cdc0, 0xd15200, 0xc0001b2f40)
	/usr/local/go/src/net/http/server.go:1895 +0x86c
created by net/http.(*Server).Serve
	/usr/local/go/src/net/http/server.go:2933 +0x35c

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 18:15:56][0m  [36;1m[0.74ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 18:15:56][0m  [36;1m[1.11ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 18:15:56][0m  [36;1m[0.33ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 18:15:56][0m  [36;1m[0.52ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 18:15:56][0m  [36;1m[0.47ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 18:15:56][0m  [36;1m[0.63ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 
2020/07/21 18:15:56 http: panic serving 123.151.77.123:32983: write tcp 172.16.13.169:80->123.151.77.123:32983: write: broken pipe
goroutine 6453 [running]:
net/http.(*conn).serve.func1(0xc0000be8c0)
	/usr/local/go/src/net/http/server.go:1772 +0x139
panic(0xb50ee0, 0xc0001dbbd0)
	/usr/local/go/src/runtime/panic.go:975 +0x3e3
github.com/gin-gonic/gin.(*Context).Render(0xc0005bd2c0, 0xc8, 0xd0e260, 0xc00078eb10)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:842 +0x173
github.com/gin-gonic/gin.(*Context).HTML(0xc0005bd2c0, 0xc8, 0xbf926d, 0x10, 0xb43d60, 0xc0006d46f0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:851 +0x99
blog/controller/page.IndexHandler(0xc0005bd2c0)
	/usr/workspace/src/blog/controller/page/pagesController.go:22 +0x570
github.com/gin-gonic/gin.(*Context).Next(0xc0005bd2c0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:161 +0x3b
github.com/gin-contrib/sessions.Sessions.func1(0xc0005bd2c0)
	/usr/workspace/pkg/mod/github.com/gin-contrib/sessions@v0.0.3/sessions.go:52 +0x16d
github.com/gin-gonic/gin.(*Context).Next(0xc0005bd2c0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:161 +0x3b
github.com/gin-gonic/gin.(*Engine).handleHTTPRequest(0xc0003b8500, 0xc0005bd2c0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/gin.go:409 +0x666
github.com/gin-gonic/gin.(*Engine).ServeHTTP(0xc0003b8500, 0xd12a40, 0xc0000b90a0, 0xc000684b00)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/gin.go:367 +0x14d
net/http.serverHandler.ServeHTTP(0xc0000b8380, 0xd12a40, 0xc0000b90a0, 0xc000684b00)
	/usr/local/go/src/net/http/server.go:2807 +0xa3
net/http.(*conn).serve(0xc0000be8c0, 0xd15200, 0xc00065f900)
	/usr/local/go/src/net/http/server.go:1895 +0x86c
created by net/http.(*Server).Serve
	/usr/local/go/src/net/http/server.go:2933 +0x35c

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 18:16:00][0m  [36;1m[0.48ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
2020/07/21 18:16:00 http: panic serving 124.64.19.27:2968: write tcp 172.16.13.169:80->124.64.19.27:2968: write: broken pipe
goroutine 6482 [running]:
net/http.(*conn).serve.func1(0xc00021c640)
	/usr/local/go/src/net/http/server.go:1772 +0x139
panic(0xb50ee0, 0xc0001da3c0)
	/usr/local/go/src/runtime/panic.go:975 +0x3e3
github.com/gin-gonic/gin.(*Context).Render(0xc0005bc2d0, 0x194, 0xd0e260, 0xc0003734d0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:842 +0x173
github.com/gin-gonic/gin.(*Context).HTML(0xc0005bc2d0, 0x194, 0xbf193d, 0x8, 0xb43d60, 0xc00065a7b0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:851 +0x99
blog/controller/page.NotFoundHandler(0xc0005bc2d0)
	/usr/workspace/src/blog/controller/page/404.go:12 +0x120
github.com/gin-gonic/gin.(*Context).Next(0xc0005bc2d0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:161 +0x3b
github.com/gin-contrib/sessions.Sessions.func1(0xc0005bc2d0)
	/usr/workspace/pkg/mod/github.com/gin-contrib/sessions@v0.0.3/sessions.go:52 +0x16d
github.com/gin-gonic/gin.(*Context).Next(0xc0005bc2d0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:161 +0x3b
github.com/gin-gonic/gin.serveError(0xc0005bc2d0, 0x194, 0x1248dc0, 0x12, 0x12)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/gin.go:445 +0x38
github.com/gin-gonic/gin.(*Engine).handleHTTPRequest(0xc0003b8500, 0xc0005bc2d0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/gin.go:438 +0x3d3
github.com/gin-gonic/gin.(*Engine).ServeHTTP(0xc0003b8500, 0xd12a40, 0xc0000b80e0, 0xc0000f2200)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/gin.go:367 +0x14d
net/http.serverHandler.ServeHTTP(0xc0000b8380, 0xd12a40, 0xc0000b80e0, 0xc0000f2200)
	/usr/local/go/src/net/http/server.go:2807 +0xa3
net/http.(*conn).serve(0xc00021c640, 0xd15200, 0xc0001b2180)
	/usr/local/go/src/net/http/server.go:1895 +0x86c
created by net/http.(*Server).Serve
	/usr/local/go/src/net/http/server.go:2933 +0x35c

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 18:16:03][0m  [36;1m[0.60ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 18:16:03][0m  [36;1m[0.27ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:144)[0m 
[33m[2020-07-21 18:16:03][0m  [36;1m[0.86ms][0m   SELECT * FROM `blogs` GROUP BY YEAR DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:157)[0m 
[33m[2020-07-21 18:16:03][0m  [36;1m[0.73ms][0m   SELECT * FROM `blogs` where year = 2020 GROUP BY month DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:169)[0m 
[33m[2020-07-21 18:16:03][0m  [36;1m[0.66ms][0m   SELECT * FROM `blogs` where year = 2020 and month = 7 ORDER BY `id` DESC  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 18:16:03][0m  [36;1m[0.40ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=4  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 18:16:03][0m  [36;1m[0.40ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=3  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 18:16:03][0m  [36;1m[0.35ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=2  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 18:16:03][0m  [36;1m[0.35ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 18:16:22][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 18:16:22][0m  [36;1m[0.22ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:144)[0m 
[33m[2020-07-21 18:16:22][0m  [36;1m[0.64ms][0m   SELECT * FROM `blogs` GROUP BY YEAR DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:157)[0m 
[33m[2020-07-21 18:16:22][0m  [36;1m[0.62ms][0m   SELECT * FROM `blogs` where year = 2020 GROUP BY month DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:169)[0m 
[33m[2020-07-21 18:16:22][0m  [36;1m[0.70ms][0m   SELECT * FROM `blogs` where year = 2020 and month = 7 ORDER BY `id` DESC  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 18:16:22][0m  [36;1m[0.40ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=4  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 18:16:22][0m  [36;1m[0.36ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=3  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 18:16:22][0m  [36;1m[0.33ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=2  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 18:16:22][0m  [36;1m[0.34ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-21 18:17:05][0m  [36;1m[0.36ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 2)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-21 18:17:05][0m  [36;1m[0.43ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=2  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-21 18:17:05][0m  [36;1m[0.41ms][0m  UPDATE `blogs` SET `title` = '解决Linux关闭终端后运行的程序自动停止', `content` = '# 问题发现
  昨天博客发布，操作完关闭终端就睡了
  然而今天醒来突然发现终端不能访问了
  查看发现原来博客项目进程被杀死了
# 解决办法
    go build main.go
执行完后

    nohup ./main &
让程序在后台运行就可了


[========]
# ps:这个方法并不完美，因为我也是刚刚接触还不知道怎么切回来', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3696516981,3671280793&fm=26&gp=0.jpg', `numb` = 24, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '昨天博客发布，操作完关闭终端就睡了，然而今天醒来突然发现终端不能访问了，查看发现原来博客项目进程被杀死了', `creat_time` = '2020-07-19 19:05:36', `update_time` = '2020-07-19 19:05:36', `type_id` = 2, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 3  
[36;31m[1 rows affected or returned ][0m 
<h1>问题发现</h1>

<p>昨天博客发布，操作完关闭终端就睡了
  然而今天醒来突然发现终端不能访问了
  查看发现原来博客项目进程被杀死了</p>

<h1>解决办法</h1>

<pre><code>go build main.go
</code></pre>

<p>执行完后</p>

<pre><code>nohup ./main &amp;
</code></pre>

<p>让程序在后台运行就可了</p>

<p>[========]</p>

<h1>ps:这个方法并不完美，因为我也是刚刚接触还不知道怎么切回来</h1>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 18:17:05][0m  [36;1m[0.28ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-21 18:20:31][0m  [36;1m[0.38ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 2)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-21 18:20:31][0m  [36;1m[0.45ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=2  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-21 18:20:32][0m  [36;1m[0.40ms][0m  UPDATE `blogs` SET `title` = '解决Linux关闭终端后运行的程序自动停止', `content` = '# 问题发现
  昨天博客发布，操作完关闭终端就睡了
  然而今天醒来突然发现终端不能访问了
  查看发现原来博客项目进程被杀死了
# 解决办法
    go build main.go
执行完后

    nohup ./main &
让程序在后台运行就可了


[========]
# ps:这个方法并不完美，因为我也是刚刚接触还不知道怎么切回来', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3696516981,3671280793&fm=26&gp=0.jpg', `numb` = 25, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '昨天博客发布，操作完关闭终端就睡了，然而今天醒来突然发现终端不能访问了，查看发现原来博客项目进程被杀死了', `creat_time` = '2020-07-19 19:05:36', `update_time` = '2020-07-19 19:05:36', `type_id` = 2, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 3  
[36;31m[1 rows affected or returned ][0m 
<h1>问题发现</h1>

<p>昨天博客发布，操作完关闭终端就睡了
  然而今天醒来突然发现终端不能访问了
  查看发现原来博客项目进程被杀死了</p>

<h1>解决办法</h1>

<pre><code>go build main.go
</code></pre>

<p>执行完后</p>

<pre><code>nohup ./main &amp;
</code></pre>

<p>让程序在后台运行就可了</p>

<p>[========]</p>

<h1>ps:这个方法并不完美，因为我也是刚刚接触还不知道怎么切回来</h1>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 18:20:32][0m  [36;1m[0.28ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-21 18:22:24][0m  [36;1m[0.39ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 4)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-21 18:22:24][0m  [36;1m[0.44ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=4  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-21 18:22:24][0m  [36;1m[0.43ms][0m  UPDATE `blogs` SET `title` = '本博客开源公告', `content` = '今天本博客评论功能发布
# 自今天起，本博客基本功能已经完成
## 发布V1.0版本并开源
## 博客语言说明
#### 本博客后端是用golang 的gin框架+gorm编写
前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的
#### 博客效果参考本站
#一、博客简介
## 1.博客目录

    blog
    ├────controller
	├────└───admin
	|	|	├──adminblog.go
	|	|	├───adminController.go
	|	|	├──adminTag.go
	|	|	├──adminType.go
	|	|	└──adminUser.go
	|	└──page
	|		├──404.go
	|		├───about.go
	|		├──archives.go
	|		├──blog.go
	|		├──comment.go
	|		├──pagesController.go
	|		├──researchController.go
	|		└──tagsController.go
    ├── dao
	│	├──blogs.go
	│	├──comment.go
	│	├──sql.go
	│	├──tags.go
	│	├──types.go
	│	└──user.go
    ├── logic
    │   └── user.go
    ├── middlerware
	│	├──function.go
	│	├──getImg.go
	│	├──getTime.go
	│	├──markdown.go
	│	├──select.go
	│	└──session.go
    ├── model
	│	├──blog.go
	│	├──commnent.go
	│	├──tag.go
	│	├──type.go
	│	└──user/go
    ├── static
	│	└──静态文件（头像、图片、logo、css、js等）
    ├── templates
	│	└──html模板文件
    ├── go.mod（依赖）
    └── main.go
    

## 2.相关功能实现简介
### 1、评论及回复功能
comment的结构体属性如下
```go
package model

type Comment struct {
	Id     int //评论id
	BlogId int //博文id
	ReCommentId    int    //父评论id
	CommentName string //评论人姓名
	ReCommentName  string //父评论人姓名
	CommentEmail   string
	Img            string
	CommentContent string `gorm:"type:text" form:"CommentContent" json:"CommentContent"` //评论内容
	CommentTime    string ` json:"comment_time,omitempty"`
	Parent         *Comment
	Comments       []Comment
}
```
#### 实现方法
##### 1先通过查找父评论为-1的顶级评论
父评论Id为-1说明他不是任何评论的子评论
##### 2在html上遍历所有的顶级评论
在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论
###### （1）递归存储每个顶级评论的子评论
这里我用一个切片来储存一个顶级评论的所有子评论
```go
var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
	var comments []model.Comment
	DB.Debug().Where("re_comment_id = -1 AND blog_id = ?", id).Find(&comments)
	return &comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
	if count != 0 {
		fmt.Println("if判断1")
		var comments []model.Comment
		DB.Debug().Where("re_comment_id = ?", id).Find(&comments)
		count = len(comments)
		if count != 0 {
			fmt.Println("if判断2")
			for _, comment := range comments {
				fmt.Println("for判断1")
				Comments = append(Comments, comment)
				SelectCommentByComment(comment.Id, count)
			}
		}
	}
	fmt.Println(Comments)
	return &Comments

}
```
ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来
###### （2）出现问题的原因
因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量
###### （3）解决问题
```go
func ClearComments() bool {
	var comments []model.Comment
	Comments = comments
	return true
}

```
这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现
#### 这里我还加了一个小小的随机头像功能
```go
if  CommentName == user.Name && CommentEmail == user.UserEmail {
		fmt.Println("进入了1")
		comment.Img =user.UserImg
		//找相同评论人
	}else if CommentName == one.CommentName && CommentEmail == one.CommentEmail {
		fmt.Println("进入了2")
		comment.Img =one.Img
		//随机选头像
	}else{
		fmt.Println("进入了3")
		comment.Img =middleware.GetImg()
	}
```
##### 123分别代表三种不同的用户群体
1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
![](/static/images/%e5%a4%b4%e5%83%8f1.png)![](/static/images/%e5%a4%b4%e5%83%8f2.png)![](/static/images/%e5%a4%b4%e5%83%8f3.png)![](/static/images/%e5%a4%b4%e5%83%8f4.png)![](/static/images/%e5%a4%b4%e5%83%8f5.png)![](/static/images/%e5%a4%b4%e5%83%8f6.png)
### 2、归档功能
#### blog的结构体属性如下
```go
package model

type Blog struct {
	Id           int
	Title        string    `form:"title" json:"title"`                          //标题
	Content      string    `gorm:"type:longtext" form:"content" json:"content"` //内容
	Image        string    `gorm:"type:text" form:"image" json:"image"`         //首图
	Numb         int       `form:"numb" json:"numb"`                            //次数
	Flag         string    `form:"flag" json:"flag"`                            //原创或者转载
	Appreciation string    `form:"appreciation" json:"appreciation"`            //打赏开关
	ShareInfo    string    `form:"shareInfo" json:"shareInfo"`                  //版权开关
	Comment      string    `form:"comment" json:"comment"`                      //评论开关
	Recommend    string    `form:"recommend" json:"recommend"`                  //推荐开关
	Description  string    `gorm:"type:text" form:"description" json:"description"`
	CreatTime    string    `form:"creatTime"  json:"creat_time,omitempty"`   //创建时间
	UpdateTime   string    `form:"updateTime"  json:"update_time,omitempty"` //更新时间
	Comments     []Comment `form:"comments" json:"comments"`
	TypeId       int       `form:"typeId" json:"typeId"`
	Type         Type      `form:"type" gorm:"ForeignKey:TypeId"`
	Year         int       `form:"year" json:"year"`
	Month        int       `form:"month" json:"month"`
	Day          int       `form:"day" json:"day"`
}

```
#### 实现方法
我的思路是创建三个时间节点
year month day 
利用sql分组查询
##### Group By分组查询步骤
###### （1）先按照年份查询
###### （2）再按照年份遍历每个月份
并将所有保存在一个切片中
###### （3）按照月份遍历每个月的所有文章
保存在一个Map中，key是对应的月份，value是每个月份的所有文章
#### 自此归档功能实现


## 3.已知BUG
### 后台退出功能
后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧

开源地址
[github](https://github.com/likewl/blog "github")
[gitee](https://gitee.com/nculike/blog "gitee")', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1535821573,4166447487&fm=26&gp=0.jpg', `numb` = 51, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '本博客后端是用golang 的gin框架+gorm编写', `creat_time` = '2020-07-20 15:24:23', `update_time` = '2020-07-20 15:24:23', `type_id` = 4, `year` = 2020, `month` = 7, `day` = 20  WHERE `blogs`.`id` = 4  
[36;31m[1 rows affected or returned ][0m 
<p>今天本博客评论功能发布</p>

<h1>自今天起，本博客基本功能已经完成</h1>

<h2>发布V1.0版本并开源</h2>

<h2>博客语言说明</h2>

<h4>本博客后端是用golang 的gin框架+gorm编写</h4>

<p>前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的</p>

<h4>博客效果参考本站</h4>

<p>#一、博客简介</p>

<h2>1.博客目录</h2>

<pre><code>blog
├────controller
├────└───admin
|   |   ├──adminblog.go
|   |   ├───adminController.go
|   |   ├──adminTag.go
|   |   ├──adminType.go
|   |   └──adminUser.go
|   └──page
|       ├──404.go
|       ├───about.go
|       ├──archives.go
|       ├──blog.go
|       ├──comment.go
|       ├──pagesController.go
|       ├──researchController.go
|       └──tagsController.go
├── dao
│   ├──blogs.go
│   ├──comment.go
│   ├──sql.go
│   ├──tags.go
│   ├──types.go
│   └──user.go
├── logic
│   └── user.go
├── middlerware
│   ├──function.go
│   ├──getImg.go
│   ├──getTime.go
│   ├──markdown.go
│   ├──select.go
│   └──session.go
├── model
│   ├──blog.go
│   ├──commnent.go
│   ├──tag.go
│   ├──type.go
│   └──user/go
├── static
│   └──静态文件（头像、图片、logo、css、js等）
├── templates
│   └──html模板文件
├── go.mod（依赖）
└── main.go
</code></pre>

<h2>2.相关功能实现简介</h2>

<h3>1、评论及回复功能</h3>

<p>comment的结构体属性如下</p>

<pre><code class="language-go">package model

type Comment struct {
    Id     int //评论id
    BlogId int //博文id
    ReCommentId    int    //父评论id
    CommentName string //评论人姓名
    ReCommentName  string //父评论人姓名
    CommentEmail   string
    Img            string
    CommentContent string `gorm:&#34;type:text&#34; form:&#34;CommentContent&#34; json:&#34;CommentContent&#34;` //评论内容
    CommentTime    string ` json:&#34;comment_time,omitempty&#34;`
    Parent         *Comment
    Comments       []Comment
}
</code></pre>

<h4>实现方法</h4>

<h5>1先通过查找父评论为-1的顶级评论</h5>

<p>父评论Id为-1说明他不是任何评论的子评论</p>

<h5>2在html上遍历所有的顶级评论</h5>

<p>在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论</p>

<h6>（1）递归存储每个顶级评论的子评论</h6>

<p>这里我用一个切片来储存一个顶级评论的所有子评论</p>

<pre><code class="language-go">var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
    var comments []model.Comment
    DB.Debug().Where(&#34;re_comment_id = -1 AND blog_id = ?&#34;, id).Find(&amp;comments)
    return &amp;comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
    if count != 0 {
        fmt.Println(&#34;if判断1&#34;)
        var comments []model.Comment
        DB.Debug().Where(&#34;re_comment_id = ?&#34;, id).Find(&amp;comments)
        count = len(comments)
        if count != 0 {
            fmt.Println(&#34;if判断2&#34;)
            for _, comment := range comments {
                fmt.Println(&#34;for判断1&#34;)
                Comments = append(Comments, comment)
                SelectCommentByComment(comment.Id, count)
            }
        }
    }
    fmt.Println(Comments)
    return &amp;Comments

}
</code></pre>

<p>ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来</p>

<h6>（2）出现问题的原因</h6>

<p>因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量</p>

<h6>（3）解决问题</h6>

<pre><code class="language-go">func ClearComments() bool {
    var comments []model.Comment
    Comments = comments
    return true
}

</code></pre>

<p>这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现</p>

<h4>这里我还加了一个小小的随机头像功能</h4>

<pre><code class="language-go">if  CommentName == user.Name &amp;&amp; CommentEmail == user.UserEmail {
        fmt.Println(&#34;进入了1&#34;)
        comment.Img =user.UserImg
        //找相同评论人
    }else if CommentName == one.CommentName &amp;&amp; CommentEmail == one.CommentEmail {
        fmt.Println(&#34;进入了2&#34;)
        comment.Img =one.Img
        //随机选头像
    }else{
        fmt.Println(&#34;进入了3&#34;)
        comment.Img =middleware.GetImg()
    }
</code></pre>

<h5>123分别代表三种不同的用户群体</h5>

<p>1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
<img src="/static/images/%e5%a4%b4%e5%83%8f1.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f2.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f3.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f4.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f5.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f6.png" alt=""/></p>

<h3>2、归档功能</h3>

<h4>blog的结构体属性如下</h4>

<pre><code class="language-go">package model

type Blog struct {
    Id           int
    Title        string    `form:&#34;title&#34; json:&#34;title&#34;`                          //标题
    Content      string    `gorm:&#34;type:longtext&#34; form:&#34;content&#34; json:&#34;content&#34;` //内容
    Image        string    `gorm:&#34;type:text&#34; form:&#34;image&#34; json:&#34;image&#34;`         //首图
    Numb         int       `form:&#34;numb&#34; json:&#34;numb&#34;`                            //次数
    Flag         string    `form:&#34;flag&#34; json:&#34;flag&#34;`                            //原创或者转载
    Appreciation string    `form:&#34;appreciation&#34; json:&#34;appreciation&#34;`            //打赏开关
    ShareInfo    string    `form:&#34;shareInfo&#34; json:&#34;shareInfo&#34;`                  //版权开关
    Comment      string    `form:&#34;comment&#34; json:&#34;comment&#34;`                      //评论开关
    Recommend    string    `form:&#34;recommend&#34; json:&#34;recommend&#34;`                  //推荐开关
    Description  string    `gorm:&#34;type:text&#34; form:&#34;description&#34; json:&#34;description&#34;`
    CreatTime    string    `form:&#34;creatTime&#34;  json:&#34;creat_time,omitempty&#34;`   //创建时间
    UpdateTime   string    `form:&#34;updateTime&#34;  json:&#34;update_time,omitempty&#34;` //更新时间
    Comments     []Comment `form:&#34;comments&#34; json:&#34;comments&#34;`
    TypeId       int       `form:&#34;typeId&#34; json:&#34;typeId&#34;`
    Type         Type      `form:&#34;type&#34; gorm:&#34;ForeignKey:TypeId&#34;`
    Year         int       `form:&#34;year&#34; json:&#34;year&#34;`
    Month        int       `form:&#34;month&#34; json:&#34;month&#34;`
    Day          int       `form:&#34;day&#34; json:&#34;day&#34;`
}

</code></pre>

<h4>实现方法</h4>

<p>我的思路是创建三个时间节点
year month day
利用sql分组查询</p>

<h5>Group By分组查询步骤</h5>

<h6>（1）先按照年份查询</h6>

<h6>（2）再按照年份遍历每个月份</h6>

<p>并将所有保存在一个切片中</p>

<h6>（3）按照月份遍历每个月的所有文章</h6>

<p>保存在一个Map中，key是对应的月份，value是每个月份的所有文章</p>

<h4>自此归档功能实现</h4>

<h2>3.已知BUG</h2>

<h3>后台退出功能</h3>

<p>后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧</p>

<p>开源地址
<a href="https://github.com/likewl/blog" title="github" rel="nofollow">github</a>
<a href="https://gitee.com/nculike/blog" title="gitee" rel="nofollow">gitee</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 18:22:24][0m  [36;1m[0.50ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 18:22:47][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 18:22:47][0m  [36;1m[0.72ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 18:22:47][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 18:22:47][0m  [36;1m[0.31ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 18:22:47][0m  [36;1m[0.27ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 18:22:47][0m  [36;1m[0.32ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-21 18:31:35][0m  [36;1m[0.37ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 2)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-21 18:31:35][0m  [36;1m[0.44ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=2  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-21 18:31:35][0m  [36;1m[0.37ms][0m  UPDATE `blogs` SET `title` = '解决Linux关闭终端后运行的程序自动停止', `content` = '# 问题发现
  昨天博客发布，操作完关闭终端就睡了
  然而今天醒来突然发现终端不能访问了
  查看发现原来博客项目进程被杀死了
# 解决办法
    go build main.go
执行完后

    nohup ./main &
让程序在后台运行就可了


[========]
# ps:这个方法并不完美，因为我也是刚刚接触还不知道怎么切回来', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3696516981,3671280793&fm=26&gp=0.jpg', `numb` = 26, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '昨天博客发布，操作完关闭终端就睡了，然而今天醒来突然发现终端不能访问了，查看发现原来博客项目进程被杀死了', `creat_time` = '2020-07-19 19:05:36', `update_time` = '2020-07-19 19:05:36', `type_id` = 2, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 3  
[36;31m[1 rows affected or returned ][0m 
<h1>问题发现</h1>

<p>昨天博客发布，操作完关闭终端就睡了
  然而今天醒来突然发现终端不能访问了
  查看发现原来博客项目进程被杀死了</p>

<h1>解决办法</h1>

<pre><code>go build main.go
</code></pre>

<p>执行完后</p>

<pre><code>nohup ./main &amp;
</code></pre>

<p>让程序在后台运行就可了</p>

<p>[========]</p>

<h1>ps:这个方法并不完美，因为我也是刚刚接触还不知道怎么切回来</h1>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 18:31:35][0m  [36;1m[0.26ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 18:32:45][0m  [36;1m[0.53ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 18:32:45][0m  [36;1m[0.67ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 18:32:45][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 18:32:45][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 18:32:45][0m  [36;1m[0.24ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 18:32:45][0m  [36;1m[0.37ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 18:32:47][0m  [36;1m[0.53ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 18:32:47][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:144)[0m 
[33m[2020-07-21 18:32:47][0m  [36;1m[0.59ms][0m   SELECT * FROM `blogs` GROUP BY YEAR DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:157)[0m 
[33m[2020-07-21 18:32:47][0m  [36;1m[0.71ms][0m   SELECT * FROM `blogs` where year = 2020 GROUP BY month DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:169)[0m 
[33m[2020-07-21 18:32:47][0m  [36;1m[0.61ms][0m   SELECT * FROM `blogs` where year = 2020 and month = 7 ORDER BY `id` DESC  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 18:32:47][0m  [36;1m[0.37ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=4  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 18:32:47][0m  [36;1m[0.33ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=3  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 18:32:47][0m  [36;1m[0.34ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=2  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 18:32:47][0m  [36;1m[0.32ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 18:52:28][0m  [36;1m[0.53ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 18:54:28][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 18:54:28][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 18:54:28][0m  [36;1m[0.72ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 18:54:28][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 18:54:28][0m  [36;1m[0.31ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 18:54:28][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 18:54:28][0m  [36;1m[0.33ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 18:56:55][0m  [36;1m[0.61ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 18:56:55][0m  [36;1m[0.25ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:144)[0m 
[33m[2020-07-21 18:56:55][0m  [36;1m[0.64ms][0m   SELECT * FROM `blogs` GROUP BY YEAR DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:157)[0m 
[33m[2020-07-21 18:56:55][0m  [36;1m[0.68ms][0m   SELECT * FROM `blogs` where year = 2020 GROUP BY month DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:169)[0m 
[33m[2020-07-21 18:56:55][0m  [36;1m[0.61ms][0m   SELECT * FROM `blogs` where year = 2020 and month = 7 ORDER BY `id` DESC  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 18:56:55][0m  [36;1m[0.40ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=4  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 18:56:55][0m  [36;1m[0.33ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=3  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 18:56:55][0m  [36;1m[0.35ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=2  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 18:56:55][0m  [36;1m[0.33ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-21 18:56:57][0m  [36;1m[0.57ms][0m  SELECT * FROM `tags`    
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 18:56:57][0m  [36;1m[0.26ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 18:56:57][0m  [36;1m[0.72ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:31)[0m 
[33m[2020-07-21 18:56:57][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `tags`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 18:56:59][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 18:56:59][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:144)[0m 
[33m[2020-07-21 18:56:59][0m  [36;1m[0.63ms][0m   SELECT * FROM `blogs` GROUP BY YEAR DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:157)[0m 
[33m[2020-07-21 18:56:59][0m  [36;1m[0.69ms][0m   SELECT * FROM `blogs` where year = 2020 GROUP BY month DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:169)[0m 
[33m[2020-07-21 18:56:59][0m  [36;1m[0.65ms][0m   SELECT * FROM `blogs` where year = 2020 and month = 7 ORDER BY `id` DESC  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 18:56:59][0m  [36;1m[0.40ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=4  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 18:56:59][0m  [36;1m[0.34ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=3  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 18:56:59][0m  [36;1m[0.35ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=2  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-21 18:56:59][0m  [36;1m[0.33ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 18:56:59][0m  [36;1m[0.66ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 19:00:05][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 19:00:05][0m  [36;1m[0.74ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 19:00:05][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 19:00:05][0m  [36;1m[0.33ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 19:00:05][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 19:00:05][0m  [36;1m[0.33ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 19:58:39][0m  [36;1m[0.58ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 19:58:39][0m  [36;1m[0.90ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 19:58:39][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 19:58:39][0m  [36;1m[0.29ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 19:58:39][0m  [36;1m[0.29ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 19:58:39][0m  [36;1m[0.37ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 
2020/07/21 19:59:07 http: panic serving 196.52.43.58:53592: write tcp 172.16.13.169:80->196.52.43.58:53592: write: connection reset by peer
goroutine 7019 [running]:
net/http.(*conn).serve.func1(0xc0003b65a0)
	/usr/local/go/src/net/http/server.go:1772 +0x139
panic(0xb50ee0, 0xc0001da690)
	/usr/local/go/src/runtime/panic.go:975 +0x3e3
github.com/gin-gonic/gin.(*Context).Render(0xc0003f8f00, 0xc8, 0xd0e260, 0xc00065d590)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:842 +0x173
github.com/gin-gonic/gin.(*Context).HTML(0xc0003f8f00, 0xc8, 0xbf926d, 0x10, 0xb43d60, 0xc000342120)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:851 +0x99
blog/controller/page.IndexHandler(0xc0003f8f00)
	/usr/workspace/src/blog/controller/page/pagesController.go:22 +0x570
github.com/gin-gonic/gin.(*Context).Next(0xc0003f8f00)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:161 +0x3b
github.com/gin-contrib/sessions.Sessions.func1(0xc0003f8f00)
	/usr/workspace/pkg/mod/github.com/gin-contrib/sessions@v0.0.3/sessions.go:52 +0x16d
github.com/gin-gonic/gin.(*Context).Next(0xc0003f8f00)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:161 +0x3b
github.com/gin-gonic/gin.(*Engine).handleHTTPRequest(0xc0003b8500, 0xc0003f8f00)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/gin.go:409 +0x666
github.com/gin-gonic/gin.(*Engine).ServeHTTP(0xc0003b8500, 0xd12a40, 0xc0000b80e0, 0xc0003ca000)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/gin.go:367 +0x14d
net/http.serverHandler.ServeHTTP(0xc0000b8380, 0xd12a40, 0xc0000b80e0, 0xc0003ca000)
	/usr/local/go/src/net/http/server.go:2807 +0xa3
net/http.(*conn).serve(0xc0003b65a0, 0xd15200, 0xc000622000)
	/usr/local/go/src/net/http/server.go:1895 +0x86c
created by net/http.(*Server).Serve
	/usr/local/go/src/net/http/server.go:2933 +0x35c

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 20:16:28][0m  [36;1m[0.57ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 20:16:28][0m  [36;1m[0.73ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 20:16:28][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 20:16:28][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 20:16:28][0m  [36;1m[0.30ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 20:16:28][0m  [36;1m[0.31ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 20:27:28][0m  [36;1m[0.52ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 20:27:28][0m  [36;1m[0.71ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 20:27:28][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 20:27:28][0m  [36;1m[0.31ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 20:27:28][0m  [36;1m[0.28ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 20:27:28][0m  [36;1m[0.31ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 20:43:30][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 20:43:30][0m  [36;1m[0.69ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 20:43:30][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 20:43:30][0m  [36;1m[0.32ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 20:43:30][0m  [36;1m[0.27ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 20:43:30][0m  [36;1m[0.33ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 20:47:56][0m  [36;1m[0.53ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 20:47:56][0m  [36;1m[0.71ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 20:47:56][0m  [36;1m[0.22ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 20:47:56][0m  [36;1m[0.32ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 20:47:56][0m  [36;1m[0.28ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 20:47:56][0m  [36;1m[0.33ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 21:07:54][0m  [36;1m[0.58ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 21:07:54][0m  [36;1m[0.69ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 21:07:54][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 21:07:54][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 21:07:54][0m  [36;1m[0.27ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 21:07:54][0m  [36;1m[0.32ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 21:13:58][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 21:14:38][0m  [36;1m[0.53ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-21 21:38:41][0m  [36;1m[0.39ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 2)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-21 21:38:41][0m  [36;1m[0.54ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=2  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-21 21:38:41][0m  [36;1m[0.38ms][0m  UPDATE `blogs` SET `title` = '解决Linux关闭终端后运行的程序自动停止', `content` = '# 问题发现
  昨天博客发布，操作完关闭终端就睡了
  然而今天醒来突然发现终端不能访问了
  查看发现原来博客项目进程被杀死了
# 解决办法
    go build main.go
执行完后

    nohup ./main &
让程序在后台运行就可了


[========]
# ps:这个方法并不完美，因为我也是刚刚接触还不知道怎么切回来', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3696516981,3671280793&fm=26&gp=0.jpg', `numb` = 27, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '昨天博客发布，操作完关闭终端就睡了，然而今天醒来突然发现终端不能访问了，查看发现原来博客项目进程被杀死了', `creat_time` = '2020-07-19 19:05:36', `update_time` = '2020-07-19 19:05:36', `type_id` = 2, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 3  
[36;31m[1 rows affected or returned ][0m 
<h1>问题发现</h1>

<p>昨天博客发布，操作完关闭终端就睡了
  然而今天醒来突然发现终端不能访问了
  查看发现原来博客项目进程被杀死了</p>

<h1>解决办法</h1>

<pre><code>go build main.go
</code></pre>

<p>执行完后</p>

<pre><code>nohup ./main &amp;
</code></pre>

<p>让程序在后台运行就可了</p>

<p>[========]</p>

<h1>ps:这个方法并不完美，因为我也是刚刚接触还不知道怎么切回来</h1>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 21:38:41][0m  [36;1m[0.41ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-21 21:38:45][0m  [36;1m[0.45ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 1)  
[36;31m[2 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-21 21:38:45][0m  [36;1m[0.45ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=1  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-21 21:38:45][0m  [36;1m[0.42ms][0m  UPDATE `blogs` SET `title` = 'golang项目简单服务器部署到阿里云(linux)', `content` = '# 我个人比较推荐使用Xftp和Xshell 
# 重要是个人免费用
# 舒服又好用

# 1.下载安装go安装包：
	## （1）go语言下载地址：
	[Go语言中文网](https://studygolang.com/dl "Go语言中文网")
下载linux版本的安装包。

## （2）使用Xftp将安装包上传至指定的路径：

![](https://img-blog.csdnimg.cn/20190719142701389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
	这里上传到root目录下就行
	方便解压
## （3）解压并移到/usr/local/下：

进入指定目录，查看已有文件并且解压文件：

![](https://img-blog.csdnimg.cn/20190719143211340.png)
```
#在root目录输入ls查看目录文件
ls
#在root解压go包
tar -zxvf go的包名
```

解压完成后发现目录下多了一个go文件夹：
![](https://img-blog.csdnimg.cn/20190719143042938.png)
将文件夹移动到/usr/local/
![](https://img-blog.csdnimg.cn/20190719143137645.png)
# 2.配置环境变量：
## （1）进入目的目录查看go文件夹是否移动成功：
![](https://img-blog.csdnimg.cn/20190719143506382.png)
## （2）在usr下创建文件夹，用来存放自己的项目：
workspace
## （3）进入新建的目录workspace新建三个文件夹：
src
pkg
bin
### 说明：

	src 目录存放的是我们的go源代码，不同工程项目的代码以包名区分
	pkg 编译后生成的文件
	bin文件夹存放go install命名生成的可执行文件（这个文件夹会配置到环境变量中）
## （4）配置环境变量：

进入 /etc 修改profile文件：
![](https://img-blog.csdnimg.cn/20190719144319621.png)
```
#进入etc目录
cd /etc/
#配置 profile
vim profile
```
![](https://img-blog.csdnimg.cn/20190719145650864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
在此文件夹下加入上图的代码，代码如下：
```
// 设置go安装路径
export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin
 
// 设置工程目录
export GOPATH=/usr/workspace
export PATH=$PATH:$GOPATH/bin
```

## （5）刷新环境变量：
```
source /etc/profile
```
##  （6）查看go环境是否配置成功：
```
go version
```
## （7）查看详细配置：
```
go env
```
结果如下：  
![](https://img-blog.csdnimg.cn/20190719145255720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70) 
# 3.上传项目代码：
在刚刚创建的workspace下新创建的三个文件夹中，src 目录存放的是我们的go源代码
# 4运行
```go
go build main.go
//或者
go run main.go
```
最后执行 ./main 就行了。
如果想让项目在后台执行：执行 nohup ./main & ，这样就可以程序在后台运行了。

参考教程https://blog.csdn.net/qq_42410605/article/details/96479892', `image` = 'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3111860246,1925938903&fm=26&gp=0.jpg', `numb` = 45, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '简单又详细的教程', `creat_time` = '2020-07-19 18:32:31', `update_time` = '2020-07-20 13:11:56', `type_id` = 1, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 1  
[36;31m[1 rows affected or returned ][0m 
<h1>我个人比较推荐使用Xftp和Xshell</h1>

<h1>重要是个人免费用</h1>

<h1>舒服又好用</h1>

<h1>1.下载安装go安装包：</h1>

<pre><code>## （1）go语言下载地址：
[Go语言中文网](https://studygolang.com/dl &#34;Go语言中文网&#34;)
</code></pre>

<p>下载linux版本的安装包。</p>

<h2>（2）使用Xftp将安装包上传至指定的路径：</h2>

<p><img src="https://img-blog.csdnimg.cn/20190719142701389.png?x-oss-process=image%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1%2Csize_16%2Ccolor_FFFFFF%2Ct_70" alt=""/>
    这里上传到root目录下就行
    方便解压</p>

<h2>（3）解压并移到/usr/local/下：</h2>

<p>进入指定目录，查看已有文件并且解压文件：</p>

<p><img src="https://img-blog.csdnimg.cn/20190719143211340.png" alt=""/></p>

<pre><code>#在root目录输入ls查看目录文件
ls
#在root解压go包
tar -zxvf go的包名
</code></pre>

<p>解压完成后发现目录下多了一个go文件夹：
<img src="https://img-blog.csdnimg.cn/20190719143042938.png" alt=""/>
将文件夹移动到/usr/local/
<img src="https://img-blog.csdnimg.cn/20190719143137645.png" alt=""/></p>

<h1>2.配置环境变量：</h1>

<h2>（1）进入目的目录查看go文件夹是否移动成功：</h2>

<p><img src="https://img-blog.csdnimg.cn/20190719143506382.png" alt=""/></p>

<h2>（2）在usr下创建文件夹，用来存放自己的项目：</h2>

<p>workspace</p>

<h2>（3）进入新建的目录workspace新建三个文件夹：</h2>

<p>src
pkg
bin</p>

<h3>说明：</h3>

<pre><code>src 目录存放的是我们的go源代码，不同工程项目的代码以包名区分
pkg 编译后生成的文件
bin文件夹存放go install命名生成的可执行文件（这个文件夹会配置到环境变量中）
</code></pre>

<h2>（4）配置环境变量：</h2>

<p>进入 /etc 修改profile文件：
<img src="https://img-blog.csdnimg.cn/20190719144319621.png" alt=""/></p>

<pre><code>#进入etc目录
cd /etc/
#配置 profile
vim profile
</code></pre>

<p><img src="https://img-blog.csdnimg.cn/20190719145650864.png?x-oss-process=image%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1%2Csize_16%2Ccolor_FFFFFF%2Ct_70" alt=""/>
在此文件夹下加入上图的代码，代码如下：</p>

<pre><code>// 设置go安装路径
export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin
 
// 设置工程目录
export GOPATH=/usr/workspace
export PATH=$PATH:$GOPATH/bin
</code></pre>

<h2>（5）刷新环境变量：</h2>

<pre><code>source /etc/profile
</code></pre>

<h2> （6）查看go环境是否配置成功：</h2>

<pre><code>go version
</code></pre>

<h2>（7）查看详细配置：</h2>

<pre><code>go env
</code></pre>

<p>结果如下：  
<img src="https://img-blog.csdnimg.cn/20190719145255720.png?x-oss-process=image%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1%2Csize_16%2Ccolor_FFFFFF%2Ct_70" alt=""/> </p>

<h1>3.上传项目代码：</h1>

<p>在刚刚创建的workspace下新创建的三个文件夹中，src 目录存放的是我们的go源代码</p>

<h1>4运行</h1>

<pre><code class="language-go">go build main.go
//或者
go run main.go
</code></pre>

<p>最后执行 ./main 就行了。
如果想让项目在后台执行：执行 nohup ./main &amp; ，这样就可以程序在后台运行了。</p>

<p>参考教程<a href="https://blog.csdn.net/qq_42410605/article/details/96479892" rel="nofollow">https://blog.csdn.net/qq_42410605/article/details/96479892</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 21:38:45][0m  [36;1m[0.26ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-21 21:38:45][0m  [36;1m[1.89ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 1)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-21 21:38:45][0m  [36;1m[0.35ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 2)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-21 21:38:45][0m  [36;1m[0.30ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 4)  
[36;31m[0 rows affected or returned ][0m 
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-21 21:38:45][0m  [36;1m[0.34ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 3)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-21 21:38:45][0m  [36;1m[0.31ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 5)  
[36;31m[0 rows affected or returned ][0m 
[{5 1 3 like 狗科 535889315@qq.com /static/images/header.jpg ？？？ 2020-07-20 13:30:17 <nil> []}]
[{5 1 3 like 狗科 535889315@qq.com /static/images/header.jpg ？？？ 2020-07-20 13:30:17 <nil> []}]

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 21:43:48][0m  [36;1m[0.56ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 21:43:48][0m  [36;1m[0.69ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 21:43:48][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 21:43:48][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 21:43:48][0m  [36;1m[0.24ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 21:43:48][0m  [36;1m[0.32ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 22:29:32][0m  [36;1m[0.56ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 22:29:32][0m  [36;1m[0.69ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 22:29:32][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 22:29:32][0m  [36;1m[0.33ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 22:29:32][0m  [36;1m[0.28ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 22:29:32][0m  [36;1m[0.32ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-21 22:29:34][0m  [36;1m[0.43ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 2)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-21 22:29:34][0m  [36;1m[0.55ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=2  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-21 22:29:34][0m  [36;1m[0.41ms][0m  UPDATE `blogs` SET `title` = '解决Linux关闭终端后运行的程序自动停止', `content` = '# 问题发现
  昨天博客发布，操作完关闭终端就睡了
  然而今天醒来突然发现终端不能访问了
  查看发现原来博客项目进程被杀死了
# 解决办法
    go build main.go
执行完后

    nohup ./main &
让程序在后台运行就可了


[========]
# ps:这个方法并不完美，因为我也是刚刚接触还不知道怎么切回来', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3696516981,3671280793&fm=26&gp=0.jpg', `numb` = 28, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '昨天博客发布，操作完关闭终端就睡了，然而今天醒来突然发现终端不能访问了，查看发现原来博客项目进程被杀死了', `creat_time` = '2020-07-19 19:05:36', `update_time` = '2020-07-19 19:05:36', `type_id` = 2, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 3  
[36;31m[1 rows affected or returned ][0m 
<h1>问题发现</h1>

<p>昨天博客发布，操作完关闭终端就睡了
  然而今天醒来突然发现终端不能访问了
  查看发现原来博客项目进程被杀死了</p>

<h1>解决办法</h1>

<pre><code>go build main.go
</code></pre>

<p>执行完后</p>

<pre><code>nohup ./main &amp;
</code></pre>

<p>让程序在后台运行就可了</p>

<p>[========]</p>

<h1>ps:这个方法并不完美，因为我也是刚刚接触还不知道怎么切回来</h1>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 22:29:34][0m  [36;1m[0.34ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 23:07:53][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 23:07:53][0m  [36;1m[0.72ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 23:07:53][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 23:07:53][0m  [36;1m[0.31ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 23:07:53][0m  [36;1m[0.27ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 23:07:53][0m  [36;1m[0.38ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 23:08:26][0m  [36;1m[0.52ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-21 23:08:26][0m  [36;1m[0.72ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-21 23:08:26][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-21 23:08:26][0m  [36;1m[0.32ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-21 23:08:26][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-21 23:08:26][0m  [36;1m[0.32ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-21 23:40:37][0m  [36;1m[0.58ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 00:05:51][0m  [36;1m[0.59ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 00:05:51][0m  [36;1m[0.75ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 00:05:51][0m  [36;1m[0.22ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-22 00:05:51][0m  [36;1m[0.34ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-22 00:05:51][0m  [36;1m[0.30ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-22 00:05:51][0m  [36;1m[0.38ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 00:05:53][0m  [36;1m[0.53ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 00:05:53][0m  [36;1m[0.80ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 00:05:53][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-22 00:05:53][0m  [36;1m[0.29ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-22 00:05:53][0m  [36;1m[0.25ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-22 00:05:53][0m  [36;1m[0.33ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 01:09:27][0m  [36;1m[0.57ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 01:09:27][0m  [36;1m[0.71ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 01:09:27][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-22 01:09:27][0m  [36;1m[0.32ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-22 01:09:27][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-22 01:09:27][0m  [36;1m[0.35ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 01:13:08][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 01:13:08][0m  [36;1m[0.76ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 01:13:08][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-22 01:13:08][0m  [36;1m[0.29ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-22 01:13:08][0m  [36;1m[0.25ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-22 01:13:08][0m  [36;1m[0.34ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-22 01:13:12][0m  [36;1m[0.40ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 4)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-22 01:13:12][0m  [36;1m[0.42ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=4  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-22 01:13:12][0m  [36;1m[0.43ms][0m  UPDATE `blogs` SET `title` = '本博客开源公告', `content` = '今天本博客评论功能发布
# 自今天起，本博客基本功能已经完成
## 发布V1.0版本并开源
## 博客语言说明
#### 本博客后端是用golang 的gin框架+gorm编写
前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的
#### 博客效果参考本站
#一、博客简介
## 1.博客目录

    blog
    ├────controller
	├────└───admin
	|	|	├──adminblog.go
	|	|	├───adminController.go
	|	|	├──adminTag.go
	|	|	├──adminType.go
	|	|	└──adminUser.go
	|	└──page
	|		├──404.go
	|		├───about.go
	|		├──archives.go
	|		├──blog.go
	|		├──comment.go
	|		├──pagesController.go
	|		├──researchController.go
	|		└──tagsController.go
    ├── dao
	│	├──blogs.go
	│	├──comment.go
	│	├──sql.go
	│	├──tags.go
	│	├──types.go
	│	└──user.go
    ├── logic
    │   └── user.go
    ├── middlerware
	│	├──function.go
	│	├──getImg.go
	│	├──getTime.go
	│	├──markdown.go
	│	├──select.go
	│	└──session.go
    ├── model
	│	├──blog.go
	│	├──commnent.go
	│	├──tag.go
	│	├──type.go
	│	└──user/go
    ├── static
	│	└──静态文件（头像、图片、logo、css、js等）
    ├── templates
	│	└──html模板文件
    ├── go.mod（依赖）
    └── main.go
    

## 2.相关功能实现简介
### 1、评论及回复功能
comment的结构体属性如下
```go
package model

type Comment struct {
	Id     int //评论id
	BlogId int //博文id
	ReCommentId    int    //父评论id
	CommentName string //评论人姓名
	ReCommentName  string //父评论人姓名
	CommentEmail   string
	Img            string
	CommentContent string `gorm:"type:text" form:"CommentContent" json:"CommentContent"` //评论内容
	CommentTime    string ` json:"comment_time,omitempty"`
	Parent         *Comment
	Comments       []Comment
}
```
#### 实现方法
##### 1先通过查找父评论为-1的顶级评论
父评论Id为-1说明他不是任何评论的子评论
##### 2在html上遍历所有的顶级评论
在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论
###### （1）递归存储每个顶级评论的子评论
这里我用一个切片来储存一个顶级评论的所有子评论
```go
var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
	var comments []model.Comment
	DB.Debug().Where("re_comment_id = -1 AND blog_id = ?", id).Find(&comments)
	return &comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
	if count != 0 {
		fmt.Println("if判断1")
		var comments []model.Comment
		DB.Debug().Where("re_comment_id = ?", id).Find(&comments)
		count = len(comments)
		if count != 0 {
			fmt.Println("if判断2")
			for _, comment := range comments {
				fmt.Println("for判断1")
				Comments = append(Comments, comment)
				SelectCommentByComment(comment.Id, count)
			}
		}
	}
	fmt.Println(Comments)
	return &Comments

}
```
ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来
###### （2）出现问题的原因
因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量
###### （3）解决问题
```go
func ClearComments() bool {
	var comments []model.Comment
	Comments = comments
	return true
}

```
这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现
#### 这里我还加了一个小小的随机头像功能
```go
if  CommentName == user.Name && CommentEmail == user.UserEmail {
		fmt.Println("进入了1")
		comment.Img =user.UserImg
		//找相同评论人
	}else if CommentName == one.CommentName && CommentEmail == one.CommentEmail {
		fmt.Println("进入了2")
		comment.Img =one.Img
		//随机选头像
	}else{
		fmt.Println("进入了3")
		comment.Img =middleware.GetImg()
	}
```
##### 123分别代表三种不同的用户群体
1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
![](/static/images/%e5%a4%b4%e5%83%8f1.png)![](/static/images/%e5%a4%b4%e5%83%8f2.png)![](/static/images/%e5%a4%b4%e5%83%8f3.png)![](/static/images/%e5%a4%b4%e5%83%8f4.png)![](/static/images/%e5%a4%b4%e5%83%8f5.png)![](/static/images/%e5%a4%b4%e5%83%8f6.png)
### 2、归档功能
#### blog的结构体属性如下
```go
package model

type Blog struct {
	Id           int
	Title        string    `form:"title" json:"title"`                          //标题
	Content      string    `gorm:"type:longtext" form:"content" json:"content"` //内容
	Image        string    `gorm:"type:text" form:"image" json:"image"`         //首图
	Numb         int       `form:"numb" json:"numb"`                            //次数
	Flag         string    `form:"flag" json:"flag"`                            //原创或者转载
	Appreciation string    `form:"appreciation" json:"appreciation"`            //打赏开关
	ShareInfo    string    `form:"shareInfo" json:"shareInfo"`                  //版权开关
	Comment      string    `form:"comment" json:"comment"`                      //评论开关
	Recommend    string    `form:"recommend" json:"recommend"`                  //推荐开关
	Description  string    `gorm:"type:text" form:"description" json:"description"`
	CreatTime    string    `form:"creatTime"  json:"creat_time,omitempty"`   //创建时间
	UpdateTime   string    `form:"updateTime"  json:"update_time,omitempty"` //更新时间
	Comments     []Comment `form:"comments" json:"comments"`
	TypeId       int       `form:"typeId" json:"typeId"`
	Type         Type      `form:"type" gorm:"ForeignKey:TypeId"`
	Year         int       `form:"year" json:"year"`
	Month        int       `form:"month" json:"month"`
	Day          int       `form:"day" json:"day"`
}

```
#### 实现方法
我的思路是创建三个时间节点
year month day 
利用sql分组查询
##### Group By分组查询步骤
###### （1）先按照年份查询
###### （2）再按照年份遍历每个月份
并将所有保存在一个切片中
###### （3）按照月份遍历每个月的所有文章
保存在一个Map中，key是对应的月份，value是每个月份的所有文章
#### 自此归档功能实现


## 3.已知BUG
### 后台退出功能
后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧

开源地址
[github](https://github.com/likewl/blog "github")
[gitee](https://gitee.com/nculike/blog "gitee")', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1535821573,4166447487&fm=26&gp=0.jpg', `numb` = 52, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '本博客后端是用golang 的gin框架+gorm编写', `creat_time` = '2020-07-20 15:24:23', `update_time` = '2020-07-20 15:24:23', `type_id` = 4, `year` = 2020, `month` = 7, `day` = 20  WHERE `blogs`.`id` = 4  
[36;31m[1 rows affected or returned ][0m 
<p>今天本博客评论功能发布</p>

<h1>自今天起，本博客基本功能已经完成</h1>

<h2>发布V1.0版本并开源</h2>

<h2>博客语言说明</h2>

<h4>本博客后端是用golang 的gin框架+gorm编写</h4>

<p>前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的</p>

<h4>博客效果参考本站</h4>

<p>#一、博客简介</p>

<h2>1.博客目录</h2>

<pre><code>blog
├────controller
├────└───admin
|   |   ├──adminblog.go
|   |   ├───adminController.go
|   |   ├──adminTag.go
|   |   ├──adminType.go
|   |   └──adminUser.go
|   └──page
|       ├──404.go
|       ├───about.go
|       ├──archives.go
|       ├──blog.go
|       ├──comment.go
|       ├──pagesController.go
|       ├──researchController.go
|       └──tagsController.go
├── dao
│   ├──blogs.go
│   ├──comment.go
│   ├──sql.go
│   ├──tags.go
│   ├──types.go
│   └──user.go
├── logic
│   └── user.go
├── middlerware
│   ├──function.go
│   ├──getImg.go
│   ├──getTime.go
│   ├──markdown.go
│   ├──select.go
│   └──session.go
├── model
│   ├──blog.go
│   ├──commnent.go
│   ├──tag.go
│   ├──type.go
│   └──user/go
├── static
│   └──静态文件（头像、图片、logo、css、js等）
├── templates
│   └──html模板文件
├── go.mod（依赖）
└── main.go
</code></pre>

<h2>2.相关功能实现简介</h2>

<h3>1、评论及回复功能</h3>

<p>comment的结构体属性如下</p>

<pre><code class="language-go">package model

type Comment struct {
    Id     int //评论id
    BlogId int //博文id
    ReCommentId    int    //父评论id
    CommentName string //评论人姓名
    ReCommentName  string //父评论人姓名
    CommentEmail   string
    Img            string
    CommentContent string `gorm:&#34;type:text&#34; form:&#34;CommentContent&#34; json:&#34;CommentContent&#34;` //评论内容
    CommentTime    string ` json:&#34;comment_time,omitempty&#34;`
    Parent         *Comment
    Comments       []Comment
}
</code></pre>

<h4>实现方法</h4>

<h5>1先通过查找父评论为-1的顶级评论</h5>

<p>父评论Id为-1说明他不是任何评论的子评论</p>

<h5>2在html上遍历所有的顶级评论</h5>

<p>在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论</p>

<h6>（1）递归存储每个顶级评论的子评论</h6>

<p>这里我用一个切片来储存一个顶级评论的所有子评论</p>

<pre><code class="language-go">var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
    var comments []model.Comment
    DB.Debug().Where(&#34;re_comment_id = -1 AND blog_id = ?&#34;, id).Find(&amp;comments)
    return &amp;comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
    if count != 0 {
        fmt.Println(&#34;if判断1&#34;)
        var comments []model.Comment
        DB.Debug().Where(&#34;re_comment_id = ?&#34;, id).Find(&amp;comments)
        count = len(comments)
        if count != 0 {
            fmt.Println(&#34;if判断2&#34;)
            for _, comment := range comments {
                fmt.Println(&#34;for判断1&#34;)
                Comments = append(Comments, comment)
                SelectCommentByComment(comment.Id, count)
            }
        }
    }
    fmt.Println(Comments)
    return &amp;Comments

}
</code></pre>

<p>ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来</p>

<h6>（2）出现问题的原因</h6>

<p>因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量</p>

<h6>（3）解决问题</h6>

<pre><code class="language-go">func ClearComments() bool {
    var comments []model.Comment
    Comments = comments
    return true
}

</code></pre>

<p>这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现</p>

<h4>这里我还加了一个小小的随机头像功能</h4>

<pre><code class="language-go">if  CommentName == user.Name &amp;&amp; CommentEmail == user.UserEmail {
        fmt.Println(&#34;进入了1&#34;)
        comment.Img =user.UserImg
        //找相同评论人
    }else if CommentName == one.CommentName &amp;&amp; CommentEmail == one.CommentEmail {
        fmt.Println(&#34;进入了2&#34;)
        comment.Img =one.Img
        //随机选头像
    }else{
        fmt.Println(&#34;进入了3&#34;)
        comment.Img =middleware.GetImg()
    }
</code></pre>

<h5>123分别代表三种不同的用户群体</h5>

<p>1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
<img src="/static/images/%e5%a4%b4%e5%83%8f1.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f2.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f3.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f4.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f5.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f6.png" alt=""/></p>

<h3>2、归档功能</h3>

<h4>blog的结构体属性如下</h4>

<pre><code class="language-go">package model

type Blog struct {
    Id           int
    Title        string    `form:&#34;title&#34; json:&#34;title&#34;`                          //标题
    Content      string    `gorm:&#34;type:longtext&#34; form:&#34;content&#34; json:&#34;content&#34;` //内容
    Image        string    `gorm:&#34;type:text&#34; form:&#34;image&#34; json:&#34;image&#34;`         //首图
    Numb         int       `form:&#34;numb&#34; json:&#34;numb&#34;`                            //次数
    Flag         string    `form:&#34;flag&#34; json:&#34;flag&#34;`                            //原创或者转载
    Appreciation string    `form:&#34;appreciation&#34; json:&#34;appreciation&#34;`            //打赏开关
    ShareInfo    string    `form:&#34;shareInfo&#34; json:&#34;shareInfo&#34;`                  //版权开关
    Comment      string    `form:&#34;comment&#34; json:&#34;comment&#34;`                      //评论开关
    Recommend    string    `form:&#34;recommend&#34; json:&#34;recommend&#34;`                  //推荐开关
    Description  string    `gorm:&#34;type:text&#34; form:&#34;description&#34; json:&#34;description&#34;`
    CreatTime    string    `form:&#34;creatTime&#34;  json:&#34;creat_time,omitempty&#34;`   //创建时间
    UpdateTime   string    `form:&#34;updateTime&#34;  json:&#34;update_time,omitempty&#34;` //更新时间
    Comments     []Comment `form:&#34;comments&#34; json:&#34;comments&#34;`
    TypeId       int       `form:&#34;typeId&#34; json:&#34;typeId&#34;`
    Type         Type      `form:&#34;type&#34; gorm:&#34;ForeignKey:TypeId&#34;`
    Year         int       `form:&#34;year&#34; json:&#34;year&#34;`
    Month        int       `form:&#34;month&#34; json:&#34;month&#34;`
    Day          int       `form:&#34;day&#34; json:&#34;day&#34;`
}

</code></pre>

<h4>实现方法</h4>

<p>我的思路是创建三个时间节点
year month day
利用sql分组查询</p>

<h5>Group By分组查询步骤</h5>

<h6>（1）先按照年份查询</h6>

<h6>（2）再按照年份遍历每个月份</h6>

<p>并将所有保存在一个切片中</p>

<h6>（3）按照月份遍历每个月的所有文章</h6>

<p>保存在一个Map中，key是对应的月份，value是每个月份的所有文章</p>

<h4>自此归档功能实现</h4>

<h2>3.已知BUG</h2>

<h3>后台退出功能</h3>

<p>后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧</p>

<p>开源地址
<a href="https://github.com/likewl/blog" title="github" rel="nofollow">github</a>
<a href="https://gitee.com/nculike/blog" title="gitee" rel="nofollow">gitee</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 01:13:12][0m  [36;1m[0.27ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 01:13:38][0m  [36;1m[0.58ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 01:13:38][0m  [36;1m[0.69ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 01:13:38][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-22 01:13:38][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-22 01:13:39][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-22 01:13:39][0m  [36;1m[0.31ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 01:13:42][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 01:13:42][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:144)[0m 
[33m[2020-07-22 01:13:42][0m  [36;1m[0.58ms][0m   SELECT * FROM `blogs` GROUP BY YEAR DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:157)[0m 
[33m[2020-07-22 01:13:42][0m  [36;1m[0.65ms][0m   SELECT * FROM `blogs` where year = 2020 GROUP BY month DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:169)[0m 
[33m[2020-07-22 01:13:42][0m  [36;1m[0.60ms][0m   SELECT * FROM `blogs` where year = 2020 and month = 7 ORDER BY `id` DESC  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-22 01:13:42][0m  [36;1m[0.37ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=4  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-22 01:13:42][0m  [36;1m[0.34ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=3  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-22 01:13:42][0m  [36;1m[0.33ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=2  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-22 01:13:42][0m  [36;1m[0.31ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-22 01:13:48][0m  [36;1m[0.41ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 3)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-22 01:13:48][0m  [36;1m[0.46ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=3  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-22 01:13:48][0m  [36;1m[0.43ms][0m  UPDATE `blogs` SET `title` = 'mysql5.7 查询数据，group by 报错：Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 't.id' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by？', `content` = '在做归档功能时用到了分组查询
结果出现了这样的错误
```
Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 't.id' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by

```
查询才知道
mysql 5.7 加入的新特性，only_full_group_by，它只允许你的查询字段是包括在 group by 里面的字段，这种模式导致无法我们无法得到想要的字段值，我们可以禁用掉 only_full_group_by：
### 第一步：
```
select @@GLOBAL.sql_mode;
```
得到现有的 sql_mode, 如下：
```
ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION

```
### 第二步：
```
set global sql_mode ='STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION';

set session sql_mode= 'STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION';
```
去除 ONLY_FULL_GROUP_BY，重新设置，就 ok 了。', `image` = 'https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2507389442,2201469096&fm=26&gp=0.jpg', `numb` = 23, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '在做归档功能时用到了分组查询，结果出现了这样的错误，原来是mysql57的新功能
', `creat_time` = '2020-07-19 18:58:22', `update_time` = '2020-07-19 18:59:30', `type_id` = 3, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 2  
[36;31m[1 rows affected or returned ][0m 
<p>在做归档功能时用到了分组查询
结果出现了这样的错误</p>

<pre><code>Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column &#39;t.id&#39; which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by

</code></pre>

<p>查询才知道
mysql 5.7 加入的新特性，only_full_group_by，它只允许你的查询字段是包括在 group by 里面的字段，这种模式导致无法我们无法得到想要的字段值，我们可以禁用掉 only_full_group_by：</p>

<h3>第一步：</h3>

<pre><code>select @@GLOBAL.sql_mode;
</code></pre>

<p>得到现有的 sql_mode, 如下：</p>

<pre><code>ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION

</code></pre>

<h3>第二步：</h3>

<pre><code>set global sql_mode =&#39;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&#39;;

set session sql_mode= &#39;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&#39;;
</code></pre>

<p>去除 ONLY_FULL_GROUP_BY，重新设置，就 ok 了。</p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 01:13:48][0m  [36;1m[0.27ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 01:14:24][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 01:14:24][0m  [36;1m[0.70ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 01:14:24][0m  [36;1m[0.23ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-22 01:14:24][0m  [36;1m[0.32ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-22 01:14:24][0m  [36;1m[0.28ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-22 01:14:24][0m  [36;1m[0.39ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-22 01:14:33][0m  [36;1m[0.47ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 1)  
[36;31m[2 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-22 01:14:33][0m  [36;1m[0.46ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=1  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-22 01:14:33][0m  [36;1m[0.38ms][0m  UPDATE `blogs` SET `title` = 'golang项目简单服务器部署到阿里云(linux)', `content` = '# 我个人比较推荐使用Xftp和Xshell 
# 重要是个人免费用
# 舒服又好用

# 1.下载安装go安装包：
	## （1）go语言下载地址：
	[Go语言中文网](https://studygolang.com/dl "Go语言中文网")
下载linux版本的安装包。

## （2）使用Xftp将安装包上传至指定的路径：

![](https://img-blog.csdnimg.cn/20190719142701389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
	这里上传到root目录下就行
	方便解压
## （3）解压并移到/usr/local/下：

进入指定目录，查看已有文件并且解压文件：

![](https://img-blog.csdnimg.cn/20190719143211340.png)
```
#在root目录输入ls查看目录文件
ls
#在root解压go包
tar -zxvf go的包名
```

解压完成后发现目录下多了一个go文件夹：
![](https://img-blog.csdnimg.cn/20190719143042938.png)
将文件夹移动到/usr/local/
![](https://img-blog.csdnimg.cn/20190719143137645.png)
# 2.配置环境变量：
## （1）进入目的目录查看go文件夹是否移动成功：
![](https://img-blog.csdnimg.cn/20190719143506382.png)
## （2）在usr下创建文件夹，用来存放自己的项目：
workspace
## （3）进入新建的目录workspace新建三个文件夹：
src
pkg
bin
### 说明：

	src 目录存放的是我们的go源代码，不同工程项目的代码以包名区分
	pkg 编译后生成的文件
	bin文件夹存放go install命名生成的可执行文件（这个文件夹会配置到环境变量中）
## （4）配置环境变量：

进入 /etc 修改profile文件：
![](https://img-blog.csdnimg.cn/20190719144319621.png)
```
#进入etc目录
cd /etc/
#配置 profile
vim profile
```
![](https://img-blog.csdnimg.cn/20190719145650864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
在此文件夹下加入上图的代码，代码如下：
```
// 设置go安装路径
export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin
 
// 设置工程目录
export GOPATH=/usr/workspace
export PATH=$PATH:$GOPATH/bin
```

## （5）刷新环境变量：
```
source /etc/profile
```
##  （6）查看go环境是否配置成功：
```
go version
```
## （7）查看详细配置：
```
go env
```
结果如下：  
![](https://img-blog.csdnimg.cn/20190719145255720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70) 
# 3.上传项目代码：
在刚刚创建的workspace下新创建的三个文件夹中，src 目录存放的是我们的go源代码
# 4运行
```go
go build main.go
//或者
go run main.go
```
最后执行 ./main 就行了。
如果想让项目在后台执行：执行 nohup ./main & ，这样就可以程序在后台运行了。

参考教程https://blog.csdn.net/qq_42410605/article/details/96479892', `image` = 'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3111860246,1925938903&fm=26&gp=0.jpg', `numb` = 46, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '简单又详细的教程', `creat_time` = '2020-07-19 18:32:31', `update_time` = '2020-07-20 13:11:56', `type_id` = 1, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 1  
[36;31m[1 rows affected or returned ][0m 
<h1>我个人比较推荐使用Xftp和Xshell</h1>

<h1>重要是个人免费用</h1>

<h1>舒服又好用</h1>

<h1>1.下载安装go安装包：</h1>

<pre><code>## （1）go语言下载地址：
[Go语言中文网](https://studygolang.com/dl &#34;Go语言中文网&#34;)
</code></pre>

<p>下载linux版本的安装包。</p>

<h2>（2）使用Xftp将安装包上传至指定的路径：</h2>

<p><img src="https://img-blog.csdnimg.cn/20190719142701389.png?x-oss-process=image%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1%2Csize_16%2Ccolor_FFFFFF%2Ct_70" alt=""/>
    这里上传到root目录下就行
    方便解压</p>

<h2>（3）解压并移到/usr/local/下：</h2>

<p>进入指定目录，查看已有文件并且解压文件：</p>

<p><img src="https://img-blog.csdnimg.cn/20190719143211340.png" alt=""/></p>

<pre><code>#在root目录输入ls查看目录文件
ls
#在root解压go包
tar -zxvf go的包名
</code></pre>

<p>解压完成后发现目录下多了一个go文件夹：
<img src="https://img-blog.csdnimg.cn/20190719143042938.png" alt=""/>
将文件夹移动到/usr/local/
<img src="https://img-blog.csdnimg.cn/20190719143137645.png" alt=""/></p>

<h1>2.配置环境变量：</h1>

<h2>（1）进入目的目录查看go文件夹是否移动成功：</h2>

<p><img src="https://img-blog.csdnimg.cn/20190719143506382.png" alt=""/></p>

<h2>（2）在usr下创建文件夹，用来存放自己的项目：</h2>

<p>workspace</p>

<h2>（3）进入新建的目录workspace新建三个文件夹：</h2>

<p>src
pkg
bin</p>

<h3>说明：</h3>

<pre><code>src 目录存放的是我们的go源代码，不同工程项目的代码以包名区分
pkg 编译后生成的文件
bin文件夹存放go install命名生成的可执行文件（这个文件夹会配置到环境变量中）
</code></pre>

<h2>（4）配置环境变量：</h2>

<p>进入 /etc 修改profile文件：
<img src="https://img-blog.csdnimg.cn/20190719144319621.png" alt=""/></p>

<pre><code>#进入etc目录
cd /etc/
#配置 profile
vim profile
</code></pre>

<p><img src="https://img-blog.csdnimg.cn/20190719145650864.png?x-oss-process=image%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1%2Csize_16%2Ccolor_FFFFFF%2Ct_70" alt=""/>
在此文件夹下加入上图的代码，代码如下：</p>

<pre><code>// 设置go安装路径
export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin
 
// 设置工程目录
export GOPATH=/usr/workspace
export PATH=$PATH:$GOPATH/bin
</code></pre>

<h2>（5）刷新环境变量：</h2>

<pre><code>source /etc/profile
</code></pre>

<h2> （6）查看go环境是否配置成功：</h2>

<pre><code>go version
</code></pre>

<h2>（7）查看详细配置：</h2>

<pre><code>go env
</code></pre>

<p>结果如下：  
<img src="https://img-blog.csdnimg.cn/20190719145255720.png?x-oss-process=image%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1%2Csize_16%2Ccolor_FFFFFF%2Ct_70" alt=""/> </p>

<h1>3.上传项目代码：</h1>

<p>在刚刚创建的workspace下新创建的三个文件夹中，src 目录存放的是我们的go源代码</p>

<h1>4运行</h1>

<pre><code class="language-go">go build main.go
//或者
go run main.go
</code></pre>

<p>最后执行 ./main 就行了。
如果想让项目在后台执行：执行 nohup ./main &amp; ，这样就可以程序在后台运行了。</p>

<p>参考教程<a href="https://blog.csdn.net/qq_42410605/article/details/96479892" rel="nofollow">https://blog.csdn.net/qq_42410605/article/details/96479892</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 01:14:33][0m  [36;1m[0.27ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-22 01:14:33][0m  [36;1m[0.38ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 1)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-22 01:14:33][0m  [36;1m[0.36ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 2)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-22 01:14:33][0m  [36;1m[0.31ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 4)  
[36;31m[0 rows affected or returned ][0m 
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-22 01:14:33][0m  [36;1m[0.35ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 3)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-22 01:14:33][0m  [36;1m[0.31ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 5)  
[36;31m[0 rows affected or returned ][0m 
[{5 1 3 like 狗科 535889315@qq.com /static/images/header.jpg ？？？ 2020-07-20 13:30:17 <nil> []}]
[{5 1 3 like 狗科 535889315@qq.com /static/images/header.jpg ？？？ 2020-07-20 13:30:17 <nil> []}]

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 01:30:29][0m  [36;1m[0.61ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 01:30:29][0m  [36;1m[0.81ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 01:30:29][0m  [36;1m[0.22ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-22 01:30:29][0m  [36;1m[0.35ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-22 01:30:29][0m  [36;1m[0.31ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-22 01:30:29][0m  [36;1m[0.35ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 01:50:55][0m  [36;1m[0.69ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 01:50:55][0m  [36;1m[0.93ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 01:50:55][0m  [36;1m[0.27ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-22 01:50:55][0m  [36;1m[0.38ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-22 01:50:55][0m  [36;1m[0.34ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-22 01:50:55][0m  [36;1m[0.42ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 02:22:43][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 02:41:39][0m  [36;1m[0.53ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 02:42:17][0m  [36;1m[0.53ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 03:23:29][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 03:23:37][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 03:27:43][0m  [36;1m[0.63ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 03:27:43][0m  [36;1m[0.52ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 03:39:59][0m  [36;1m[0.51ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 03:40:41][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 03:54:54][0m  [36;1m[0.53ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 03:54:54][0m  [36;1m[0.71ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 03:54:54][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-22 03:54:54][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-22 03:54:54][0m  [36;1m[0.27ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-22 03:54:54][0m  [36;1m[0.34ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 04:09:47][0m  [36;1m[0.52ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 04:32:15][0m  [36;1m[0.56ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 04:48:06][0m  [36;1m[0.57ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 04:48:06][0m  [36;1m[0.72ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 04:48:06][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-22 04:48:06][0m  [36;1m[0.31ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-22 04:48:06][0m  [36;1m[0.27ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-22 04:48:06][0m  [36;1m[0.34ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 04:49:11][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 04:49:22][0m  [36;1m[0.51ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 04:49:23][0m  [36;1m[0.56ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 04:49:23][0m  [36;1m[0.64ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 04:49:23][0m  [36;1m[0.56ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 04:49:23][0m  [36;1m[0.73ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 04:49:23][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-22 04:49:23][0m  [36;1m[0.31ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-22 04:49:23][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-22 04:49:23][0m  [36;1m[0.34ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 04:49:28][0m  [36;1m[0.56ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 04:49:28][0m  [36;1m[0.84ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 04:49:28][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-22 04:49:28][0m  [36;1m[0.37ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-22 04:49:28][0m  [36;1m[0.29ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-22 04:49:28][0m  [36;1m[0.34ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 04:49:44][0m  [36;1m[0.58ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 04:49:44][0m  [36;1m[0.71ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 04:49:44][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-22 04:49:44][0m  [36;1m[0.28ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-22 04:49:44][0m  [36;1m[0.31ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-22 04:49:44][0m  [36;1m[0.31ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 04:49:44][0m  [36;1m[0.52ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 04:49:44][0m  [36;1m[0.68ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 04:49:44][0m  [36;1m[0.18ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-22 04:49:44][0m  [36;1m[0.29ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-22 04:49:44][0m  [36;1m[0.24ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-22 04:49:44][0m  [36;1m[0.32ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 05:28:42][0m  [36;1m[0.59ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 05:28:42][0m  [36;1m[0.72ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 05:28:42][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-22 05:28:42][0m  [36;1m[0.32ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-22 05:28:42][0m  [36;1m[0.29ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-22 05:28:42][0m  [36;1m[0.33ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 08:07:07][0m  [36;1m[0.51ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 08:07:08][0m  [36;1m[0.59ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 08:07:08][0m  [36;1m[0.72ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 08:07:09][0m  [36;1m[0.53ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 08:07:10][0m  [36;1m[0.58ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 08:07:10][0m  [36;1m[0.70ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 08:07:10][0m  [36;1m[0.23ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-22 08:07:10][0m  [36;1m[0.33ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-22 08:07:10][0m  [36;1m[0.25ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-22 08:07:10][0m  [36;1m[0.34ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 08:07:14][0m  [36;1m[0.50ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 08:07:14][0m  [36;1m[0.74ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 08:07:14][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-22 08:07:14][0m  [36;1m[0.34ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-22 08:07:14][0m  [36;1m[0.27ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-22 08:07:14][0m  [36;1m[0.37ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-22 08:08:14][0m  [36;1m[0.38ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 3)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-22 08:08:14][0m  [36;1m[0.46ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=3  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-22 08:08:14][0m  [36;1m[0.39ms][0m  UPDATE `blogs` SET `title` = 'mysql5.7 查询数据，group by 报错：Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 't.id' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by？', `content` = '在做归档功能时用到了分组查询
结果出现了这样的错误
```
Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 't.id' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by

```
查询才知道
mysql 5.7 加入的新特性，only_full_group_by，它只允许你的查询字段是包括在 group by 里面的字段，这种模式导致无法我们无法得到想要的字段值，我们可以禁用掉 only_full_group_by：
### 第一步：
```
select @@GLOBAL.sql_mode;
```
得到现有的 sql_mode, 如下：
```
ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION

```
### 第二步：
```
set global sql_mode ='STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION';

set session sql_mode= 'STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION';
```
去除 ONLY_FULL_GROUP_BY，重新设置，就 ok 了。', `image` = 'https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2507389442,2201469096&fm=26&gp=0.jpg', `numb` = 24, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '在做归档功能时用到了分组查询，结果出现了这样的错误，原来是mysql57的新功能
', `creat_time` = '2020-07-19 18:58:22', `update_time` = '2020-07-19 18:59:30', `type_id` = 3, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 2  
[36;31m[1 rows affected or returned ][0m 
<p>在做归档功能时用到了分组查询
结果出现了这样的错误</p>

<pre><code>Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column &#39;t.id&#39; which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by

</code></pre>

<p>查询才知道
mysql 5.7 加入的新特性，only_full_group_by，它只允许你的查询字段是包括在 group by 里面的字段，这种模式导致无法我们无法得到想要的字段值，我们可以禁用掉 only_full_group_by：</p>

<h3>第一步：</h3>

<pre><code>select @@GLOBAL.sql_mode;
</code></pre>

<p>得到现有的 sql_mode, 如下：</p>

<pre><code>ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION

</code></pre>

<h3>第二步：</h3>

<pre><code>set global sql_mode =&#39;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&#39;;

set session sql_mode= &#39;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&#39;;
</code></pre>

<p>去除 ONLY_FULL_GROUP_BY，重新设置，就 ok 了。</p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 08:08:14][0m  [36;1m[0.30ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-22 08:08:17][0m  [36;1m[0.42ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 3)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-22 08:08:17][0m  [36;1m[0.46ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=3  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-22 08:08:17][0m  [36;1m[0.46ms][0m  UPDATE `blogs` SET `title` = 'mysql5.7 查询数据，group by 报错：Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 't.id' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by？', `content` = '在做归档功能时用到了分组查询
结果出现了这样的错误
```
Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 't.id' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by

```
查询才知道
mysql 5.7 加入的新特性，only_full_group_by，它只允许你的查询字段是包括在 group by 里面的字段，这种模式导致无法我们无法得到想要的字段值，我们可以禁用掉 only_full_group_by：
### 第一步：
```
select @@GLOBAL.sql_mode;
```
得到现有的 sql_mode, 如下：
```
ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION

```
### 第二步：
```
set global sql_mode ='STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION';

set session sql_mode= 'STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION';
```
去除 ONLY_FULL_GROUP_BY，重新设置，就 ok 了。', `image` = 'https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2507389442,2201469096&fm=26&gp=0.jpg', `numb` = 25, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '在做归档功能时用到了分组查询，结果出现了这样的错误，原来是mysql57的新功能
', `creat_time` = '2020-07-19 18:58:22', `update_time` = '2020-07-19 18:59:30', `type_id` = 3, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 2  
[36;31m[1 rows affected or returned ][0m 
<p>在做归档功能时用到了分组查询
结果出现了这样的错误</p>

<pre><code>Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column &#39;t.id&#39; which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by

</code></pre>

<p>查询才知道
mysql 5.7 加入的新特性，only_full_group_by，它只允许你的查询字段是包括在 group by 里面的字段，这种模式导致无法我们无法得到想要的字段值，我们可以禁用掉 only_full_group_by：</p>

<h3>第一步：</h3>

<pre><code>select @@GLOBAL.sql_mode;
</code></pre>

<p>得到现有的 sql_mode, 如下：</p>

<pre><code>ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION

</code></pre>

<h3>第二步：</h3>

<pre><code>set global sql_mode =&#39;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&#39;;

set session sql_mode= &#39;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&#39;;
</code></pre>

<p>去除 ONLY_FULL_GROUP_BY，重新设置，就 ok 了。</p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 08:08:17][0m  [36;1m[0.30ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 08:09:36][0m  [36;1m[0.58ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 08:09:36][0m  [36;1m[0.81ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 08:09:36][0m  [36;1m[0.28ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-22 08:09:36][0m  [36;1m[0.36ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-22 08:09:36][0m  [36;1m[0.32ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-22 08:09:36][0m  [36;1m[0.34ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 08:09:47][0m  [36;1m[0.53ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-22 08:09:47][0m  [36;1m[0.26ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-22 08:09:47][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 
1

[35m(/usr/workspace/src/blog/dao/types.go:52)[0m 
[33m[2020-07-22 08:09:47][0m  [36;1m[0.49ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id WHERE (type_id = 1) ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 08:09:50][0m  [36;1m[0.51ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-22 08:09:50][0m  [36;1m[0.21ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-22 08:09:50][0m  [36;1m[0.17ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 
1

[35m(/usr/workspace/src/blog/dao/types.go:52)[0m 
[33m[2020-07-22 08:09:50][0m  [36;1m[0.46ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id WHERE (type_id = 1) ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 08:09:50][0m  [36;1m[0.52ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-22 08:09:50][0m  [36;1m[0.25ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-22 08:09:50][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 
1

[35m(/usr/workspace/src/blog/dao/types.go:52)[0m 
[33m[2020-07-22 08:09:50][0m  [36;1m[0.48ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id WHERE (type_id = 1) ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-22 08:09:58][0m  [36;1m[0.55ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 08:09:58][0m  [36;1m[0.26ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 08:09:58][0m  [36;1m[0.69ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-22 08:09:58][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-22 08:10:01][0m  [36;1m[0.55ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 08:10:01][0m  [36;1m[0.23ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 08:10:01][0m  [36;1m[0.69ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-22 08:10:01][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-22 08:10:01][0m  [36;1m[0.59ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 08:10:01][0m  [36;1m[0.28ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 08:10:01][0m  [36;1m[0.74ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-22 08:10:01][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-22 08:10:09][0m  [36;1m[0.38ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 4)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-22 08:10:09][0m  [36;1m[0.46ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=4  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-22 08:10:09][0m  [36;1m[0.44ms][0m  UPDATE `blogs` SET `title` = '本博客开源公告', `content` = '今天本博客评论功能发布
# 自今天起，本博客基本功能已经完成
## 发布V1.0版本并开源
## 博客语言说明
#### 本博客后端是用golang 的gin框架+gorm编写
前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的
#### 博客效果参考本站
#一、博客简介
## 1.博客目录

    blog
    ├────controller
	├────└───admin
	|	|	├──adminblog.go
	|	|	├───adminController.go
	|	|	├──adminTag.go
	|	|	├──adminType.go
	|	|	└──adminUser.go
	|	└──page
	|		├──404.go
	|		├───about.go
	|		├──archives.go
	|		├──blog.go
	|		├──comment.go
	|		├──pagesController.go
	|		├──researchController.go
	|		└──tagsController.go
    ├── dao
	│	├──blogs.go
	│	├──comment.go
	│	├──sql.go
	│	├──tags.go
	│	├──types.go
	│	└──user.go
    ├── logic
    │   └── user.go
    ├── middlerware
	│	├──function.go
	│	├──getImg.go
	│	├──getTime.go
	│	├──markdown.go
	│	├──select.go
	│	└──session.go
    ├── model
	│	├──blog.go
	│	├──commnent.go
	│	├──tag.go
	│	├──type.go
	│	└──user/go
    ├── static
	│	└──静态文件（头像、图片、logo、css、js等）
    ├── templates
	│	└──html模板文件
    ├── go.mod（依赖）
    └── main.go
    

## 2.相关功能实现简介
### 1、评论及回复功能
comment的结构体属性如下
```go
package model

type Comment struct {
	Id     int //评论id
	BlogId int //博文id
	ReCommentId    int    //父评论id
	CommentName string //评论人姓名
	ReCommentName  string //父评论人姓名
	CommentEmail   string
	Img            string
	CommentContent string `gorm:"type:text" form:"CommentContent" json:"CommentContent"` //评论内容
	CommentTime    string ` json:"comment_time,omitempty"`
	Parent         *Comment
	Comments       []Comment
}
```
#### 实现方法
##### 1先通过查找父评论为-1的顶级评论
父评论Id为-1说明他不是任何评论的子评论
##### 2在html上遍历所有的顶级评论
在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论
###### （1）递归存储每个顶级评论的子评论
这里我用一个切片来储存一个顶级评论的所有子评论
```go
var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
	var comments []model.Comment
	DB.Debug().Where("re_comment_id = -1 AND blog_id = ?", id).Find(&comments)
	return &comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
	if count != 0 {
		fmt.Println("if判断1")
		var comments []model.Comment
		DB.Debug().Where("re_comment_id = ?", id).Find(&comments)
		count = len(comments)
		if count != 0 {
			fmt.Println("if判断2")
			for _, comment := range comments {
				fmt.Println("for判断1")
				Comments = append(Comments, comment)
				SelectCommentByComment(comment.Id, count)
			}
		}
	}
	fmt.Println(Comments)
	return &Comments

}
```
ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来
###### （2）出现问题的原因
因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量
###### （3）解决问题
```go
func ClearComments() bool {
	var comments []model.Comment
	Comments = comments
	return true
}

```
这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现
#### 这里我还加了一个小小的随机头像功能
```go
if  CommentName == user.Name && CommentEmail == user.UserEmail {
		fmt.Println("进入了1")
		comment.Img =user.UserImg
		//找相同评论人
	}else if CommentName == one.CommentName && CommentEmail == one.CommentEmail {
		fmt.Println("进入了2")
		comment.Img =one.Img
		//随机选头像
	}else{
		fmt.Println("进入了3")
		comment.Img =middleware.GetImg()
	}
```
##### 123分别代表三种不同的用户群体
1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
![](/static/images/%e5%a4%b4%e5%83%8f1.png)![](/static/images/%e5%a4%b4%e5%83%8f2.png)![](/static/images/%e5%a4%b4%e5%83%8f3.png)![](/static/images/%e5%a4%b4%e5%83%8f4.png)![](/static/images/%e5%a4%b4%e5%83%8f5.png)![](/static/images/%e5%a4%b4%e5%83%8f6.png)
### 2、归档功能
#### blog的结构体属性如下
```go
package model

type Blog struct {
	Id           int
	Title        string    `form:"title" json:"title"`                          //标题
	Content      string    `gorm:"type:longtext" form:"content" json:"content"` //内容
	Image        string    `gorm:"type:text" form:"image" json:"image"`         //首图
	Numb         int       `form:"numb" json:"numb"`                            //次数
	Flag         string    `form:"flag" json:"flag"`                            //原创或者转载
	Appreciation string    `form:"appreciation" json:"appreciation"`            //打赏开关
	ShareInfo    string    `form:"shareInfo" json:"shareInfo"`                  //版权开关
	Comment      string    `form:"comment" json:"comment"`                      //评论开关
	Recommend    string    `form:"recommend" json:"recommend"`                  //推荐开关
	Description  string    `gorm:"type:text" form:"description" json:"description"`
	CreatTime    string    `form:"creatTime"  json:"creat_time,omitempty"`   //创建时间
	UpdateTime   string    `form:"updateTime"  json:"update_time,omitempty"` //更新时间
	Comments     []Comment `form:"comments" json:"comments"`
	TypeId       int       `form:"typeId" json:"typeId"`
	Type         Type      `form:"type" gorm:"ForeignKey:TypeId"`
	Year         int       `form:"year" json:"year"`
	Month        int       `form:"month" json:"month"`
	Day          int       `form:"day" json:"day"`
}

```
#### 实现方法
我的思路是创建三个时间节点
year month day 
利用sql分组查询
##### Group By分组查询步骤
###### （1）先按照年份查询
###### （2）再按照年份遍历每个月份
并将所有保存在一个切片中
###### （3）按照月份遍历每个月的所有文章
保存在一个Map中，key是对应的月份，value是每个月份的所有文章
#### 自此归档功能实现


## 3.已知BUG
### 后台退出功能
后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧

开源地址
[github](https://github.com/likewl/blog "github")
[gitee](https://gitee.com/nculike/blog "gitee")', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1535821573,4166447487&fm=26&gp=0.jpg', `numb` = 53, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '本博客后端是用golang 的gin框架+gorm编写', `creat_time` = '2020-07-20 15:24:23', `update_time` = '2020-07-20 15:24:23', `type_id` = 4, `year` = 2020, `month` = 7, `day` = 20  WHERE `blogs`.`id` = 4  
[36;31m[1 rows affected or returned ][0m 
<p>今天本博客评论功能发布</p>

<h1>自今天起，本博客基本功能已经完成</h1>

<h2>发布V1.0版本并开源</h2>

<h2>博客语言说明</h2>

<h4>本博客后端是用golang 的gin框架+gorm编写</h4>

<p>前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的</p>

<h4>博客效果参考本站</h4>

<p>#一、博客简介</p>

<h2>1.博客目录</h2>

<pre><code>blog
├────controller
├────└───admin
|   |   ├──adminblog.go
|   |   ├───adminController.go
|   |   ├──adminTag.go
|   |   ├──adminType.go
|   |   └──adminUser.go
|   └──page
|       ├──404.go
|       ├───about.go
|       ├──archives.go
|       ├──blog.go
|       ├──comment.go
|       ├──pagesController.go
|       ├──researchController.go
|       └──tagsController.go
├── dao
│   ├──blogs.go
│   ├──comment.go
│   ├──sql.go
│   ├──tags.go
│   ├──types.go
│   └──user.go
├── logic
│   └── user.go
├── middlerware
│   ├──function.go
│   ├──getImg.go
│   ├──getTime.go
│   ├──markdown.go
│   ├──select.go
│   └──session.go
├── model
│   ├──blog.go
│   ├──commnent.go
│   ├──tag.go
│   ├──type.go
│   └──user/go
├── static
│   └──静态文件（头像、图片、logo、css、js等）
├── templates
│   └──html模板文件
├── go.mod（依赖）
└── main.go
</code></pre>

<h2>2.相关功能实现简介</h2>

<h3>1、评论及回复功能</h3>

<p>comment的结构体属性如下</p>

<pre><code class="language-go">package model

type Comment struct {
    Id     int //评论id
    BlogId int //博文id
    ReCommentId    int    //父评论id
    CommentName string //评论人姓名
    ReCommentName  string //父评论人姓名
    CommentEmail   string
    Img            string
    CommentContent string `gorm:&#34;type:text&#34; form:&#34;CommentContent&#34; json:&#34;CommentContent&#34;` //评论内容
    CommentTime    string ` json:&#34;comment_time,omitempty&#34;`
    Parent         *Comment
    Comments       []Comment
}
</code></pre>

<h4>实现方法</h4>

<h5>1先通过查找父评论为-1的顶级评论</h5>

<p>父评论Id为-1说明他不是任何评论的子评论</p>

<h5>2在html上遍历所有的顶级评论</h5>

<p>在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论</p>

<h6>（1）递归存储每个顶级评论的子评论</h6>

<p>这里我用一个切片来储存一个顶级评论的所有子评论</p>

<pre><code class="language-go">var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
    var comments []model.Comment
    DB.Debug().Where(&#34;re_comment_id = -1 AND blog_id = ?&#34;, id).Find(&amp;comments)
    return &amp;comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
    if count != 0 {
        fmt.Println(&#34;if判断1&#34;)
        var comments []model.Comment
        DB.Debug().Where(&#34;re_comment_id = ?&#34;, id).Find(&amp;comments)
        count = len(comments)
        if count != 0 {
            fmt.Println(&#34;if判断2&#34;)
            for _, comment := range comments {
                fmt.Println(&#34;for判断1&#34;)
                Comments = append(Comments, comment)
                SelectCommentByComment(comment.Id, count)
            }
        }
    }
    fmt.Println(Comments)
    return &amp;Comments

}
</code></pre>

<p>ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来</p>

<h6>（2）出现问题的原因</h6>

<p>因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量</p>

<h6>（3）解决问题</h6>

<pre><code class="language-go">func ClearComments() bool {
    var comments []model.Comment
    Comments = comments
    return true
}

</code></pre>

<p>这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现</p>

<h4>这里我还加了一个小小的随机头像功能</h4>

<pre><code class="language-go">if  CommentName == user.Name &amp;&amp; CommentEmail == user.UserEmail {
        fmt.Println(&#34;进入了1&#34;)
        comment.Img =user.UserImg
        //找相同评论人
    }else if CommentName == one.CommentName &amp;&amp; CommentEmail == one.CommentEmail {
        fmt.Println(&#34;进入了2&#34;)
        comment.Img =one.Img
        //随机选头像
    }else{
        fmt.Println(&#34;进入了3&#34;)
        comment.Img =middleware.GetImg()
    }
</code></pre>

<h5>123分别代表三种不同的用户群体</h5>

<p>1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
<img src="/static/images/%e5%a4%b4%e5%83%8f1.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f2.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f3.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f4.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f5.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f6.png" alt=""/></p>

<h3>2、归档功能</h3>

<h4>blog的结构体属性如下</h4>

<pre><code class="language-go">package model

type Blog struct {
    Id           int
    Title        string    `form:&#34;title&#34; json:&#34;title&#34;`                          //标题
    Content      string    `gorm:&#34;type:longtext&#34; form:&#34;content&#34; json:&#34;content&#34;` //内容
    Image        string    `gorm:&#34;type:text&#34; form:&#34;image&#34; json:&#34;image&#34;`         //首图
    Numb         int       `form:&#34;numb&#34; json:&#34;numb&#34;`                            //次数
    Flag         string    `form:&#34;flag&#34; json:&#34;flag&#34;`                            //原创或者转载
    Appreciation string    `form:&#34;appreciation&#34; json:&#34;appreciation&#34;`            //打赏开关
    ShareInfo    string    `form:&#34;shareInfo&#34; json:&#34;shareInfo&#34;`                  //版权开关
    Comment      string    `form:&#34;comment&#34; json:&#34;comment&#34;`                      //评论开关
    Recommend    string    `form:&#34;recommend&#34; json:&#34;recommend&#34;`                  //推荐开关
    Description  string    `gorm:&#34;type:text&#34; form:&#34;description&#34; json:&#34;description&#34;`
    CreatTime    string    `form:&#34;creatTime&#34;  json:&#34;creat_time,omitempty&#34;`   //创建时间
    UpdateTime   string    `form:&#34;updateTime&#34;  json:&#34;update_time,omitempty&#34;` //更新时间
    Comments     []Comment `form:&#34;comments&#34; json:&#34;comments&#34;`
    TypeId       int       `form:&#34;typeId&#34; json:&#34;typeId&#34;`
    Type         Type      `form:&#34;type&#34; gorm:&#34;ForeignKey:TypeId&#34;`
    Year         int       `form:&#34;year&#34; json:&#34;year&#34;`
    Month        int       `form:&#34;month&#34; json:&#34;month&#34;`
    Day          int       `form:&#34;day&#34; json:&#34;day&#34;`
}

</code></pre>

<h4>实现方法</h4>

<p>我的思路是创建三个时间节点
year month day
利用sql分组查询</p>

<h5>Group By分组查询步骤</h5>

<h6>（1）先按照年份查询</h6>

<h6>（2）再按照年份遍历每个月份</h6>

<p>并将所有保存在一个切片中</p>

<h6>（3）按照月份遍历每个月的所有文章</h6>

<p>保存在一个Map中，key是对应的月份，value是每个月份的所有文章</p>

<h4>自此归档功能实现</h4>

<h2>3.已知BUG</h2>

<h3>后台退出功能</h3>

<p>后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧</p>

<p>开源地址
<a href="https://github.com/likewl/blog" title="github" rel="nofollow">github</a>
<a href="https://gitee.com/nculike/blog" title="gitee" rel="nofollow">gitee</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 08:10:09][0m  [36;1m[0.31ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 08:11:05][0m  [36;1m[0.52ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-22 08:11:05][0m  [36;1m[0.24ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-22 08:11:05][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 
1

[35m(/usr/workspace/src/blog/dao/types.go:52)[0m 
[33m[2020-07-22 08:11:05][0m  [36;1m[0.46ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id WHERE (type_id = 1) ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[1 rows affected or returned ][0m 
[GIN-debug] redirecting request 301: /types --> /types??????/4

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-22 08:13:52][0m  [36;1m[0.43ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 1)  
[36;31m[2 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-22 08:13:52][0m  [36;1m[0.43ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=1  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-22 08:13:52][0m  [36;1m[0.38ms][0m  UPDATE `blogs` SET `title` = 'golang项目简单服务器部署到阿里云(linux)', `content` = '# 我个人比较推荐使用Xftp和Xshell 
# 重要是个人免费用
# 舒服又好用

# 1.下载安装go安装包：
	## （1）go语言下载地址：
	[Go语言中文网](https://studygolang.com/dl "Go语言中文网")
下载linux版本的安装包。

## （2）使用Xftp将安装包上传至指定的路径：

![](https://img-blog.csdnimg.cn/20190719142701389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
	这里上传到root目录下就行
	方便解压
## （3）解压并移到/usr/local/下：

进入指定目录，查看已有文件并且解压文件：

![](https://img-blog.csdnimg.cn/20190719143211340.png)
```
#在root目录输入ls查看目录文件
ls
#在root解压go包
tar -zxvf go的包名
```

解压完成后发现目录下多了一个go文件夹：
![](https://img-blog.csdnimg.cn/20190719143042938.png)
将文件夹移动到/usr/local/
![](https://img-blog.csdnimg.cn/20190719143137645.png)
# 2.配置环境变量：
## （1）进入目的目录查看go文件夹是否移动成功：
![](https://img-blog.csdnimg.cn/20190719143506382.png)
## （2）在usr下创建文件夹，用来存放自己的项目：
workspace
## （3）进入新建的目录workspace新建三个文件夹：
src
pkg
bin
### 说明：

	src 目录存放的是我们的go源代码，不同工程项目的代码以包名区分
	pkg 编译后生成的文件
	bin文件夹存放go install命名生成的可执行文件（这个文件夹会配置到环境变量中）
## （4）配置环境变量：

进入 /etc 修改profile文件：
![](https://img-blog.csdnimg.cn/20190719144319621.png)
```
#进入etc目录
cd /etc/
#配置 profile
vim profile
```
![](https://img-blog.csdnimg.cn/20190719145650864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
在此文件夹下加入上图的代码，代码如下：
```
// 设置go安装路径
export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin
 
// 设置工程目录
export GOPATH=/usr/workspace
export PATH=$PATH:$GOPATH/bin
```

## （5）刷新环境变量：
```
source /etc/profile
```
##  （6）查看go环境是否配置成功：
```
go version
```
## （7）查看详细配置：
```
go env
```
结果如下：  
![](https://img-blog.csdnimg.cn/20190719145255720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70) 
# 3.上传项目代码：
在刚刚创建的workspace下新创建的三个文件夹中，src 目录存放的是我们的go源代码
# 4运行
```go
go build main.go
//或者
go run main.go
```
最后执行 ./main 就行了。
如果想让项目在后台执行：执行 nohup ./main & ，这样就可以程序在后台运行了。

参考教程https://blog.csdn.net/qq_42410605/article/details/96479892', `image` = 'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3111860246,1925938903&fm=26&gp=0.jpg', `numb` = 47, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '简单又详细的教程', `creat_time` = '2020-07-19 18:32:31', `update_time` = '2020-07-20 13:11:56', `type_id` = 1, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 1  
[36;31m[1 rows affected or returned ][0m 
<h1>我个人比较推荐使用Xftp和Xshell</h1>

<h1>重要是个人免费用</h1>

<h1>舒服又好用</h1>

<h1>1.下载安装go安装包：</h1>

<pre><code>## （1）go语言下载地址：
[Go语言中文网](https://studygolang.com/dl &#34;Go语言中文网&#34;)
</code></pre>

<p>下载linux版本的安装包。</p>

<h2>（2）使用Xftp将安装包上传至指定的路径：</h2>

<p><img src="https://img-blog.csdnimg.cn/20190719142701389.png?x-oss-process=image%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1%2Csize_16%2Ccolor_FFFFFF%2Ct_70" alt=""/>
    这里上传到root目录下就行
    方便解压</p>

<h2>（3）解压并移到/usr/local/下：</h2>

<p>进入指定目录，查看已有文件并且解压文件：</p>

<p><img src="https://img-blog.csdnimg.cn/20190719143211340.png" alt=""/></p>

<pre><code>#在root目录输入ls查看目录文件
ls
#在root解压go包
tar -zxvf go的包名
</code></pre>

<p>解压完成后发现目录下多了一个go文件夹：
<img src="https://img-blog.csdnimg.cn/20190719143042938.png" alt=""/>
将文件夹移动到/usr/local/
<img src="https://img-blog.csdnimg.cn/20190719143137645.png" alt=""/></p>

<h1>2.配置环境变量：</h1>

<h2>（1）进入目的目录查看go文件夹是否移动成功：</h2>

<p><img src="https://img-blog.csdnimg.cn/20190719143506382.png" alt=""/></p>

<h2>（2）在usr下创建文件夹，用来存放自己的项目：</h2>

<p>workspace</p>

<h2>（3）进入新建的目录workspace新建三个文件夹：</h2>

<p>src
pkg
bin</p>

<h3>说明：</h3>

<pre><code>src 目录存放的是我们的go源代码，不同工程项目的代码以包名区分
pkg 编译后生成的文件
bin文件夹存放go install命名生成的可执行文件（这个文件夹会配置到环境变量中）
</code></pre>

<h2>（4）配置环境变量：</h2>

<p>进入 /etc 修改profile文件：
<img src="https://img-blog.csdnimg.cn/20190719144319621.png" alt=""/></p>

<pre><code>#进入etc目录
cd /etc/
#配置 profile
vim profile
</code></pre>

<p><img src="https://img-blog.csdnimg.cn/20190719145650864.png?x-oss-process=image%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1%2Csize_16%2Ccolor_FFFFFF%2Ct_70" alt=""/>
在此文件夹下加入上图的代码，代码如下：</p>

<pre><code>// 设置go安装路径
export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin
 
// 设置工程目录
export GOPATH=/usr/workspace
export PATH=$PATH:$GOPATH/bin
</code></pre>

<h2>（5）刷新环境变量：</h2>

<pre><code>source /etc/profile
</code></pre>

<h2> （6）查看go环境是否配置成功：</h2>

<pre><code>go version
</code></pre>

<h2>（7）查看详细配置：</h2>

<pre><code>go env
</code></pre>

<p>结果如下：  
<img src="https://img-blog.csdnimg.cn/20190719145255720.png?x-oss-process=image%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1%2Csize_16%2Ccolor_FFFFFF%2Ct_70" alt=""/> </p>

<h1>3.上传项目代码：</h1>

<p>在刚刚创建的workspace下新创建的三个文件夹中，src 目录存放的是我们的go源代码</p>

<h1>4运行</h1>

<pre><code class="language-go">go build main.go
//或者
go run main.go
</code></pre>

<p>最后执行 ./main 就行了。
如果想让项目在后台执行：执行 nohup ./main &amp; ，这样就可以程序在后台运行了。</p>

<p>参考教程<a href="https://blog.csdn.net/qq_42410605/article/details/96479892" rel="nofollow">https://blog.csdn.net/qq_42410605/article/details/96479892</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 08:13:52][0m  [36;1m[0.25ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-22 08:13:52][0m  [36;1m[0.40ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 1)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-22 08:13:52][0m  [36;1m[0.36ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 2)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-22 08:13:52][0m  [36;1m[0.36ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 4)  
[36;31m[0 rows affected or returned ][0m 
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-22 08:13:52][0m  [36;1m[0.33ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 3)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-22 08:13:52][0m  [36;1m[0.34ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 5)  
[36;31m[0 rows affected or returned ][0m 
[{5 1 3 like 狗科 535889315@qq.com /static/images/header.jpg ？？？ 2020-07-20 13:30:17 <nil> []}]
[{5 1 3 like 狗科 535889315@qq.com /static/images/header.jpg ？？？ 2020-07-20 13:30:17 <nil> []}]

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-22 08:15:15][0m  [36;1m[0.91ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 08:15:15][0m  [36;1m[1.65ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 08:15:15][0m  [36;1m[0.83ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-22 08:15:15][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 08:21:57][0m  [36;1m[0.59ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 08:23:16][0m  [36;1m[0.50ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 08:23:16][0m  [36;1m[0.69ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 08:23:16][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-22 08:23:16][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-22 08:23:16][0m  [36;1m[0.25ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-22 08:23:16][0m  [36;1m[0.32ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-22 08:23:18][0m  [36;1m[0.54ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 08:23:18][0m  [36;1m[0.27ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 08:23:18][0m  [36;1m[0.72ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-22 08:23:18][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-22 08:23:21][0m  [36;1m[0.64ms][0m  SELECT * FROM `tags`    
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 08:23:21][0m  [36;1m[0.28ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 08:23:21][0m  [36;1m[0.72ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:31)[0m 
[33m[2020-07-22 08:23:21][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `tags`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-22 08:23:25][0m  [36;1m[0.52ms][0m  SELECT * FROM `tags`    
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 08:23:25][0m  [36;1m[0.29ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:68)[0m 
[33m[2020-07-22 08:23:25][0m  [36;1m[0.44ms][0m  SELECT * FROM `tags`  WHERE (tag_name='项目部署') ORDER BY `tags`.`id` ASC LIMIT 1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:76)[0m 
[33m[2020-07-22 08:23:25][0m  [36;1m[0.91ms][0m   SELECT b.id,b.title,b.type_id,t.tag_name,b.description,b.recommend,b.numb,b.update_time,b.image,a.`type_name`  FROM `blogs` b LEFT JOIN `tag_blogs` tb ON b.id = tb.`blog_id` LEFT JOIN tags t ON tb.`tag_id`=t.`id` LEFT JOIN `types` a ON b.type_id = a.`id` WHERE t.`id`=1 ORDER BY b.id  DESC LIMIT 10 OFFSET 0  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:31)[0m 
[33m[2020-07-22 08:23:25][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `tags`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 08:23:29][0m  [36;1m[0.72ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 08:23:29][0m  [36;1m[0.28ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:144)[0m 
[33m[2020-07-22 08:23:29][0m  [36;1m[0.82ms][0m   SELECT * FROM `blogs` GROUP BY YEAR DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:157)[0m 
[33m[2020-07-22 08:23:29][0m  [36;1m[0.87ms][0m   SELECT * FROM `blogs` where year = 2020 GROUP BY month DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:169)[0m 
[33m[2020-07-22 08:23:29][0m  [36;1m[0.88ms][0m   SELECT * FROM `blogs` where year = 2020 and month = 7 ORDER BY `id` DESC  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-22 08:23:29][0m  [36;1m[0.49ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=4  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-22 08:23:29][0m  [36;1m[0.45ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=3  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-22 08:23:29][0m  [36;1m[0.45ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=2  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-22 08:23:29][0m  [36;1m[0.44ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 08:23:34][0m  [36;1m[0.57ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-22 08:26:11][0m  [36;1m[0.52ms][0m  SELECT * FROM `tags`    
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 08:26:11][0m  [36;1m[0.25ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 08:26:11][0m  [36;1m[0.70ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:31)[0m 
[33m[2020-07-22 08:26:11][0m  [36;1m[0.18ms][0m  SELECT count(*) FROM `tags`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 08:29:05][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 08:29:05][0m  [36;1m[0.22ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:144)[0m 
[33m[2020-07-22 08:29:05][0m  [36;1m[0.66ms][0m   SELECT * FROM `blogs` GROUP BY YEAR DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:157)[0m 
[33m[2020-07-22 08:29:05][0m  [36;1m[0.74ms][0m   SELECT * FROM `blogs` where year = 2020 GROUP BY month DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:169)[0m 
[33m[2020-07-22 08:29:05][0m  [36;1m[0.67ms][0m   SELECT * FROM `blogs` where year = 2020 and month = 7 ORDER BY `id` DESC  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-22 08:29:05][0m  [36;1m[0.37ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=4  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-22 08:29:05][0m  [36;1m[0.34ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=3  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-22 08:29:05][0m  [36;1m[0.33ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=2  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-22 08:29:05][0m  [36;1m[0.31ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-22 08:34:02][0m  [36;1m[0.56ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 08:34:02][0m  [36;1m[0.31ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 08:34:02][0m  [36;1m[0.69ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-22 08:34:02][0m  [36;1m[0.22ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 09:08:37][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 09:08:40][0m  [36;1m[0.58ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 09:24:40][0m  [36;1m[0.52ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 09:24:40][0m  [36;1m[0.73ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 09:24:40][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-22 09:24:40][0m  [36;1m[0.31ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-22 09:24:40][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-22 09:24:40][0m  [36;1m[0.35ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 09:24:45][0m  [36;1m[0.97ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 09:24:45][0m  [36;1m[2.33ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 09:24:45][0m  [36;1m[0.22ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-22 09:24:45][0m  [36;1m[0.35ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-22 09:24:45][0m  [36;1m[0.29ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-22 09:24:45][0m  [36;1m[0.37ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 09:24:45][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 09:24:45][0m  [36;1m[0.74ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 09:24:45][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-22 09:24:45][0m  [36;1m[0.32ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-22 09:24:45][0m  [36;1m[0.27ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-22 09:24:45][0m  [36;1m[0.35ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 09:24:47][0m  [36;1m[0.57ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 09:24:47][0m  [36;1m[0.79ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 09:24:47][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-22 09:24:47][0m  [36;1m[0.31ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-22 09:24:47][0m  [36;1m[0.25ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-22 09:24:47][0m  [36;1m[0.31ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 09:24:48][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 09:24:48][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 09:24:48][0m  [36;1m[0.51ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 09:24:48][0m  [36;1m[0.73ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 09:24:48][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-22 09:24:48][0m  [36;1m[0.34ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-22 09:24:48][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-22 09:24:48][0m  [36;1m[0.32ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 09:24:49][0m  [36;1m[0.57ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 09:24:49][0m  [36;1m[0.53ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 09:24:49][0m  [36;1m[0.81ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 09:24:49][0m  [36;1m[0.22ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-22 09:24:49][0m  [36;1m[0.29ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-22 09:24:49][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-22 09:24:49][0m  [36;1m[0.31ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 09:24:50][0m  [36;1m[0.51ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 09:24:50][0m  [36;1m[0.53ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 09:34:49][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 09:34:49][0m  [36;1m[0.74ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 09:34:49][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-22 09:34:49][0m  [36;1m[0.32ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-22 09:34:49][0m  [36;1m[0.27ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-22 09:34:49][0m  [36;1m[0.32ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 10:42:10][0m  [36;1m[0.56ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 10:42:10][0m  [36;1m[0.70ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 10:42:10][0m  [36;1m[0.23ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-22 10:42:10][0m  [36;1m[0.31ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-22 10:42:10][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-22 10:42:10][0m  [36;1m[0.33ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 10:59:28][0m  [36;1m[0.69ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 10:59:28][0m  [36;1m[0.76ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 10:59:28][0m  [36;1m[0.23ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-22 10:59:28][0m  [36;1m[0.33ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-22 10:59:28][0m  [36;1m[0.27ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-22 10:59:28][0m  [36;1m[0.41ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 11:10:29][0m  [36;1m[0.56ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 11:10:29][0m  [36;1m[0.71ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 11:10:29][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-22 11:10:29][0m  [36;1m[0.29ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-22 11:10:29][0m  [36;1m[0.27ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-22 11:10:29][0m  [36;1m[0.33ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 11:13:54][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 11:13:54][0m  [36;1m[0.73ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 11:13:54][0m  [36;1m[0.29ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-22 11:13:54][0m  [36;1m[0.31ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-22 11:13:54][0m  [36;1m[0.27ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-22 11:13:54][0m  [36;1m[0.41ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 
2020/07/22 11:13:54 http: panic serving 223.84.146.252:37283: write tcp 172.16.13.169:80->223.84.146.252:37283: write: broken pipe
goroutine 9801 [running]:
net/http.(*conn).serve.func1(0xc0000be140)
	/usr/local/go/src/net/http/server.go:1772 +0x139
panic(0xb50ee0, 0xc000066780)
	/usr/local/go/src/runtime/panic.go:975 +0x3e3
github.com/gin-gonic/gin.(*Context).Render(0xc0005bc2d0, 0xc8, 0xd0e260, 0xc000298f30)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:842 +0x173
github.com/gin-gonic/gin.(*Context).HTML(0xc0005bc2d0, 0xc8, 0xbf926d, 0x10, 0xb43d60, 0xc0002843c0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:851 +0x99
blog/controller/page.IndexHandler(0xc0005bc2d0)
	/usr/workspace/src/blog/controller/page/pagesController.go:22 +0x570
github.com/gin-gonic/gin.(*Context).Next(0xc0005bc2d0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:161 +0x3b
github.com/gin-contrib/sessions.Sessions.func1(0xc0005bc2d0)
	/usr/workspace/pkg/mod/github.com/gin-contrib/sessions@v0.0.3/sessions.go:52 +0x16d
github.com/gin-gonic/gin.(*Context).Next(0xc0005bc2d0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:161 +0x3b
github.com/gin-gonic/gin.(*Engine).handleHTTPRequest(0xc0003b8500, 0xc0005bc2d0)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/gin.go:409 +0x666
github.com/gin-gonic/gin.(*Engine).ServeHTTP(0xc0003b8500, 0xd12a40, 0xc0000b81c0, 0xc0000f2100)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/gin.go:367 +0x14d
net/http.serverHandler.ServeHTTP(0xc0000b8380, 0xd12a40, 0xc0000b81c0, 0xc0000f2100)
	/usr/local/go/src/net/http/server.go:2807 +0xa3
net/http.(*conn).serve(0xc0000be140, 0xd15200, 0xc0003d2140)
	/usr/local/go/src/net/http/server.go:1895 +0x86c
created by net/http.(*Server).Serve
	/usr/local/go/src/net/http/server.go:2933 +0x35c

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 11:13:55][0m  [36;1m[0.53ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
2020/07/22 11:13:55 http: panic serving 223.84.146.252:37282: write tcp 172.16.13.169:80->223.84.146.252:37282: write: broken pipe
goroutine 9803 [running]:
net/http.(*conn).serve.func1(0xc0000be640)
	/usr/local/go/src/net/http/server.go:1772 +0x139
panic(0xb50ee0, 0xc000066b40)
	/usr/local/go/src/runtime/panic.go:975 +0x3e3
github.com/gin-gonic/gin.(*Context).Render(0xc0005bc690, 0x194, 0xd0e260, 0xc00061e090)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:842 +0x173
github.com/gin-gonic/gin.(*Context).HTML(0xc0005bc690, 0x194, 0xbf193d, 0x8, 0xb43d60, 0xc0002d7c50)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:851 +0x99
blog/controller/page.NotFoundHandler(0xc0005bc690)
	/usr/workspace/src/blog/controller/page/404.go:12 +0x120
github.com/gin-gonic/gin.(*Context).Next(0xc0005bc690)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:161 +0x3b
github.com/gin-contrib/sessions.Sessions.func1(0xc0005bc690)
	/usr/workspace/pkg/mod/github.com/gin-contrib/sessions@v0.0.3/sessions.go:52 +0x16d
github.com/gin-gonic/gin.(*Context).Next(0xc0005bc690)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/context.go:161 +0x3b
github.com/gin-gonic/gin.serveError(0xc0005bc690, 0x194, 0x1248dc0, 0x12, 0x12)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/gin.go:445 +0x38
github.com/gin-gonic/gin.(*Engine).handleHTTPRequest(0xc0003b8500, 0xc0005bc690)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/gin.go:438 +0x3d3
github.com/gin-gonic/gin.(*Engine).ServeHTTP(0xc0003b8500, 0xd12a40, 0xc0000b8620, 0xc0000f2200)
	/usr/workspace/pkg/mod/github.com/gin-gonic/gin@v1.6.3/gin.go:367 +0x14d
net/http.serverHandler.ServeHTTP(0xc0000b8380, 0xd12a40, 0xc0000b8620, 0xc0000f2200)
	/usr/local/go/src/net/http/server.go:2807 +0xa3
net/http.(*conn).serve(0xc0000be640, 0xd15200, 0xc0003d2480)
	/usr/local/go/src/net/http/server.go:1895 +0x86c
created by net/http.(*Server).Serve
	/usr/local/go/src/net/http/server.go:2933 +0x35c

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 11:13:58][0m  [36;1m[0.50ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 11:13:58][0m  [36;1m[0.68ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 11:13:58][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-22 11:13:58][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-22 11:13:58][0m  [36;1m[0.27ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-22 11:13:58][0m  [36;1m[0.37ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 11:14:24][0m  [36;1m[0.51ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 11:14:24][0m  [36;1m[0.70ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 11:14:24][0m  [36;1m[0.24ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-22 11:14:24][0m  [36;1m[0.66ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-22 11:14:24][0m  [36;1m[1.89ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-22 11:14:24][0m  [36;1m[0.33ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 11:14:28][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 11:14:49][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 11:14:49][0m  [36;1m[0.24ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:144)[0m 
[33m[2020-07-22 11:14:49][0m  [36;1m[0.62ms][0m   SELECT * FROM `blogs` GROUP BY YEAR DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:157)[0m 
[33m[2020-07-22 11:14:49][0m  [36;1m[0.72ms][0m   SELECT * FROM `blogs` where year = 2020 GROUP BY month DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:169)[0m 
[33m[2020-07-22 11:14:49][0m  [36;1m[0.65ms][0m   SELECT * FROM `blogs` where year = 2020 and month = 7 ORDER BY `id` DESC  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-22 11:14:49][0m  [36;1m[0.42ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=4  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-22 11:14:49][0m  [36;1m[0.33ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=3  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-22 11:14:49][0m  [36;1m[0.35ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=2  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-22 11:14:49][0m  [36;1m[0.34ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-22 11:14:53][0m  [36;1m[0.62ms][0m  SELECT * FROM `tags`    
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 11:14:53][0m  [36;1m[0.27ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 11:14:53][0m  [36;1m[0.76ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:31)[0m 
[33m[2020-07-22 11:14:53][0m  [36;1m[2.01ms][0m  SELECT count(*) FROM `tags`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-22 11:15:02][0m  [36;1m[0.55ms][0m  SELECT * FROM `tags`    
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 11:15:02][0m  [36;1m[0.25ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:68)[0m 
[33m[2020-07-22 11:15:02][0m  [36;1m[0.42ms][0m  SELECT * FROM `tags`  WHERE (tag_name='开源') ORDER BY `tags`.`id` ASC LIMIT 1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:76)[0m 
[33m[2020-07-22 11:15:02][0m  [36;1m[0.79ms][0m   SELECT b.id,b.title,b.type_id,t.tag_name,b.description,b.recommend,b.numb,b.update_time,b.image,a.`type_name`  FROM `blogs` b LEFT JOIN `tag_blogs` tb ON b.id = tb.`blog_id` LEFT JOIN tags t ON tb.`tag_id`=t.`id` LEFT JOIN `types` a ON b.type_id = a.`id` WHERE t.`id`=4 ORDER BY b.id  DESC LIMIT 10 OFFSET 0  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:31)[0m 
[33m[2020-07-22 11:15:02][0m  [36;1m[0.22ms][0m  SELECT count(*) FROM `tags`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-22 11:15:03][0m  [36;1m[0.39ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 4)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-22 11:15:03][0m  [36;1m[0.47ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=4  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-22 11:15:03][0m  [36;1m[0.47ms][0m  UPDATE `blogs` SET `title` = '本博客开源公告', `content` = '今天本博客评论功能发布
# 自今天起，本博客基本功能已经完成
## 发布V1.0版本并开源
## 博客语言说明
#### 本博客后端是用golang 的gin框架+gorm编写
前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的
#### 博客效果参考本站
#一、博客简介
## 1.博客目录

    blog
    ├────controller
	├────└───admin
	|	|	├──adminblog.go
	|	|	├───adminController.go
	|	|	├──adminTag.go
	|	|	├──adminType.go
	|	|	└──adminUser.go
	|	└──page
	|		├──404.go
	|		├───about.go
	|		├──archives.go
	|		├──blog.go
	|		├──comment.go
	|		├──pagesController.go
	|		├──researchController.go
	|		└──tagsController.go
    ├── dao
	│	├──blogs.go
	│	├──comment.go
	│	├──sql.go
	│	├──tags.go
	│	├──types.go
	│	└──user.go
    ├── logic
    │   └── user.go
    ├── middlerware
	│	├──function.go
	│	├──getImg.go
	│	├──getTime.go
	│	├──markdown.go
	│	├──select.go
	│	└──session.go
    ├── model
	│	├──blog.go
	│	├──commnent.go
	│	├──tag.go
	│	├──type.go
	│	└──user/go
    ├── static
	│	└──静态文件（头像、图片、logo、css、js等）
    ├── templates
	│	└──html模板文件
    ├── go.mod（依赖）
    └── main.go
    

## 2.相关功能实现简介
### 1、评论及回复功能
comment的结构体属性如下
```go
package model

type Comment struct {
	Id     int //评论id
	BlogId int //博文id
	ReCommentId    int    //父评论id
	CommentName string //评论人姓名
	ReCommentName  string //父评论人姓名
	CommentEmail   string
	Img            string
	CommentContent string `gorm:"type:text" form:"CommentContent" json:"CommentContent"` //评论内容
	CommentTime    string ` json:"comment_time,omitempty"`
	Parent         *Comment
	Comments       []Comment
}
```
#### 实现方法
##### 1先通过查找父评论为-1的顶级评论
父评论Id为-1说明他不是任何评论的子评论
##### 2在html上遍历所有的顶级评论
在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论
###### （1）递归存储每个顶级评论的子评论
这里我用一个切片来储存一个顶级评论的所有子评论
```go
var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
	var comments []model.Comment
	DB.Debug().Where("re_comment_id = -1 AND blog_id = ?", id).Find(&comments)
	return &comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
	if count != 0 {
		fmt.Println("if判断1")
		var comments []model.Comment
		DB.Debug().Where("re_comment_id = ?", id).Find(&comments)
		count = len(comments)
		if count != 0 {
			fmt.Println("if判断2")
			for _, comment := range comments {
				fmt.Println("for判断1")
				Comments = append(Comments, comment)
				SelectCommentByComment(comment.Id, count)
			}
		}
	}
	fmt.Println(Comments)
	return &Comments

}
```
ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来
###### （2）出现问题的原因
因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量
###### （3）解决问题
```go
func ClearComments() bool {
	var comments []model.Comment
	Comments = comments
	return true
}

```
这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现
#### 这里我还加了一个小小的随机头像功能
```go
if  CommentName == user.Name && CommentEmail == user.UserEmail {
		fmt.Println("进入了1")
		comment.Img =user.UserImg
		//找相同评论人
	}else if CommentName == one.CommentName && CommentEmail == one.CommentEmail {
		fmt.Println("进入了2")
		comment.Img =one.Img
		//随机选头像
	}else{
		fmt.Println("进入了3")
		comment.Img =middleware.GetImg()
	}
```
##### 123分别代表三种不同的用户群体
1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
![](/static/images/%e5%a4%b4%e5%83%8f1.png)![](/static/images/%e5%a4%b4%e5%83%8f2.png)![](/static/images/%e5%a4%b4%e5%83%8f3.png)![](/static/images/%e5%a4%b4%e5%83%8f4.png)![](/static/images/%e5%a4%b4%e5%83%8f5.png)![](/static/images/%e5%a4%b4%e5%83%8f6.png)
### 2、归档功能
#### blog的结构体属性如下
```go
package model

type Blog struct {
	Id           int
	Title        string    `form:"title" json:"title"`                          //标题
	Content      string    `gorm:"type:longtext" form:"content" json:"content"` //内容
	Image        string    `gorm:"type:text" form:"image" json:"image"`         //首图
	Numb         int       `form:"numb" json:"numb"`                            //次数
	Flag         string    `form:"flag" json:"flag"`                            //原创或者转载
	Appreciation string    `form:"appreciation" json:"appreciation"`            //打赏开关
	ShareInfo    string    `form:"shareInfo" json:"shareInfo"`                  //版权开关
	Comment      string    `form:"comment" json:"comment"`                      //评论开关
	Recommend    string    `form:"recommend" json:"recommend"`                  //推荐开关
	Description  string    `gorm:"type:text" form:"description" json:"description"`
	CreatTime    string    `form:"creatTime"  json:"creat_time,omitempty"`   //创建时间
	UpdateTime   string    `form:"updateTime"  json:"update_time,omitempty"` //更新时间
	Comments     []Comment `form:"comments" json:"comments"`
	TypeId       int       `form:"typeId" json:"typeId"`
	Type         Type      `form:"type" gorm:"ForeignKey:TypeId"`
	Year         int       `form:"year" json:"year"`
	Month        int       `form:"month" json:"month"`
	Day          int       `form:"day" json:"day"`
}

```
#### 实现方法
我的思路是创建三个时间节点
year month day 
利用sql分组查询
##### Group By分组查询步骤
###### （1）先按照年份查询
###### （2）再按照年份遍历每个月份
并将所有保存在一个切片中
###### （3）按照月份遍历每个月的所有文章
保存在一个Map中，key是对应的月份，value是每个月份的所有文章
#### 自此归档功能实现


## 3.已知BUG
### 后台退出功能
后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧

开源地址
[github](https://github.com/likewl/blog "github")
[gitee](https://gitee.com/nculike/blog "gitee")', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1535821573,4166447487&fm=26&gp=0.jpg', `numb` = 54, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '本博客后端是用golang 的gin框架+gorm编写', `creat_time` = '2020-07-20 15:24:23', `update_time` = '2020-07-20 15:24:23', `type_id` = 4, `year` = 2020, `month` = 7, `day` = 20  WHERE `blogs`.`id` = 4  
[36;31m[1 rows affected or returned ][0m 
<p>今天本博客评论功能发布</p>

<h1>自今天起，本博客基本功能已经完成</h1>

<h2>发布V1.0版本并开源</h2>

<h2>博客语言说明</h2>

<h4>本博客后端是用golang 的gin框架+gorm编写</h4>

<p>前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的</p>

<h4>博客效果参考本站</h4>

<p>#一、博客简介</p>

<h2>1.博客目录</h2>

<pre><code>blog
├────controller
├────└───admin
|   |   ├──adminblog.go
|   |   ├───adminController.go
|   |   ├──adminTag.go
|   |   ├──adminType.go
|   |   └──adminUser.go
|   └──page
|       ├──404.go
|       ├───about.go
|       ├──archives.go
|       ├──blog.go
|       ├──comment.go
|       ├──pagesController.go
|       ├──researchController.go
|       └──tagsController.go
├── dao
│   ├──blogs.go
│   ├──comment.go
│   ├──sql.go
│   ├──tags.go
│   ├──types.go
│   └──user.go
├── logic
│   └── user.go
├── middlerware
│   ├──function.go
│   ├──getImg.go
│   ├──getTime.go
│   ├──markdown.go
│   ├──select.go
│   └──session.go
├── model
│   ├──blog.go
│   ├──commnent.go
│   ├──tag.go
│   ├──type.go
│   └──user/go
├── static
│   └──静态文件（头像、图片、logo、css、js等）
├── templates
│   └──html模板文件
├── go.mod（依赖）
└── main.go
</code></pre>

<h2>2.相关功能实现简介</h2>

<h3>1、评论及回复功能</h3>

<p>comment的结构体属性如下</p>

<pre><code class="language-go">package model

type Comment struct {
    Id     int //评论id
    BlogId int //博文id
    ReCommentId    int    //父评论id
    CommentName string //评论人姓名
    ReCommentName  string //父评论人姓名
    CommentEmail   string
    Img            string
    CommentContent string `gorm:&#34;type:text&#34; form:&#34;CommentContent&#34; json:&#34;CommentContent&#34;` //评论内容
    CommentTime    string ` json:&#34;comment_time,omitempty&#34;`
    Parent         *Comment
    Comments       []Comment
}
</code></pre>

<h4>实现方法</h4>

<h5>1先通过查找父评论为-1的顶级评论</h5>

<p>父评论Id为-1说明他不是任何评论的子评论</p>

<h5>2在html上遍历所有的顶级评论</h5>

<p>在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论</p>

<h6>（1）递归存储每个顶级评论的子评论</h6>

<p>这里我用一个切片来储存一个顶级评论的所有子评论</p>

<pre><code class="language-go">var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
    var comments []model.Comment
    DB.Debug().Where(&#34;re_comment_id = -1 AND blog_id = ?&#34;, id).Find(&amp;comments)
    return &amp;comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
    if count != 0 {
        fmt.Println(&#34;if判断1&#34;)
        var comments []model.Comment
        DB.Debug().Where(&#34;re_comment_id = ?&#34;, id).Find(&amp;comments)
        count = len(comments)
        if count != 0 {
            fmt.Println(&#34;if判断2&#34;)
            for _, comment := range comments {
                fmt.Println(&#34;for判断1&#34;)
                Comments = append(Comments, comment)
                SelectCommentByComment(comment.Id, count)
            }
        }
    }
    fmt.Println(Comments)
    return &amp;Comments

}
</code></pre>

<p>ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来</p>

<h6>（2）出现问题的原因</h6>

<p>因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量</p>

<h6>（3）解决问题</h6>

<pre><code class="language-go">func ClearComments() bool {
    var comments []model.Comment
    Comments = comments
    return true
}

</code></pre>

<p>这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现</p>

<h4>这里我还加了一个小小的随机头像功能</h4>

<pre><code class="language-go">if  CommentName == user.Name &amp;&amp; CommentEmail == user.UserEmail {
        fmt.Println(&#34;进入了1&#34;)
        comment.Img =user.UserImg
        //找相同评论人
    }else if CommentName == one.CommentName &amp;&amp; CommentEmail == one.CommentEmail {
        fmt.Println(&#34;进入了2&#34;)
        comment.Img =one.Img
        //随机选头像
    }else{
        fmt.Println(&#34;进入了3&#34;)
        comment.Img =middleware.GetImg()
    }
</code></pre>

<h5>123分别代表三种不同的用户群体</h5>

<p>1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
<img src="/static/images/%e5%a4%b4%e5%83%8f1.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f2.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f3.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f4.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f5.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f6.png" alt=""/></p>

<h3>2、归档功能</h3>

<h4>blog的结构体属性如下</h4>

<pre><code class="language-go">package model

type Blog struct {
    Id           int
    Title        string    `form:&#34;title&#34; json:&#34;title&#34;`                          //标题
    Content      string    `gorm:&#34;type:longtext&#34; form:&#34;content&#34; json:&#34;content&#34;` //内容
    Image        string    `gorm:&#34;type:text&#34; form:&#34;image&#34; json:&#34;image&#34;`         //首图
    Numb         int       `form:&#34;numb&#34; json:&#34;numb&#34;`                            //次数
    Flag         string    `form:&#34;flag&#34; json:&#34;flag&#34;`                            //原创或者转载
    Appreciation string    `form:&#34;appreciation&#34; json:&#34;appreciation&#34;`            //打赏开关
    ShareInfo    string    `form:&#34;shareInfo&#34; json:&#34;shareInfo&#34;`                  //版权开关
    Comment      string    `form:&#34;comment&#34; json:&#34;comment&#34;`                      //评论开关
    Recommend    string    `form:&#34;recommend&#34; json:&#34;recommend&#34;`                  //推荐开关
    Description  string    `gorm:&#34;type:text&#34; form:&#34;description&#34; json:&#34;description&#34;`
    CreatTime    string    `form:&#34;creatTime&#34;  json:&#34;creat_time,omitempty&#34;`   //创建时间
    UpdateTime   string    `form:&#34;updateTime&#34;  json:&#34;update_time,omitempty&#34;` //更新时间
    Comments     []Comment `form:&#34;comments&#34; json:&#34;comments&#34;`
    TypeId       int       `form:&#34;typeId&#34; json:&#34;typeId&#34;`
    Type         Type      `form:&#34;type&#34; gorm:&#34;ForeignKey:TypeId&#34;`
    Year         int       `form:&#34;year&#34; json:&#34;year&#34;`
    Month        int       `form:&#34;month&#34; json:&#34;month&#34;`
    Day          int       `form:&#34;day&#34; json:&#34;day&#34;`
}

</code></pre>

<h4>实现方法</h4>

<p>我的思路是创建三个时间节点
year month day
利用sql分组查询</p>

<h5>Group By分组查询步骤</h5>

<h6>（1）先按照年份查询</h6>

<h6>（2）再按照年份遍历每个月份</h6>

<p>并将所有保存在一个切片中</p>

<h6>（3）按照月份遍历每个月的所有文章</h6>

<p>保存在一个Map中，key是对应的月份，value是每个月份的所有文章</p>

<h4>自此归档功能实现</h4>

<h2>3.已知BUG</h2>

<h3>后台退出功能</h3>

<p>后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧</p>

<p>开源地址
<a href="https://github.com/likewl/blog" title="github" rel="nofollow">github</a>
<a href="https://gitee.com/nculike/blog" title="gitee" rel="nofollow">gitee</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 11:15:03][0m  [36;1m[0.30ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 11:15:24][0m  [36;1m[0.52ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 11:15:24][0m  [36;1m[0.71ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 11:15:24][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-22 11:15:24][0m  [36;1m[0.28ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-22 11:15:24][0m  [36;1m[0.25ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-22 11:15:24][0m  [36;1m[0.32ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 11:15:28][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 11:21:14][0m  [36;1m[0.60ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 11:21:14][0m  [36;1m[0.81ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 11:21:14][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-22 11:21:14][0m  [36;1m[0.40ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-22 11:21:14][0m  [36;1m[0.33ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-22 11:21:14][0m  [36;1m[0.32ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 11:21:17][0m  [36;1m[0.62ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 11:51:41][0m  [36;1m[0.51ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 11:51:41][0m  [36;1m[0.69ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 11:51:41][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-22 11:51:41][0m  [36;1m[0.31ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-22 11:51:41][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-22 11:51:41][0m  [36;1m[0.31ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 12:03:21][0m  [36;1m[0.63ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 12:03:21][0m  [36;1m[0.80ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 12:03:21][0m  [36;1m[0.27ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-22 12:03:21][0m  [36;1m[0.38ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-22 12:03:21][0m  [36;1m[0.29ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-22 12:03:21][0m  [36;1m[0.34ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 12:16:33][0m  [36;1m[0.59ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 12:16:33][0m  [36;1m[0.73ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 12:16:33][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-22 12:16:33][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-22 12:16:33][0m  [36;1m[0.27ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-22 12:16:33][0m  [36;1m[0.34ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 12:17:56][0m  [36;1m[0.58ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 12:17:56][0m  [36;1m[0.72ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 12:17:56][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-22 12:17:56][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-22 12:17:56][0m  [36;1m[0.30ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-22 12:17:56][0m  [36;1m[0.34ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-22 12:18:46][0m  [36;1m[0.42ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 4)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-22 12:18:46][0m  [36;1m[0.44ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=4  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-22 12:18:46][0m  [36;1m[0.42ms][0m  UPDATE `blogs` SET `title` = '本博客开源公告', `content` = '今天本博客评论功能发布
# 自今天起，本博客基本功能已经完成
## 发布V1.0版本并开源
## 博客语言说明
#### 本博客后端是用golang 的gin框架+gorm编写
前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的
#### 博客效果参考本站
#一、博客简介
## 1.博客目录

    blog
    ├────controller
	├────└───admin
	|	|	├──adminblog.go
	|	|	├───adminController.go
	|	|	├──adminTag.go
	|	|	├──adminType.go
	|	|	└──adminUser.go
	|	└──page
	|		├──404.go
	|		├───about.go
	|		├──archives.go
	|		├──blog.go
	|		├──comment.go
	|		├──pagesController.go
	|		├──researchController.go
	|		└──tagsController.go
    ├── dao
	│	├──blogs.go
	│	├──comment.go
	│	├──sql.go
	│	├──tags.go
	│	├──types.go
	│	└──user.go
    ├── logic
    │   └── user.go
    ├── middlerware
	│	├──function.go
	│	├──getImg.go
	│	├──getTime.go
	│	├──markdown.go
	│	├──select.go
	│	└──session.go
    ├── model
	│	├──blog.go
	│	├──commnent.go
	│	├──tag.go
	│	├──type.go
	│	└──user/go
    ├── static
	│	└──静态文件（头像、图片、logo、css、js等）
    ├── templates
	│	└──html模板文件
    ├── go.mod（依赖）
    └── main.go
    

## 2.相关功能实现简介
### 1、评论及回复功能
comment的结构体属性如下
```go
package model

type Comment struct {
	Id     int //评论id
	BlogId int //博文id
	ReCommentId    int    //父评论id
	CommentName string //评论人姓名
	ReCommentName  string //父评论人姓名
	CommentEmail   string
	Img            string
	CommentContent string `gorm:"type:text" form:"CommentContent" json:"CommentContent"` //评论内容
	CommentTime    string ` json:"comment_time,omitempty"`
	Parent         *Comment
	Comments       []Comment
}
```
#### 实现方法
##### 1先通过查找父评论为-1的顶级评论
父评论Id为-1说明他不是任何评论的子评论
##### 2在html上遍历所有的顶级评论
在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论
###### （1）递归存储每个顶级评论的子评论
这里我用一个切片来储存一个顶级评论的所有子评论
```go
var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
	var comments []model.Comment
	DB.Debug().Where("re_comment_id = -1 AND blog_id = ?", id).Find(&comments)
	return &comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
	if count != 0 {
		fmt.Println("if判断1")
		var comments []model.Comment
		DB.Debug().Where("re_comment_id = ?", id).Find(&comments)
		count = len(comments)
		if count != 0 {
			fmt.Println("if判断2")
			for _, comment := range comments {
				fmt.Println("for判断1")
				Comments = append(Comments, comment)
				SelectCommentByComment(comment.Id, count)
			}
		}
	}
	fmt.Println(Comments)
	return &Comments

}
```
ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来
###### （2）出现问题的原因
因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量
###### （3）解决问题
```go
func ClearComments() bool {
	var comments []model.Comment
	Comments = comments
	return true
}

```
这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现
#### 这里我还加了一个小小的随机头像功能
```go
if  CommentName == user.Name && CommentEmail == user.UserEmail {
		fmt.Println("进入了1")
		comment.Img =user.UserImg
		//找相同评论人
	}else if CommentName == one.CommentName && CommentEmail == one.CommentEmail {
		fmt.Println("进入了2")
		comment.Img =one.Img
		//随机选头像
	}else{
		fmt.Println("进入了3")
		comment.Img =middleware.GetImg()
	}
```
##### 123分别代表三种不同的用户群体
1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
![](/static/images/%e5%a4%b4%e5%83%8f1.png)![](/static/images/%e5%a4%b4%e5%83%8f2.png)![](/static/images/%e5%a4%b4%e5%83%8f3.png)![](/static/images/%e5%a4%b4%e5%83%8f4.png)![](/static/images/%e5%a4%b4%e5%83%8f5.png)![](/static/images/%e5%a4%b4%e5%83%8f6.png)
### 2、归档功能
#### blog的结构体属性如下
```go
package model

type Blog struct {
	Id           int
	Title        string    `form:"title" json:"title"`                          //标题
	Content      string    `gorm:"type:longtext" form:"content" json:"content"` //内容
	Image        string    `gorm:"type:text" form:"image" json:"image"`         //首图
	Numb         int       `form:"numb" json:"numb"`                            //次数
	Flag         string    `form:"flag" json:"flag"`                            //原创或者转载
	Appreciation string    `form:"appreciation" json:"appreciation"`            //打赏开关
	ShareInfo    string    `form:"shareInfo" json:"shareInfo"`                  //版权开关
	Comment      string    `form:"comment" json:"comment"`                      //评论开关
	Recommend    string    `form:"recommend" json:"recommend"`                  //推荐开关
	Description  string    `gorm:"type:text" form:"description" json:"description"`
	CreatTime    string    `form:"creatTime"  json:"creat_time,omitempty"`   //创建时间
	UpdateTime   string    `form:"updateTime"  json:"update_time,omitempty"` //更新时间
	Comments     []Comment `form:"comments" json:"comments"`
	TypeId       int       `form:"typeId" json:"typeId"`
	Type         Type      `form:"type" gorm:"ForeignKey:TypeId"`
	Year         int       `form:"year" json:"year"`
	Month        int       `form:"month" json:"month"`
	Day          int       `form:"day" json:"day"`
}

```
#### 实现方法
我的思路是创建三个时间节点
year month day 
利用sql分组查询
##### Group By分组查询步骤
###### （1）先按照年份查询
###### （2）再按照年份遍历每个月份
并将所有保存在一个切片中
###### （3）按照月份遍历每个月的所有文章
保存在一个Map中，key是对应的月份，value是每个月份的所有文章
#### 自此归档功能实现


## 3.已知BUG
### 后台退出功能
后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧

开源地址
[github](https://github.com/likewl/blog "github")
[gitee](https://gitee.com/nculike/blog "gitee")', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1535821573,4166447487&fm=26&gp=0.jpg', `numb` = 55, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '本博客后端是用golang 的gin框架+gorm编写', `creat_time` = '2020-07-20 15:24:23', `update_time` = '2020-07-20 15:24:23', `type_id` = 4, `year` = 2020, `month` = 7, `day` = 20  WHERE `blogs`.`id` = 4  
[36;31m[1 rows affected or returned ][0m 
<p>今天本博客评论功能发布</p>

<h1>自今天起，本博客基本功能已经完成</h1>

<h2>发布V1.0版本并开源</h2>

<h2>博客语言说明</h2>

<h4>本博客后端是用golang 的gin框架+gorm编写</h4>

<p>前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的</p>

<h4>博客效果参考本站</h4>

<p>#一、博客简介</p>

<h2>1.博客目录</h2>

<pre><code>blog
├────controller
├────└───admin
|   |   ├──adminblog.go
|   |   ├───adminController.go
|   |   ├──adminTag.go
|   |   ├──adminType.go
|   |   └──adminUser.go
|   └──page
|       ├──404.go
|       ├───about.go
|       ├──archives.go
|       ├──blog.go
|       ├──comment.go
|       ├──pagesController.go
|       ├──researchController.go
|       └──tagsController.go
├── dao
│   ├──blogs.go
│   ├──comment.go
│   ├──sql.go
│   ├──tags.go
│   ├──types.go
│   └──user.go
├── logic
│   └── user.go
├── middlerware
│   ├──function.go
│   ├──getImg.go
│   ├──getTime.go
│   ├──markdown.go
│   ├──select.go
│   └──session.go
├── model
│   ├──blog.go
│   ├──commnent.go
│   ├──tag.go
│   ├──type.go
│   └──user/go
├── static
│   └──静态文件（头像、图片、logo、css、js等）
├── templates
│   └──html模板文件
├── go.mod（依赖）
└── main.go
</code></pre>

<h2>2.相关功能实现简介</h2>

<h3>1、评论及回复功能</h3>

<p>comment的结构体属性如下</p>

<pre><code class="language-go">package model

type Comment struct {
    Id     int //评论id
    BlogId int //博文id
    ReCommentId    int    //父评论id
    CommentName string //评论人姓名
    ReCommentName  string //父评论人姓名
    CommentEmail   string
    Img            string
    CommentContent string `gorm:&#34;type:text&#34; form:&#34;CommentContent&#34; json:&#34;CommentContent&#34;` //评论内容
    CommentTime    string ` json:&#34;comment_time,omitempty&#34;`
    Parent         *Comment
    Comments       []Comment
}
</code></pre>

<h4>实现方法</h4>

<h5>1先通过查找父评论为-1的顶级评论</h5>

<p>父评论Id为-1说明他不是任何评论的子评论</p>

<h5>2在html上遍历所有的顶级评论</h5>

<p>在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论</p>

<h6>（1）递归存储每个顶级评论的子评论</h6>

<p>这里我用一个切片来储存一个顶级评论的所有子评论</p>

<pre><code class="language-go">var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
    var comments []model.Comment
    DB.Debug().Where(&#34;re_comment_id = -1 AND blog_id = ?&#34;, id).Find(&amp;comments)
    return &amp;comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
    if count != 0 {
        fmt.Println(&#34;if判断1&#34;)
        var comments []model.Comment
        DB.Debug().Where(&#34;re_comment_id = ?&#34;, id).Find(&amp;comments)
        count = len(comments)
        if count != 0 {
            fmt.Println(&#34;if判断2&#34;)
            for _, comment := range comments {
                fmt.Println(&#34;for判断1&#34;)
                Comments = append(Comments, comment)
                SelectCommentByComment(comment.Id, count)
            }
        }
    }
    fmt.Println(Comments)
    return &amp;Comments

}
</code></pre>

<p>ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来</p>

<h6>（2）出现问题的原因</h6>

<p>因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量</p>

<h6>（3）解决问题</h6>

<pre><code class="language-go">func ClearComments() bool {
    var comments []model.Comment
    Comments = comments
    return true
}

</code></pre>

<p>这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现</p>

<h4>这里我还加了一个小小的随机头像功能</h4>

<pre><code class="language-go">if  CommentName == user.Name &amp;&amp; CommentEmail == user.UserEmail {
        fmt.Println(&#34;进入了1&#34;)
        comment.Img =user.UserImg
        //找相同评论人
    }else if CommentName == one.CommentName &amp;&amp; CommentEmail == one.CommentEmail {
        fmt.Println(&#34;进入了2&#34;)
        comment.Img =one.Img
        //随机选头像
    }else{
        fmt.Println(&#34;进入了3&#34;)
        comment.Img =middleware.GetImg()
    }
</code></pre>

<h5>123分别代表三种不同的用户群体</h5>

<p>1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
<img src="/static/images/%e5%a4%b4%e5%83%8f1.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f2.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f3.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f4.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f5.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f6.png" alt=""/></p>

<h3>2、归档功能</h3>

<h4>blog的结构体属性如下</h4>

<pre><code class="language-go">package model

type Blog struct {
    Id           int
    Title        string    `form:&#34;title&#34; json:&#34;title&#34;`                          //标题
    Content      string    `gorm:&#34;type:longtext&#34; form:&#34;content&#34; json:&#34;content&#34;` //内容
    Image        string    `gorm:&#34;type:text&#34; form:&#34;image&#34; json:&#34;image&#34;`         //首图
    Numb         int       `form:&#34;numb&#34; json:&#34;numb&#34;`                            //次数
    Flag         string    `form:&#34;flag&#34; json:&#34;flag&#34;`                            //原创或者转载
    Appreciation string    `form:&#34;appreciation&#34; json:&#34;appreciation&#34;`            //打赏开关
    ShareInfo    string    `form:&#34;shareInfo&#34; json:&#34;shareInfo&#34;`                  //版权开关
    Comment      string    `form:&#34;comment&#34; json:&#34;comment&#34;`                      //评论开关
    Recommend    string    `form:&#34;recommend&#34; json:&#34;recommend&#34;`                  //推荐开关
    Description  string    `gorm:&#34;type:text&#34; form:&#34;description&#34; json:&#34;description&#34;`
    CreatTime    string    `form:&#34;creatTime&#34;  json:&#34;creat_time,omitempty&#34;`   //创建时间
    UpdateTime   string    `form:&#34;updateTime&#34;  json:&#34;update_time,omitempty&#34;` //更新时间
    Comments     []Comment `form:&#34;comments&#34; json:&#34;comments&#34;`
    TypeId       int       `form:&#34;typeId&#34; json:&#34;typeId&#34;`
    Type         Type      `form:&#34;type&#34; gorm:&#34;ForeignKey:TypeId&#34;`
    Year         int       `form:&#34;year&#34; json:&#34;year&#34;`
    Month        int       `form:&#34;month&#34; json:&#34;month&#34;`
    Day          int       `form:&#34;day&#34; json:&#34;day&#34;`
}

</code></pre>

<h4>实现方法</h4>

<p>我的思路是创建三个时间节点
year month day
利用sql分组查询</p>

<h5>Group By分组查询步骤</h5>

<h6>（1）先按照年份查询</h6>

<h6>（2）再按照年份遍历每个月份</h6>

<p>并将所有保存在一个切片中</p>

<h6>（3）按照月份遍历每个月的所有文章</h6>

<p>保存在一个Map中，key是对应的月份，value是每个月份的所有文章</p>

<h4>自此归档功能实现</h4>

<h2>3.已知BUG</h2>

<h3>后台退出功能</h3>

<p>后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧</p>

<p>开源地址
<a href="https://github.com/likewl/blog" title="github" rel="nofollow">github</a>
<a href="https://gitee.com/nculike/blog" title="gitee" rel="nofollow">gitee</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 12:18:46][0m  [36;1m[0.24ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-22 12:23:14][0m  [36;1m[0.36ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 4)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-22 12:23:14][0m  [36;1m[0.43ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=4  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-22 12:23:14][0m  [36;1m[0.44ms][0m  UPDATE `blogs` SET `title` = '本博客开源公告', `content` = '今天本博客评论功能发布
# 自今天起，本博客基本功能已经完成
## 发布V1.0版本并开源
## 博客语言说明
#### 本博客后端是用golang 的gin框架+gorm编写
前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的
#### 博客效果参考本站
#一、博客简介
## 1.博客目录

    blog
    ├────controller
	├────└───admin
	|	|	├──adminblog.go
	|	|	├───adminController.go
	|	|	├──adminTag.go
	|	|	├──adminType.go
	|	|	└──adminUser.go
	|	└──page
	|		├──404.go
	|		├───about.go
	|		├──archives.go
	|		├──blog.go
	|		├──comment.go
	|		├──pagesController.go
	|		├──researchController.go
	|		└──tagsController.go
    ├── dao
	│	├──blogs.go
	│	├──comment.go
	│	├──sql.go
	│	├──tags.go
	│	├──types.go
	│	└──user.go
    ├── logic
    │   └── user.go
    ├── middlerware
	│	├──function.go
	│	├──getImg.go
	│	├──getTime.go
	│	├──markdown.go
	│	├──select.go
	│	└──session.go
    ├── model
	│	├──blog.go
	│	├──commnent.go
	│	├──tag.go
	│	├──type.go
	│	└──user/go
    ├── static
	│	└──静态文件（头像、图片、logo、css、js等）
    ├── templates
	│	└──html模板文件
    ├── go.mod（依赖）
    └── main.go
    

## 2.相关功能实现简介
### 1、评论及回复功能
comment的结构体属性如下
```go
package model

type Comment struct {
	Id     int //评论id
	BlogId int //博文id
	ReCommentId    int    //父评论id
	CommentName string //评论人姓名
	ReCommentName  string //父评论人姓名
	CommentEmail   string
	Img            string
	CommentContent string `gorm:"type:text" form:"CommentContent" json:"CommentContent"` //评论内容
	CommentTime    string ` json:"comment_time,omitempty"`
	Parent         *Comment
	Comments       []Comment
}
```
#### 实现方法
##### 1先通过查找父评论为-1的顶级评论
父评论Id为-1说明他不是任何评论的子评论
##### 2在html上遍历所有的顶级评论
在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论
###### （1）递归存储每个顶级评论的子评论
这里我用一个切片来储存一个顶级评论的所有子评论
```go
var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
	var comments []model.Comment
	DB.Debug().Where("re_comment_id = -1 AND blog_id = ?", id).Find(&comments)
	return &comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
	if count != 0 {
		fmt.Println("if判断1")
		var comments []model.Comment
		DB.Debug().Where("re_comment_id = ?", id).Find(&comments)
		count = len(comments)
		if count != 0 {
			fmt.Println("if判断2")
			for _, comment := range comments {
				fmt.Println("for判断1")
				Comments = append(Comments, comment)
				SelectCommentByComment(comment.Id, count)
			}
		}
	}
	fmt.Println(Comments)
	return &Comments

}
```
ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来
###### （2）出现问题的原因
因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量
###### （3）解决问题
```go
func ClearComments() bool {
	var comments []model.Comment
	Comments = comments
	return true
}

```
这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现
#### 这里我还加了一个小小的随机头像功能
```go
if  CommentName == user.Name && CommentEmail == user.UserEmail {
		fmt.Println("进入了1")
		comment.Img =user.UserImg
		//找相同评论人
	}else if CommentName == one.CommentName && CommentEmail == one.CommentEmail {
		fmt.Println("进入了2")
		comment.Img =one.Img
		//随机选头像
	}else{
		fmt.Println("进入了3")
		comment.Img =middleware.GetImg()
	}
```
##### 123分别代表三种不同的用户群体
1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
![](/static/images/%e5%a4%b4%e5%83%8f1.png)![](/static/images/%e5%a4%b4%e5%83%8f2.png)![](/static/images/%e5%a4%b4%e5%83%8f3.png)![](/static/images/%e5%a4%b4%e5%83%8f4.png)![](/static/images/%e5%a4%b4%e5%83%8f5.png)![](/static/images/%e5%a4%b4%e5%83%8f6.png)
### 2、归档功能
#### blog的结构体属性如下
```go
package model

type Blog struct {
	Id           int
	Title        string    `form:"title" json:"title"`                          //标题
	Content      string    `gorm:"type:longtext" form:"content" json:"content"` //内容
	Image        string    `gorm:"type:text" form:"image" json:"image"`         //首图
	Numb         int       `form:"numb" json:"numb"`                            //次数
	Flag         string    `form:"flag" json:"flag"`                            //原创或者转载
	Appreciation string    `form:"appreciation" json:"appreciation"`            //打赏开关
	ShareInfo    string    `form:"shareInfo" json:"shareInfo"`                  //版权开关
	Comment      string    `form:"comment" json:"comment"`                      //评论开关
	Recommend    string    `form:"recommend" json:"recommend"`                  //推荐开关
	Description  string    `gorm:"type:text" form:"description" json:"description"`
	CreatTime    string    `form:"creatTime"  json:"creat_time,omitempty"`   //创建时间
	UpdateTime   string    `form:"updateTime"  json:"update_time,omitempty"` //更新时间
	Comments     []Comment `form:"comments" json:"comments"`
	TypeId       int       `form:"typeId" json:"typeId"`
	Type         Type      `form:"type" gorm:"ForeignKey:TypeId"`
	Year         int       `form:"year" json:"year"`
	Month        int       `form:"month" json:"month"`
	Day          int       `form:"day" json:"day"`
}

```
#### 实现方法
我的思路是创建三个时间节点
year month day 
利用sql分组查询
##### Group By分组查询步骤
###### （1）先按照年份查询
###### （2）再按照年份遍历每个月份
并将所有保存在一个切片中
###### （3）按照月份遍历每个月的所有文章
保存在一个Map中，key是对应的月份，value是每个月份的所有文章
#### 自此归档功能实现


## 3.已知BUG
### 后台退出功能
后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧

开源地址
[github](https://github.com/likewl/blog "github")
[gitee](https://gitee.com/nculike/blog "gitee")', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1535821573,4166447487&fm=26&gp=0.jpg', `numb` = 56, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '本博客后端是用golang 的gin框架+gorm编写', `creat_time` = '2020-07-20 15:24:23', `update_time` = '2020-07-20 15:24:23', `type_id` = 4, `year` = 2020, `month` = 7, `day` = 20  WHERE `blogs`.`id` = 4  
[36;31m[1 rows affected or returned ][0m 
<p>今天本博客评论功能发布</p>

<h1>自今天起，本博客基本功能已经完成</h1>

<h2>发布V1.0版本并开源</h2>

<h2>博客语言说明</h2>

<h4>本博客后端是用golang 的gin框架+gorm编写</h4>

<p>前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的</p>

<h4>博客效果参考本站</h4>

<p>#一、博客简介</p>

<h2>1.博客目录</h2>

<pre><code>blog
├────controller
├────└───admin
|   |   ├──adminblog.go
|   |   ├───adminController.go
|   |   ├──adminTag.go
|   |   ├──adminType.go
|   |   └──adminUser.go
|   └──page
|       ├──404.go
|       ├───about.go
|       ├──archives.go
|       ├──blog.go
|       ├──comment.go
|       ├──pagesController.go
|       ├──researchController.go
|       └──tagsController.go
├── dao
│   ├──blogs.go
│   ├──comment.go
│   ├──sql.go
│   ├──tags.go
│   ├──types.go
│   └──user.go
├── logic
│   └── user.go
├── middlerware
│   ├──function.go
│   ├──getImg.go
│   ├──getTime.go
│   ├──markdown.go
│   ├──select.go
│   └──session.go
├── model
│   ├──blog.go
│   ├──commnent.go
│   ├──tag.go
│   ├──type.go
│   └──user/go
├── static
│   └──静态文件（头像、图片、logo、css、js等）
├── templates
│   └──html模板文件
├── go.mod（依赖）
└── main.go
</code></pre>

<h2>2.相关功能实现简介</h2>

<h3>1、评论及回复功能</h3>

<p>comment的结构体属性如下</p>

<pre><code class="language-go">package model

type Comment struct {
    Id     int //评论id
    BlogId int //博文id
    ReCommentId    int    //父评论id
    CommentName string //评论人姓名
    ReCommentName  string //父评论人姓名
    CommentEmail   string
    Img            string
    CommentContent string `gorm:&#34;type:text&#34; form:&#34;CommentContent&#34; json:&#34;CommentContent&#34;` //评论内容
    CommentTime    string ` json:&#34;comment_time,omitempty&#34;`
    Parent         *Comment
    Comments       []Comment
}
</code></pre>

<h4>实现方法</h4>

<h5>1先通过查找父评论为-1的顶级评论</h5>

<p>父评论Id为-1说明他不是任何评论的子评论</p>

<h5>2在html上遍历所有的顶级评论</h5>

<p>在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论</p>

<h6>（1）递归存储每个顶级评论的子评论</h6>

<p>这里我用一个切片来储存一个顶级评论的所有子评论</p>

<pre><code class="language-go">var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
    var comments []model.Comment
    DB.Debug().Where(&#34;re_comment_id = -1 AND blog_id = ?&#34;, id).Find(&amp;comments)
    return &amp;comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
    if count != 0 {
        fmt.Println(&#34;if判断1&#34;)
        var comments []model.Comment
        DB.Debug().Where(&#34;re_comment_id = ?&#34;, id).Find(&amp;comments)
        count = len(comments)
        if count != 0 {
            fmt.Println(&#34;if判断2&#34;)
            for _, comment := range comments {
                fmt.Println(&#34;for判断1&#34;)
                Comments = append(Comments, comment)
                SelectCommentByComment(comment.Id, count)
            }
        }
    }
    fmt.Println(Comments)
    return &amp;Comments

}
</code></pre>

<p>ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来</p>

<h6>（2）出现问题的原因</h6>

<p>因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量</p>

<h6>（3）解决问题</h6>

<pre><code class="language-go">func ClearComments() bool {
    var comments []model.Comment
    Comments = comments
    return true
}

</code></pre>

<p>这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现</p>

<h4>这里我还加了一个小小的随机头像功能</h4>

<pre><code class="language-go">if  CommentName == user.Name &amp;&amp; CommentEmail == user.UserEmail {
        fmt.Println(&#34;进入了1&#34;)
        comment.Img =user.UserImg
        //找相同评论人
    }else if CommentName == one.CommentName &amp;&amp; CommentEmail == one.CommentEmail {
        fmt.Println(&#34;进入了2&#34;)
        comment.Img =one.Img
        //随机选头像
    }else{
        fmt.Println(&#34;进入了3&#34;)
        comment.Img =middleware.GetImg()
    }
</code></pre>

<h5>123分别代表三种不同的用户群体</h5>

<p>1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
<img src="/static/images/%e5%a4%b4%e5%83%8f1.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f2.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f3.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f4.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f5.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f6.png" alt=""/></p>

<h3>2、归档功能</h3>

<h4>blog的结构体属性如下</h4>

<pre><code class="language-go">package model

type Blog struct {
    Id           int
    Title        string    `form:&#34;title&#34; json:&#34;title&#34;`                          //标题
    Content      string    `gorm:&#34;type:longtext&#34; form:&#34;content&#34; json:&#34;content&#34;` //内容
    Image        string    `gorm:&#34;type:text&#34; form:&#34;image&#34; json:&#34;image&#34;`         //首图
    Numb         int       `form:&#34;numb&#34; json:&#34;numb&#34;`                            //次数
    Flag         string    `form:&#34;flag&#34; json:&#34;flag&#34;`                            //原创或者转载
    Appreciation string    `form:&#34;appreciation&#34; json:&#34;appreciation&#34;`            //打赏开关
    ShareInfo    string    `form:&#34;shareInfo&#34; json:&#34;shareInfo&#34;`                  //版权开关
    Comment      string    `form:&#34;comment&#34; json:&#34;comment&#34;`                      //评论开关
    Recommend    string    `form:&#34;recommend&#34; json:&#34;recommend&#34;`                  //推荐开关
    Description  string    `gorm:&#34;type:text&#34; form:&#34;description&#34; json:&#34;description&#34;`
    CreatTime    string    `form:&#34;creatTime&#34;  json:&#34;creat_time,omitempty&#34;`   //创建时间
    UpdateTime   string    `form:&#34;updateTime&#34;  json:&#34;update_time,omitempty&#34;` //更新时间
    Comments     []Comment `form:&#34;comments&#34; json:&#34;comments&#34;`
    TypeId       int       `form:&#34;typeId&#34; json:&#34;typeId&#34;`
    Type         Type      `form:&#34;type&#34; gorm:&#34;ForeignKey:TypeId&#34;`
    Year         int       `form:&#34;year&#34; json:&#34;year&#34;`
    Month        int       `form:&#34;month&#34; json:&#34;month&#34;`
    Day          int       `form:&#34;day&#34; json:&#34;day&#34;`
}

</code></pre>

<h4>实现方法</h4>

<p>我的思路是创建三个时间节点
year month day
利用sql分组查询</p>

<h5>Group By分组查询步骤</h5>

<h6>（1）先按照年份查询</h6>

<h6>（2）再按照年份遍历每个月份</h6>

<p>并将所有保存在一个切片中</p>

<h6>（3）按照月份遍历每个月的所有文章</h6>

<p>保存在一个Map中，key是对应的月份，value是每个月份的所有文章</p>

<h4>自此归档功能实现</h4>

<h2>3.已知BUG</h2>

<h3>后台退出功能</h3>

<p>后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧</p>

<p>开源地址
<a href="https://github.com/likewl/blog" title="github" rel="nofollow">github</a>
<a href="https://gitee.com/nculike/blog" title="gitee" rel="nofollow">gitee</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 12:23:14][0m  [36;1m[0.27ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-22 12:23:32][0m  [36;1m[0.36ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 4)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-22 12:23:32][0m  [36;1m[0.43ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=4  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-22 12:23:32][0m  [36;1m[0.43ms][0m  UPDATE `blogs` SET `title` = '本博客开源公告', `content` = '今天本博客评论功能发布
# 自今天起，本博客基本功能已经完成
## 发布V1.0版本并开源
## 博客语言说明
#### 本博客后端是用golang 的gin框架+gorm编写
前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的
#### 博客效果参考本站
#一、博客简介
## 1.博客目录

    blog
    ├────controller
	├────└───admin
	|	|	├──adminblog.go
	|	|	├───adminController.go
	|	|	├──adminTag.go
	|	|	├──adminType.go
	|	|	└──adminUser.go
	|	└──page
	|		├──404.go
	|		├───about.go
	|		├──archives.go
	|		├──blog.go
	|		├──comment.go
	|		├──pagesController.go
	|		├──researchController.go
	|		└──tagsController.go
    ├── dao
	│	├──blogs.go
	│	├──comment.go
	│	├──sql.go
	│	├──tags.go
	│	├──types.go
	│	└──user.go
    ├── logic
    │   └── user.go
    ├── middlerware
	│	├──function.go
	│	├──getImg.go
	│	├──getTime.go
	│	├──markdown.go
	│	├──select.go
	│	└──session.go
    ├── model
	│	├──blog.go
	│	├──commnent.go
	│	├──tag.go
	│	├──type.go
	│	└──user/go
    ├── static
	│	└──静态文件（头像、图片、logo、css、js等）
    ├── templates
	│	└──html模板文件
    ├── go.mod（依赖）
    └── main.go
    

## 2.相关功能实现简介
### 1、评论及回复功能
comment的结构体属性如下
```go
package model

type Comment struct {
	Id     int //评论id
	BlogId int //博文id
	ReCommentId    int    //父评论id
	CommentName string //评论人姓名
	ReCommentName  string //父评论人姓名
	CommentEmail   string
	Img            string
	CommentContent string `gorm:"type:text" form:"CommentContent" json:"CommentContent"` //评论内容
	CommentTime    string ` json:"comment_time,omitempty"`
	Parent         *Comment
	Comments       []Comment
}
```
#### 实现方法
##### 1先通过查找父评论为-1的顶级评论
父评论Id为-1说明他不是任何评论的子评论
##### 2在html上遍历所有的顶级评论
在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论
###### （1）递归存储每个顶级评论的子评论
这里我用一个切片来储存一个顶级评论的所有子评论
```go
var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
	var comments []model.Comment
	DB.Debug().Where("re_comment_id = -1 AND blog_id = ?", id).Find(&comments)
	return &comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
	if count != 0 {
		fmt.Println("if判断1")
		var comments []model.Comment
		DB.Debug().Where("re_comment_id = ?", id).Find(&comments)
		count = len(comments)
		if count != 0 {
			fmt.Println("if判断2")
			for _, comment := range comments {
				fmt.Println("for判断1")
				Comments = append(Comments, comment)
				SelectCommentByComment(comment.Id, count)
			}
		}
	}
	fmt.Println(Comments)
	return &Comments

}
```
ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来
###### （2）出现问题的原因
因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量
###### （3）解决问题
```go
func ClearComments() bool {
	var comments []model.Comment
	Comments = comments
	return true
}

```
这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现
#### 这里我还加了一个小小的随机头像功能
```go
if  CommentName == user.Name && CommentEmail == user.UserEmail {
		fmt.Println("进入了1")
		comment.Img =user.UserImg
		//找相同评论人
	}else if CommentName == one.CommentName && CommentEmail == one.CommentEmail {
		fmt.Println("进入了2")
		comment.Img =one.Img
		//随机选头像
	}else{
		fmt.Println("进入了3")
		comment.Img =middleware.GetImg()
	}
```
##### 123分别代表三种不同的用户群体
1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
![](/static/images/%e5%a4%b4%e5%83%8f1.png)![](/static/images/%e5%a4%b4%e5%83%8f2.png)![](/static/images/%e5%a4%b4%e5%83%8f3.png)![](/static/images/%e5%a4%b4%e5%83%8f4.png)![](/static/images/%e5%a4%b4%e5%83%8f5.png)![](/static/images/%e5%a4%b4%e5%83%8f6.png)
### 2、归档功能
#### blog的结构体属性如下
```go
package model

type Blog struct {
	Id           int
	Title        string    `form:"title" json:"title"`                          //标题
	Content      string    `gorm:"type:longtext" form:"content" json:"content"` //内容
	Image        string    `gorm:"type:text" form:"image" json:"image"`         //首图
	Numb         int       `form:"numb" json:"numb"`                            //次数
	Flag         string    `form:"flag" json:"flag"`                            //原创或者转载
	Appreciation string    `form:"appreciation" json:"appreciation"`            //打赏开关
	ShareInfo    string    `form:"shareInfo" json:"shareInfo"`                  //版权开关
	Comment      string    `form:"comment" json:"comment"`                      //评论开关
	Recommend    string    `form:"recommend" json:"recommend"`                  //推荐开关
	Description  string    `gorm:"type:text" form:"description" json:"description"`
	CreatTime    string    `form:"creatTime"  json:"creat_time,omitempty"`   //创建时间
	UpdateTime   string    `form:"updateTime"  json:"update_time,omitempty"` //更新时间
	Comments     []Comment `form:"comments" json:"comments"`
	TypeId       int       `form:"typeId" json:"typeId"`
	Type         Type      `form:"type" gorm:"ForeignKey:TypeId"`
	Year         int       `form:"year" json:"year"`
	Month        int       `form:"month" json:"month"`
	Day          int       `form:"day" json:"day"`
}

```
#### 实现方法
我的思路是创建三个时间节点
year month day 
利用sql分组查询
##### Group By分组查询步骤
###### （1）先按照年份查询
###### （2）再按照年份遍历每个月份
并将所有保存在一个切片中
###### （3）按照月份遍历每个月的所有文章
保存在一个Map中，key是对应的月份，value是每个月份的所有文章
#### 自此归档功能实现


## 3.已知BUG
### 后台退出功能
后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧

开源地址
[github](https://github.com/likewl/blog "github")
[gitee](https://gitee.com/nculike/blog "gitee")', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1535821573,4166447487&fm=26&gp=0.jpg', `numb` = 57, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '本博客后端是用golang 的gin框架+gorm编写', `creat_time` = '2020-07-20 15:24:23', `update_time` = '2020-07-20 15:24:23', `type_id` = 4, `year` = 2020, `month` = 7, `day` = 20  WHERE `blogs`.`id` = 4  
[36;31m[1 rows affected or returned ][0m 
<p>今天本博客评论功能发布</p>

<h1>自今天起，本博客基本功能已经完成</h1>

<h2>发布V1.0版本并开源</h2>

<h2>博客语言说明</h2>

<h4>本博客后端是用golang 的gin框架+gorm编写</h4>

<p>前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的</p>

<h4>博客效果参考本站</h4>

<p>#一、博客简介</p>

<h2>1.博客目录</h2>

<pre><code>blog
├────controller
├────└───admin
|   |   ├──adminblog.go
|   |   ├───adminController.go
|   |   ├──adminTag.go
|   |   ├──adminType.go
|   |   └──adminUser.go
|   └──page
|       ├──404.go
|       ├───about.go
|       ├──archives.go
|       ├──blog.go
|       ├──comment.go
|       ├──pagesController.go
|       ├──researchController.go
|       └──tagsController.go
├── dao
│   ├──blogs.go
│   ├──comment.go
│   ├──sql.go
│   ├──tags.go
│   ├──types.go
│   └──user.go
├── logic
│   └── user.go
├── middlerware
│   ├──function.go
│   ├──getImg.go
│   ├──getTime.go
│   ├──markdown.go
│   ├──select.go
│   └──session.go
├── model
│   ├──blog.go
│   ├──commnent.go
│   ├──tag.go
│   ├──type.go
│   └──user/go
├── static
│   └──静态文件（头像、图片、logo、css、js等）
├── templates
│   └──html模板文件
├── go.mod（依赖）
└── main.go
</code></pre>

<h2>2.相关功能实现简介</h2>

<h3>1、评论及回复功能</h3>

<p>comment的结构体属性如下</p>

<pre><code class="language-go">package model

type Comment struct {
    Id     int //评论id
    BlogId int //博文id
    ReCommentId    int    //父评论id
    CommentName string //评论人姓名
    ReCommentName  string //父评论人姓名
    CommentEmail   string
    Img            string
    CommentContent string `gorm:&#34;type:text&#34; form:&#34;CommentContent&#34; json:&#34;CommentContent&#34;` //评论内容
    CommentTime    string ` json:&#34;comment_time,omitempty&#34;`
    Parent         *Comment
    Comments       []Comment
}
</code></pre>

<h4>实现方法</h4>

<h5>1先通过查找父评论为-1的顶级评论</h5>

<p>父评论Id为-1说明他不是任何评论的子评论</p>

<h5>2在html上遍历所有的顶级评论</h5>

<p>在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论</p>

<h6>（1）递归存储每个顶级评论的子评论</h6>

<p>这里我用一个切片来储存一个顶级评论的所有子评论</p>

<pre><code class="language-go">var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
    var comments []model.Comment
    DB.Debug().Where(&#34;re_comment_id = -1 AND blog_id = ?&#34;, id).Find(&amp;comments)
    return &amp;comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
    if count != 0 {
        fmt.Println(&#34;if判断1&#34;)
        var comments []model.Comment
        DB.Debug().Where(&#34;re_comment_id = ?&#34;, id).Find(&amp;comments)
        count = len(comments)
        if count != 0 {
            fmt.Println(&#34;if判断2&#34;)
            for _, comment := range comments {
                fmt.Println(&#34;for判断1&#34;)
                Comments = append(Comments, comment)
                SelectCommentByComment(comment.Id, count)
            }
        }
    }
    fmt.Println(Comments)
    return &amp;Comments

}
</code></pre>

<p>ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来</p>

<h6>（2）出现问题的原因</h6>

<p>因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量</p>

<h6>（3）解决问题</h6>

<pre><code class="language-go">func ClearComments() bool {
    var comments []model.Comment
    Comments = comments
    return true
}

</code></pre>

<p>这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现</p>

<h4>这里我还加了一个小小的随机头像功能</h4>

<pre><code class="language-go">if  CommentName == user.Name &amp;&amp; CommentEmail == user.UserEmail {
        fmt.Println(&#34;进入了1&#34;)
        comment.Img =user.UserImg
        //找相同评论人
    }else if CommentName == one.CommentName &amp;&amp; CommentEmail == one.CommentEmail {
        fmt.Println(&#34;进入了2&#34;)
        comment.Img =one.Img
        //随机选头像
    }else{
        fmt.Println(&#34;进入了3&#34;)
        comment.Img =middleware.GetImg()
    }
</code></pre>

<h5>123分别代表三种不同的用户群体</h5>

<p>1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
<img src="/static/images/%e5%a4%b4%e5%83%8f1.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f2.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f3.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f4.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f5.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f6.png" alt=""/></p>

<h3>2、归档功能</h3>

<h4>blog的结构体属性如下</h4>

<pre><code class="language-go">package model

type Blog struct {
    Id           int
    Title        string    `form:&#34;title&#34; json:&#34;title&#34;`                          //标题
    Content      string    `gorm:&#34;type:longtext&#34; form:&#34;content&#34; json:&#34;content&#34;` //内容
    Image        string    `gorm:&#34;type:text&#34; form:&#34;image&#34; json:&#34;image&#34;`         //首图
    Numb         int       `form:&#34;numb&#34; json:&#34;numb&#34;`                            //次数
    Flag         string    `form:&#34;flag&#34; json:&#34;flag&#34;`                            //原创或者转载
    Appreciation string    `form:&#34;appreciation&#34; json:&#34;appreciation&#34;`            //打赏开关
    ShareInfo    string    `form:&#34;shareInfo&#34; json:&#34;shareInfo&#34;`                  //版权开关
    Comment      string    `form:&#34;comment&#34; json:&#34;comment&#34;`                      //评论开关
    Recommend    string    `form:&#34;recommend&#34; json:&#34;recommend&#34;`                  //推荐开关
    Description  string    `gorm:&#34;type:text&#34; form:&#34;description&#34; json:&#34;description&#34;`
    CreatTime    string    `form:&#34;creatTime&#34;  json:&#34;creat_time,omitempty&#34;`   //创建时间
    UpdateTime   string    `form:&#34;updateTime&#34;  json:&#34;update_time,omitempty&#34;` //更新时间
    Comments     []Comment `form:&#34;comments&#34; json:&#34;comments&#34;`
    TypeId       int       `form:&#34;typeId&#34; json:&#34;typeId&#34;`
    Type         Type      `form:&#34;type&#34; gorm:&#34;ForeignKey:TypeId&#34;`
    Year         int       `form:&#34;year&#34; json:&#34;year&#34;`
    Month        int       `form:&#34;month&#34; json:&#34;month&#34;`
    Day          int       `form:&#34;day&#34; json:&#34;day&#34;`
}

</code></pre>

<h4>实现方法</h4>

<p>我的思路是创建三个时间节点
year month day
利用sql分组查询</p>

<h5>Group By分组查询步骤</h5>

<h6>（1）先按照年份查询</h6>

<h6>（2）再按照年份遍历每个月份</h6>

<p>并将所有保存在一个切片中</p>

<h6>（3）按照月份遍历每个月的所有文章</h6>

<p>保存在一个Map中，key是对应的月份，value是每个月份的所有文章</p>

<h4>自此归档功能实现</h4>

<h2>3.已知BUG</h2>

<h3>后台退出功能</h3>

<p>后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧</p>

<p>开源地址
<a href="https://github.com/likewl/blog" title="github" rel="nofollow">github</a>
<a href="https://gitee.com/nculike/blog" title="gitee" rel="nofollow">gitee</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 12:23:32][0m  [36;1m[0.26ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-22 12:23:37][0m  [36;1m[0.42ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 4)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-22 12:23:37][0m  [36;1m[0.49ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=4  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-22 12:23:37][0m  [36;1m[0.50ms][0m  UPDATE `blogs` SET `title` = '本博客开源公告', `content` = '今天本博客评论功能发布
# 自今天起，本博客基本功能已经完成
## 发布V1.0版本并开源
## 博客语言说明
#### 本博客后端是用golang 的gin框架+gorm编写
前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的
#### 博客效果参考本站
#一、博客简介
## 1.博客目录

    blog
    ├────controller
	├────└───admin
	|	|	├──adminblog.go
	|	|	├───adminController.go
	|	|	├──adminTag.go
	|	|	├──adminType.go
	|	|	└──adminUser.go
	|	└──page
	|		├──404.go
	|		├───about.go
	|		├──archives.go
	|		├──blog.go
	|		├──comment.go
	|		├──pagesController.go
	|		├──researchController.go
	|		└──tagsController.go
    ├── dao
	│	├──blogs.go
	│	├──comment.go
	│	├──sql.go
	│	├──tags.go
	│	├──types.go
	│	└──user.go
    ├── logic
    │   └── user.go
    ├── middlerware
	│	├──function.go
	│	├──getImg.go
	│	├──getTime.go
	│	├──markdown.go
	│	├──select.go
	│	└──session.go
    ├── model
	│	├──blog.go
	│	├──commnent.go
	│	├──tag.go
	│	├──type.go
	│	└──user/go
    ├── static
	│	└──静态文件（头像、图片、logo、css、js等）
    ├── templates
	│	└──html模板文件
    ├── go.mod（依赖）
    └── main.go
    

## 2.相关功能实现简介
### 1、评论及回复功能
comment的结构体属性如下
```go
package model

type Comment struct {
	Id     int //评论id
	BlogId int //博文id
	ReCommentId    int    //父评论id
	CommentName string //评论人姓名
	ReCommentName  string //父评论人姓名
	CommentEmail   string
	Img            string
	CommentContent string `gorm:"type:text" form:"CommentContent" json:"CommentContent"` //评论内容
	CommentTime    string ` json:"comment_time,omitempty"`
	Parent         *Comment
	Comments       []Comment
}
```
#### 实现方法
##### 1先通过查找父评论为-1的顶级评论
父评论Id为-1说明他不是任何评论的子评论
##### 2在html上遍历所有的顶级评论
在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论
###### （1）递归存储每个顶级评论的子评论
这里我用一个切片来储存一个顶级评论的所有子评论
```go
var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
	var comments []model.Comment
	DB.Debug().Where("re_comment_id = -1 AND blog_id = ?", id).Find(&comments)
	return &comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
	if count != 0 {
		fmt.Println("if判断1")
		var comments []model.Comment
		DB.Debug().Where("re_comment_id = ?", id).Find(&comments)
		count = len(comments)
		if count != 0 {
			fmt.Println("if判断2")
			for _, comment := range comments {
				fmt.Println("for判断1")
				Comments = append(Comments, comment)
				SelectCommentByComment(comment.Id, count)
			}
		}
	}
	fmt.Println(Comments)
	return &Comments

}
```
ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来
###### （2）出现问题的原因
因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量
###### （3）解决问题
```go
func ClearComments() bool {
	var comments []model.Comment
	Comments = comments
	return true
}

```
这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现
#### 这里我还加了一个小小的随机头像功能
```go
if  CommentName == user.Name && CommentEmail == user.UserEmail {
		fmt.Println("进入了1")
		comment.Img =user.UserImg
		//找相同评论人
	}else if CommentName == one.CommentName && CommentEmail == one.CommentEmail {
		fmt.Println("进入了2")
		comment.Img =one.Img
		//随机选头像
	}else{
		fmt.Println("进入了3")
		comment.Img =middleware.GetImg()
	}
```
##### 123分别代表三种不同的用户群体
1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
![](/static/images/%e5%a4%b4%e5%83%8f1.png)![](/static/images/%e5%a4%b4%e5%83%8f2.png)![](/static/images/%e5%a4%b4%e5%83%8f3.png)![](/static/images/%e5%a4%b4%e5%83%8f4.png)![](/static/images/%e5%a4%b4%e5%83%8f5.png)![](/static/images/%e5%a4%b4%e5%83%8f6.png)
### 2、归档功能
#### blog的结构体属性如下
```go
package model

type Blog struct {
	Id           int
	Title        string    `form:"title" json:"title"`                          //标题
	Content      string    `gorm:"type:longtext" form:"content" json:"content"` //内容
	Image        string    `gorm:"type:text" form:"image" json:"image"`         //首图
	Numb         int       `form:"numb" json:"numb"`                            //次数
	Flag         string    `form:"flag" json:"flag"`                            //原创或者转载
	Appreciation string    `form:"appreciation" json:"appreciation"`            //打赏开关
	ShareInfo    string    `form:"shareInfo" json:"shareInfo"`                  //版权开关
	Comment      string    `form:"comment" json:"comment"`                      //评论开关
	Recommend    string    `form:"recommend" json:"recommend"`                  //推荐开关
	Description  string    `gorm:"type:text" form:"description" json:"description"`
	CreatTime    string    `form:"creatTime"  json:"creat_time,omitempty"`   //创建时间
	UpdateTime   string    `form:"updateTime"  json:"update_time,omitempty"` //更新时间
	Comments     []Comment `form:"comments" json:"comments"`
	TypeId       int       `form:"typeId" json:"typeId"`
	Type         Type      `form:"type" gorm:"ForeignKey:TypeId"`
	Year         int       `form:"year" json:"year"`
	Month        int       `form:"month" json:"month"`
	Day          int       `form:"day" json:"day"`
}

```
#### 实现方法
我的思路是创建三个时间节点
year month day 
利用sql分组查询
##### Group By分组查询步骤
###### （1）先按照年份查询
###### （2）再按照年份遍历每个月份
并将所有保存在一个切片中
###### （3）按照月份遍历每个月的所有文章
保存在一个Map中，key是对应的月份，value是每个月份的所有文章
#### 自此归档功能实现


## 3.已知BUG
### 后台退出功能
后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧

开源地址
[github](https://github.com/likewl/blog "github")
[gitee](https://gitee.com/nculike/blog "gitee")', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1535821573,4166447487&fm=26&gp=0.jpg', `numb` = 58, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '本博客后端是用golang 的gin框架+gorm编写', `creat_time` = '2020-07-20 15:24:23', `update_time` = '2020-07-20 15:24:23', `type_id` = 4, `year` = 2020, `month` = 7, `day` = 20  WHERE `blogs`.`id` = 4  
[36;31m[1 rows affected or returned ][0m 
<p>今天本博客评论功能发布</p>

<h1>自今天起，本博客基本功能已经完成</h1>

<h2>发布V1.0版本并开源</h2>

<h2>博客语言说明</h2>

<h4>本博客后端是用golang 的gin框架+gorm编写</h4>

<p>前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的</p>

<h4>博客效果参考本站</h4>

<p>#一、博客简介</p>

<h2>1.博客目录</h2>

<pre><code>blog
├────controller
├────└───admin
|   |   ├──adminblog.go
|   |   ├───adminController.go
|   |   ├──adminTag.go
|   |   ├──adminType.go
|   |   └──adminUser.go
|   └──page
|       ├──404.go
|       ├───about.go
|       ├──archives.go
|       ├──blog.go
|       ├──comment.go
|       ├──pagesController.go
|       ├──researchController.go
|       └──tagsController.go
├── dao
│   ├──blogs.go
│   ├──comment.go
│   ├──sql.go
│   ├──tags.go
│   ├──types.go
│   └──user.go
├── logic
│   └── user.go
├── middlerware
│   ├──function.go
│   ├──getImg.go
│   ├──getTime.go
│   ├──markdown.go
│   ├──select.go
│   └──session.go
├── model
│   ├──blog.go
│   ├──commnent.go
│   ├──tag.go
│   ├──type.go
│   └──user/go
├── static
│   └──静态文件（头像、图片、logo、css、js等）
├── templates
│   └──html模板文件
├── go.mod（依赖）
└── main.go
</code></pre>

<h2>2.相关功能实现简介</h2>

<h3>1、评论及回复功能</h3>

<p>comment的结构体属性如下</p>

<pre><code class="language-go">package model

type Comment struct {
    Id     int //评论id
    BlogId int //博文id
    ReCommentId    int    //父评论id
    CommentName string //评论人姓名
    ReCommentName  string //父评论人姓名
    CommentEmail   string
    Img            string
    CommentContent string `gorm:&#34;type:text&#34; form:&#34;CommentContent&#34; json:&#34;CommentContent&#34;` //评论内容
    CommentTime    string ` json:&#34;comment_time,omitempty&#34;`
    Parent         *Comment
    Comments       []Comment
}
</code></pre>

<h4>实现方法</h4>

<h5>1先通过查找父评论为-1的顶级评论</h5>

<p>父评论Id为-1说明他不是任何评论的子评论</p>

<h5>2在html上遍历所有的顶级评论</h5>

<p>在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论</p>

<h6>（1）递归存储每个顶级评论的子评论</h6>

<p>这里我用一个切片来储存一个顶级评论的所有子评论</p>

<pre><code class="language-go">var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
    var comments []model.Comment
    DB.Debug().Where(&#34;re_comment_id = -1 AND blog_id = ?&#34;, id).Find(&amp;comments)
    return &amp;comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
    if count != 0 {
        fmt.Println(&#34;if判断1&#34;)
        var comments []model.Comment
        DB.Debug().Where(&#34;re_comment_id = ?&#34;, id).Find(&amp;comments)
        count = len(comments)
        if count != 0 {
            fmt.Println(&#34;if判断2&#34;)
            for _, comment := range comments {
                fmt.Println(&#34;for判断1&#34;)
                Comments = append(Comments, comment)
                SelectCommentByComment(comment.Id, count)
            }
        }
    }
    fmt.Println(Comments)
    return &amp;Comments

}
</code></pre>

<p>ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来</p>

<h6>（2）出现问题的原因</h6>

<p>因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量</p>

<h6>（3）解决问题</h6>

<pre><code class="language-go">func ClearComments() bool {
    var comments []model.Comment
    Comments = comments
    return true
}

</code></pre>

<p>这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现</p>

<h4>这里我还加了一个小小的随机头像功能</h4>

<pre><code class="language-go">if  CommentName == user.Name &amp;&amp; CommentEmail == user.UserEmail {
        fmt.Println(&#34;进入了1&#34;)
        comment.Img =user.UserImg
        //找相同评论人
    }else if CommentName == one.CommentName &amp;&amp; CommentEmail == one.CommentEmail {
        fmt.Println(&#34;进入了2&#34;)
        comment.Img =one.Img
        //随机选头像
    }else{
        fmt.Println(&#34;进入了3&#34;)
        comment.Img =middleware.GetImg()
    }
</code></pre>

<h5>123分别代表三种不同的用户群体</h5>

<p>1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
<img src="/static/images/%e5%a4%b4%e5%83%8f1.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f2.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f3.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f4.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f5.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f6.png" alt=""/></p>

<h3>2、归档功能</h3>

<h4>blog的结构体属性如下</h4>

<pre><code class="language-go">package model

type Blog struct {
    Id           int
    Title        string    `form:&#34;title&#34; json:&#34;title&#34;`                          //标题
    Content      string    `gorm:&#34;type:longtext&#34; form:&#34;content&#34; json:&#34;content&#34;` //内容
    Image        string    `gorm:&#34;type:text&#34; form:&#34;image&#34; json:&#34;image&#34;`         //首图
    Numb         int       `form:&#34;numb&#34; json:&#34;numb&#34;`                            //次数
    Flag         string    `form:&#34;flag&#34; json:&#34;flag&#34;`                            //原创或者转载
    Appreciation string    `form:&#34;appreciation&#34; json:&#34;appreciation&#34;`            //打赏开关
    ShareInfo    string    `form:&#34;shareInfo&#34; json:&#34;shareInfo&#34;`                  //版权开关
    Comment      string    `form:&#34;comment&#34; json:&#34;comment&#34;`                      //评论开关
    Recommend    string    `form:&#34;recommend&#34; json:&#34;recommend&#34;`                  //推荐开关
    Description  string    `gorm:&#34;type:text&#34; form:&#34;description&#34; json:&#34;description&#34;`
    CreatTime    string    `form:&#34;creatTime&#34;  json:&#34;creat_time,omitempty&#34;`   //创建时间
    UpdateTime   string    `form:&#34;updateTime&#34;  json:&#34;update_time,omitempty&#34;` //更新时间
    Comments     []Comment `form:&#34;comments&#34; json:&#34;comments&#34;`
    TypeId       int       `form:&#34;typeId&#34; json:&#34;typeId&#34;`
    Type         Type      `form:&#34;type&#34; gorm:&#34;ForeignKey:TypeId&#34;`
    Year         int       `form:&#34;year&#34; json:&#34;year&#34;`
    Month        int       `form:&#34;month&#34; json:&#34;month&#34;`
    Day          int       `form:&#34;day&#34; json:&#34;day&#34;`
}

</code></pre>

<h4>实现方法</h4>

<p>我的思路是创建三个时间节点
year month day
利用sql分组查询</p>

<h5>Group By分组查询步骤</h5>

<h6>（1）先按照年份查询</h6>

<h6>（2）再按照年份遍历每个月份</h6>

<p>并将所有保存在一个切片中</p>

<h6>（3）按照月份遍历每个月的所有文章</h6>

<p>保存在一个Map中，key是对应的月份，value是每个月份的所有文章</p>

<h4>自此归档功能实现</h4>

<h2>3.已知BUG</h2>

<h3>后台退出功能</h3>

<p>后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧</p>

<p>开源地址
<a href="https://github.com/likewl/blog" title="github" rel="nofollow">github</a>
<a href="https://gitee.com/nculike/blog" title="gitee" rel="nofollow">gitee</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 12:23:37][0m  [36;1m[0.30ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 12:28:57][0m  [36;1m[0.53ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 12:28:57][0m  [36;1m[0.73ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 12:28:57][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-22 12:28:57][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-22 12:28:57][0m  [36;1m[0.25ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-22 12:28:57][0m  [36;1m[0.32ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 12:30:48][0m  [36;1m[0.52ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 12:30:48][0m  [36;1m[0.71ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 12:30:48][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-22 12:30:48][0m  [36;1m[0.32ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-22 12:30:48][0m  [36;1m[0.27ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-22 12:30:48][0m  [36;1m[0.33ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-22 12:31:06][0m  [36;1m[0.39ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 2)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-22 12:31:06][0m  [36;1m[0.47ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=2  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-22 12:31:06][0m  [36;1m[0.39ms][0m  UPDATE `blogs` SET `title` = '解决Linux关闭终端后运行的程序自动停止', `content` = '# 问题发现
  昨天博客发布，操作完关闭终端就睡了
  然而今天醒来突然发现终端不能访问了
  查看发现原来博客项目进程被杀死了
# 解决办法
    go build main.go
执行完后

    nohup ./main &
让程序在后台运行就可了


[========]
# ps:这个方法并不完美，因为我也是刚刚接触还不知道怎么切回来', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3696516981,3671280793&fm=26&gp=0.jpg', `numb` = 29, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '昨天博客发布，操作完关闭终端就睡了，然而今天醒来突然发现终端不能访问了，查看发现原来博客项目进程被杀死了', `creat_time` = '2020-07-19 19:05:36', `update_time` = '2020-07-19 19:05:36', `type_id` = 2, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 3  
[36;31m[1 rows affected or returned ][0m 
<h1>问题发现</h1>

<p>昨天博客发布，操作完关闭终端就睡了
  然而今天醒来突然发现终端不能访问了
  查看发现原来博客项目进程被杀死了</p>

<h1>解决办法</h1>

<pre><code>go build main.go
</code></pre>

<p>执行完后</p>

<pre><code>nohup ./main &amp;
</code></pre>

<p>让程序在后台运行就可了</p>

<p>[========]</p>

<h1>ps:这个方法并不完美，因为我也是刚刚接触还不知道怎么切回来</h1>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 12:31:06][0m  [36;1m[0.24ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 12:55:51][0m  [36;1m[0.56ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 12:55:51][0m  [36;1m[0.70ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 12:55:51][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-22 12:55:51][0m  [36;1m[0.36ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-22 12:55:51][0m  [36;1m[0.27ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-22 12:55:51][0m  [36;1m[0.33ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 14:12:35][0m  [36;1m[0.53ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 14:12:35][0m  [36;1m[0.70ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 14:12:35][0m  [36;1m[0.18ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-22 14:12:35][0m  [36;1m[0.28ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-22 14:12:35][0m  [36;1m[0.25ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-22 14:12:35][0m  [36;1m[0.31ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-22 14:12:38][0m  [36;1m[0.43ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 1)  
[36;31m[2 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-22 14:12:38][0m  [36;1m[0.42ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=1  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-22 14:12:38][0m  [36;1m[0.38ms][0m  UPDATE `blogs` SET `title` = 'golang项目简单服务器部署到阿里云(linux)', `content` = '# 我个人比较推荐使用Xftp和Xshell 
# 重要是个人免费用
# 舒服又好用

# 1.下载安装go安装包：
	## （1）go语言下载地址：
	[Go语言中文网](https://studygolang.com/dl "Go语言中文网")
下载linux版本的安装包。

## （2）使用Xftp将安装包上传至指定的路径：

![](https://img-blog.csdnimg.cn/20190719142701389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
	这里上传到root目录下就行
	方便解压
## （3）解压并移到/usr/local/下：

进入指定目录，查看已有文件并且解压文件：

![](https://img-blog.csdnimg.cn/20190719143211340.png)
```
#在root目录输入ls查看目录文件
ls
#在root解压go包
tar -zxvf go的包名
```

解压完成后发现目录下多了一个go文件夹：
![](https://img-blog.csdnimg.cn/20190719143042938.png)
将文件夹移动到/usr/local/
![](https://img-blog.csdnimg.cn/20190719143137645.png)
# 2.配置环境变量：
## （1）进入目的目录查看go文件夹是否移动成功：
![](https://img-blog.csdnimg.cn/20190719143506382.png)
## （2）在usr下创建文件夹，用来存放自己的项目：
workspace
## （3）进入新建的目录workspace新建三个文件夹：
src
pkg
bin
### 说明：

	src 目录存放的是我们的go源代码，不同工程项目的代码以包名区分
	pkg 编译后生成的文件
	bin文件夹存放go install命名生成的可执行文件（这个文件夹会配置到环境变量中）
## （4）配置环境变量：

进入 /etc 修改profile文件：
![](https://img-blog.csdnimg.cn/20190719144319621.png)
```
#进入etc目录
cd /etc/
#配置 profile
vim profile
```
![](https://img-blog.csdnimg.cn/20190719145650864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
在此文件夹下加入上图的代码，代码如下：
```
// 设置go安装路径
export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin
 
// 设置工程目录
export GOPATH=/usr/workspace
export PATH=$PATH:$GOPATH/bin
```

## （5）刷新环境变量：
```
source /etc/profile
```
##  （6）查看go环境是否配置成功：
```
go version
```
## （7）查看详细配置：
```
go env
```
结果如下：  
![](https://img-blog.csdnimg.cn/20190719145255720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70) 
# 3.上传项目代码：
在刚刚创建的workspace下新创建的三个文件夹中，src 目录存放的是我们的go源代码
# 4运行
```go
go build main.go
//或者
go run main.go
```
最后执行 ./main 就行了。
如果想让项目在后台执行：执行 nohup ./main & ，这样就可以程序在后台运行了。

参考教程https://blog.csdn.net/qq_42410605/article/details/96479892', `image` = 'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3111860246,1925938903&fm=26&gp=0.jpg', `numb` = 48, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '简单又详细的教程', `creat_time` = '2020-07-19 18:32:31', `update_time` = '2020-07-20 13:11:56', `type_id` = 1, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 1  
[36;31m[1 rows affected or returned ][0m 
<h1>我个人比较推荐使用Xftp和Xshell</h1>

<h1>重要是个人免费用</h1>

<h1>舒服又好用</h1>

<h1>1.下载安装go安装包：</h1>

<pre><code>## （1）go语言下载地址：
[Go语言中文网](https://studygolang.com/dl &#34;Go语言中文网&#34;)
</code></pre>

<p>下载linux版本的安装包。</p>

<h2>（2）使用Xftp将安装包上传至指定的路径：</h2>

<p><img src="https://img-blog.csdnimg.cn/20190719142701389.png?x-oss-process=image%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1%2Csize_16%2Ccolor_FFFFFF%2Ct_70" alt=""/>
    这里上传到root目录下就行
    方便解压</p>

<h2>（3）解压并移到/usr/local/下：</h2>

<p>进入指定目录，查看已有文件并且解压文件：</p>

<p><img src="https://img-blog.csdnimg.cn/20190719143211340.png" alt=""/></p>

<pre><code>#在root目录输入ls查看目录文件
ls
#在root解压go包
tar -zxvf go的包名
</code></pre>

<p>解压完成后发现目录下多了一个go文件夹：
<img src="https://img-blog.csdnimg.cn/20190719143042938.png" alt=""/>
将文件夹移动到/usr/local/
<img src="https://img-blog.csdnimg.cn/20190719143137645.png" alt=""/></p>

<h1>2.配置环境变量：</h1>

<h2>（1）进入目的目录查看go文件夹是否移动成功：</h2>

<p><img src="https://img-blog.csdnimg.cn/20190719143506382.png" alt=""/></p>

<h2>（2）在usr下创建文件夹，用来存放自己的项目：</h2>

<p>workspace</p>

<h2>（3）进入新建的目录workspace新建三个文件夹：</h2>

<p>src
pkg
bin</p>

<h3>说明：</h3>

<pre><code>src 目录存放的是我们的go源代码，不同工程项目的代码以包名区分
pkg 编译后生成的文件
bin文件夹存放go install命名生成的可执行文件（这个文件夹会配置到环境变量中）
</code></pre>

<h2>（4）配置环境变量：</h2>

<p>进入 /etc 修改profile文件：
<img src="https://img-blog.csdnimg.cn/20190719144319621.png" alt=""/></p>

<pre><code>#进入etc目录
cd /etc/
#配置 profile
vim profile
</code></pre>

<p><img src="https://img-blog.csdnimg.cn/20190719145650864.png?x-oss-process=image%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1%2Csize_16%2Ccolor_FFFFFF%2Ct_70" alt=""/>
在此文件夹下加入上图的代码，代码如下：</p>

<pre><code>// 设置go安装路径
export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin
 
// 设置工程目录
export GOPATH=/usr/workspace
export PATH=$PATH:$GOPATH/bin
</code></pre>

<h2>（5）刷新环境变量：</h2>

<pre><code>source /etc/profile
</code></pre>

<h2> （6）查看go环境是否配置成功：</h2>

<pre><code>go version
</code></pre>

<h2>（7）查看详细配置：</h2>

<pre><code>go env
</code></pre>

<p>结果如下：  
<img src="https://img-blog.csdnimg.cn/20190719145255720.png?x-oss-process=image%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1%2Csize_16%2Ccolor_FFFFFF%2Ct_70" alt=""/> </p>

<h1>3.上传项目代码：</h1>

<p>在刚刚创建的workspace下新创建的三个文件夹中，src 目录存放的是我们的go源代码</p>

<h1>4运行</h1>

<pre><code class="language-go">go build main.go
//或者
go run main.go
</code></pre>

<p>最后执行 ./main 就行了。
如果想让项目在后台执行：执行 nohup ./main &amp; ，这样就可以程序在后台运行了。</p>

<p>参考教程<a href="https://blog.csdn.net/qq_42410605/article/details/96479892" rel="nofollow">https://blog.csdn.net/qq_42410605/article/details/96479892</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 14:12:38][0m  [36;1m[0.29ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-22 14:12:38][0m  [36;1m[0.37ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 1)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-22 14:12:38][0m  [36;1m[0.33ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 2)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-22 14:12:38][0m  [36;1m[0.29ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 4)  
[36;31m[0 rows affected or returned ][0m 
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-22 14:12:38][0m  [36;1m[0.33ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 3)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-22 14:12:38][0m  [36;1m[0.33ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 5)  
[36;31m[0 rows affected or returned ][0m 
[{5 1 3 like 狗科 535889315@qq.com /static/images/header.jpg ？？？ 2020-07-20 13:30:17 <nil> []}]
[{5 1 3 like 狗科 535889315@qq.com /static/images/header.jpg ？？？ 2020-07-20 13:30:17 <nil> []}]

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 14:15:49][0m  [36;1m[0.61ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 14:21:16][0m  [36;1m[0.56ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 14:21:16][0m  [36;1m[0.69ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 14:21:16][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-22 14:21:16][0m  [36;1m[0.31ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-22 14:21:16][0m  [36;1m[0.25ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-22 14:21:16][0m  [36;1m[0.33ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 14:41:20][0m  [36;1m[0.57ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 14:41:20][0m  [36;1m[0.67ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 14:41:20][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-22 14:41:20][0m  [36;1m[0.33ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-22 14:41:20][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-22 14:41:20][0m  [36;1m[0.31ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-22 14:41:22][0m  [36;1m[0.46ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 1)  
[36;31m[2 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-22 14:41:22][0m  [36;1m[0.44ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=1  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-22 14:41:22][0m  [36;1m[0.41ms][0m  UPDATE `blogs` SET `title` = 'golang项目简单服务器部署到阿里云(linux)', `content` = '# 我个人比较推荐使用Xftp和Xshell 
# 重要是个人免费用
# 舒服又好用

# 1.下载安装go安装包：
	## （1）go语言下载地址：
	[Go语言中文网](https://studygolang.com/dl "Go语言中文网")
下载linux版本的安装包。

## （2）使用Xftp将安装包上传至指定的路径：

![](https://img-blog.csdnimg.cn/20190719142701389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
	这里上传到root目录下就行
	方便解压
## （3）解压并移到/usr/local/下：

进入指定目录，查看已有文件并且解压文件：

![](https://img-blog.csdnimg.cn/20190719143211340.png)
```
#在root目录输入ls查看目录文件
ls
#在root解压go包
tar -zxvf go的包名
```

解压完成后发现目录下多了一个go文件夹：
![](https://img-blog.csdnimg.cn/20190719143042938.png)
将文件夹移动到/usr/local/
![](https://img-blog.csdnimg.cn/20190719143137645.png)
# 2.配置环境变量：
## （1）进入目的目录查看go文件夹是否移动成功：
![](https://img-blog.csdnimg.cn/20190719143506382.png)
## （2）在usr下创建文件夹，用来存放自己的项目：
workspace
## （3）进入新建的目录workspace新建三个文件夹：
src
pkg
bin
### 说明：

	src 目录存放的是我们的go源代码，不同工程项目的代码以包名区分
	pkg 编译后生成的文件
	bin文件夹存放go install命名生成的可执行文件（这个文件夹会配置到环境变量中）
## （4）配置环境变量：

进入 /etc 修改profile文件：
![](https://img-blog.csdnimg.cn/20190719144319621.png)
```
#进入etc目录
cd /etc/
#配置 profile
vim profile
```
![](https://img-blog.csdnimg.cn/20190719145650864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70)
在此文件夹下加入上图的代码，代码如下：
```
// 设置go安装路径
export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin
 
// 设置工程目录
export GOPATH=/usr/workspace
export PATH=$PATH:$GOPATH/bin
```

## （5）刷新环境变量：
```
source /etc/profile
```
##  （6）查看go环境是否配置成功：
```
go version
```
## （7）查看详细配置：
```
go env
```
结果如下：  
![](https://img-blog.csdnimg.cn/20190719145255720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1,size_16,color_FFFFFF,t_70) 
# 3.上传项目代码：
在刚刚创建的workspace下新创建的三个文件夹中，src 目录存放的是我们的go源代码
# 4运行
```go
go build main.go
//或者
go run main.go
```
最后执行 ./main 就行了。
如果想让项目在后台执行：执行 nohup ./main & ，这样就可以程序在后台运行了。

参考教程https://blog.csdn.net/qq_42410605/article/details/96479892', `image` = 'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3111860246,1925938903&fm=26&gp=0.jpg', `numb` = 49, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '简单又详细的教程', `creat_time` = '2020-07-19 18:32:31', `update_time` = '2020-07-20 13:11:56', `type_id` = 1, `year` = 2020, `month` = 7, `day` = 19  WHERE `blogs`.`id` = 1  
[36;31m[1 rows affected or returned ][0m 
<h1>我个人比较推荐使用Xftp和Xshell</h1>

<h1>重要是个人免费用</h1>

<h1>舒服又好用</h1>

<h1>1.下载安装go安装包：</h1>

<pre><code>## （1）go语言下载地址：
[Go语言中文网](https://studygolang.com/dl &#34;Go语言中文网&#34;)
</code></pre>

<p>下载linux版本的安装包。</p>

<h2>（2）使用Xftp将安装包上传至指定的路径：</h2>

<p><img src="https://img-blog.csdnimg.cn/20190719142701389.png?x-oss-process=image%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1%2Csize_16%2Ccolor_FFFFFF%2Ct_70" alt=""/>
    这里上传到root目录下就行
    方便解压</p>

<h2>（3）解压并移到/usr/local/下：</h2>

<p>进入指定目录，查看已有文件并且解压文件：</p>

<p><img src="https://img-blog.csdnimg.cn/20190719143211340.png" alt=""/></p>

<pre><code>#在root目录输入ls查看目录文件
ls
#在root解压go包
tar -zxvf go的包名
</code></pre>

<p>解压完成后发现目录下多了一个go文件夹：
<img src="https://img-blog.csdnimg.cn/20190719143042938.png" alt=""/>
将文件夹移动到/usr/local/
<img src="https://img-blog.csdnimg.cn/20190719143137645.png" alt=""/></p>

<h1>2.配置环境变量：</h1>

<h2>（1）进入目的目录查看go文件夹是否移动成功：</h2>

<p><img src="https://img-blog.csdnimg.cn/20190719143506382.png" alt=""/></p>

<h2>（2）在usr下创建文件夹，用来存放自己的项目：</h2>

<p>workspace</p>

<h2>（3）进入新建的目录workspace新建三个文件夹：</h2>

<p>src
pkg
bin</p>

<h3>说明：</h3>

<pre><code>src 目录存放的是我们的go源代码，不同工程项目的代码以包名区分
pkg 编译后生成的文件
bin文件夹存放go install命名生成的可执行文件（这个文件夹会配置到环境变量中）
</code></pre>

<h2>（4）配置环境变量：</h2>

<p>进入 /etc 修改profile文件：
<img src="https://img-blog.csdnimg.cn/20190719144319621.png" alt=""/></p>

<pre><code>#进入etc目录
cd /etc/
#配置 profile
vim profile
</code></pre>

<p><img src="https://img-blog.csdnimg.cn/20190719145650864.png?x-oss-process=image%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1%2Csize_16%2Ccolor_FFFFFF%2Ct_70" alt=""/>
在此文件夹下加入上图的代码，代码如下：</p>

<pre><code>// 设置go安装路径
export GOROOT=/usr/local/go
export PATH=$PATH:$GOROOT/bin
 
// 设置工程目录
export GOPATH=/usr/workspace
export PATH=$PATH:$GOPATH/bin
</code></pre>

<h2>（5）刷新环境变量：</h2>

<pre><code>source /etc/profile
</code></pre>

<h2> （6）查看go环境是否配置成功：</h2>

<pre><code>go version
</code></pre>

<h2>（7）查看详细配置：</h2>

<pre><code>go env
</code></pre>

<p>结果如下：  
<img src="https://img-blog.csdnimg.cn/20190719145255720.png?x-oss-process=image%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDEwNjA1%2Csize_16%2Ccolor_FFFFFF%2Ct_70" alt=""/> </p>

<h1>3.上传项目代码：</h1>

<p>在刚刚创建的workspace下新创建的三个文件夹中，src 目录存放的是我们的go源代码</p>

<h1>4运行</h1>

<pre><code class="language-go">go build main.go
//或者
go run main.go
</code></pre>

<p>最后执行 ./main 就行了。
如果想让项目在后台执行：执行 nohup ./main &amp; ，这样就可以程序在后台运行了。</p>

<p>参考教程<a href="https://blog.csdn.net/qq_42410605/article/details/96479892" rel="nofollow">https://blog.csdn.net/qq_42410605/article/details/96479892</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 14:41:22][0m  [36;1m[0.27ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-22 14:41:22][0m  [36;1m[0.36ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 1)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-22 14:41:22][0m  [36;1m[0.38ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 2)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-22 14:41:22][0m  [36;1m[0.30ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 4)  
[36;31m[0 rows affected or returned ][0m 
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
[{2 1 1 测试员1 like admin@qq.com /static/images/头像1.png 测试回复功能 2020-07-20 13:15:56 <nil> []} {4 1 2 肖浩 测试员1 1037432782@qq.com /static/images/头像3.png 测试成功 2020-07-20 13:16:57 <nil> []}]
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-22 14:41:22][0m  [36;1m[0.33ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 3)  
[36;31m[1 rows affected or returned ][0m 
if判断2
for判断1
if判断1

[35m(/usr/workspace/src/blog/dao/comment.go:26)[0m 
[33m[2020-07-22 14:41:22][0m  [36;1m[0.30ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = 5)  
[36;31m[0 rows affected or returned ][0m 
[{5 1 3 like 狗科 535889315@qq.com /static/images/header.jpg ？？？ 2020-07-20 13:30:17 <nil> []}]
[{5 1 3 like 狗科 535889315@qq.com /static/images/header.jpg ？？？ 2020-07-20 13:30:17 <nil> []}]

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 15:07:24][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 15:07:24][0m  [36;1m[0.68ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 15:07:24][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-22 15:07:24][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-22 15:07:24][0m  [36;1m[0.24ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-22 15:07:24][0m  [36;1m[0.32ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 15:26:55][0m  [36;1m[0.56ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 15:26:56][0m  [36;1m[0.56ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 15:26:56][0m  [36;1m[0.22ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:144)[0m 
[33m[2020-07-22 15:26:56][0m  [36;1m[0.63ms][0m   SELECT * FROM `blogs` GROUP BY YEAR DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:157)[0m 
[33m[2020-07-22 15:26:56][0m  [36;1m[0.70ms][0m   SELECT * FROM `blogs` where year = 2020 GROUP BY month DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:169)[0m 
[33m[2020-07-22 15:26:56][0m  [36;1m[0.64ms][0m   SELECT * FROM `blogs` where year = 2020 and month = 7 ORDER BY `id` DESC  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-22 15:26:56][0m  [36;1m[0.38ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=4  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-22 15:26:56][0m  [36;1m[0.42ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=3  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-22 15:26:56][0m  [36;1m[0.34ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=2  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-22 15:26:56][0m  [36;1m[0.35ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-22 15:26:57][0m  [36;1m[0.54ms][0m  SELECT * FROM `tags`    
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 15:26:57][0m  [36;1m[0.24ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 15:26:57][0m  [36;1m[0.69ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:31)[0m 
[33m[2020-07-22 15:26:57][0m  [36;1m[0.18ms][0m  SELECT count(*) FROM `tags`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-22 15:26:58][0m  [36;1m[0.54ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 15:26:58][0m  [36;1m[0.28ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 15:26:58][0m  [36;1m[0.73ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-22 15:26:58][0m  [36;1m[0.18ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 15:26:59][0m  [36;1m[0.69ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 15:26:59][0m  [36;1m[0.74ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 15:26:59][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-22 15:26:59][0m  [36;1m[0.49ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-22 15:26:59][0m  [36;1m[0.35ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-22 15:26:59][0m  [36;1m[0.38ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 15:33:28][0m  [36;1m[0.57ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 15:33:28][0m  [36;1m[0.67ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 15:33:28][0m  [36;1m[0.22ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-22 15:33:28][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-22 15:33:28][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-22 15:33:28][0m  [36;1m[0.36ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 15:33:30][0m  [36;1m[0.58ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 15:33:39][0m  [36;1m[0.56ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 15:33:39][0m  [36;1m[0.72ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 15:33:39][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-22 15:33:39][0m  [36;1m[0.28ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-22 15:33:39][0m  [36;1m[0.28ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-22 15:33:39][0m  [36;1m[0.31ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 15:33:47][0m  [36;1m[0.61ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 15:33:47][0m  [36;1m[0.67ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 15:33:47][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-22 15:33:47][0m  [36;1m[0.29ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-22 15:33:47][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-22 15:33:47][0m  [36;1m[0.32ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-22 15:33:53][0m  [36;1m[0.59ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 15:33:53][0m  [36;1m[0.25ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 15:33:53][0m  [36;1m[0.71ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-22 15:33:53][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-22 15:33:55][0m  [36;1m[0.52ms][0m  SELECT * FROM `tags`    
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 15:33:55][0m  [36;1m[0.29ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 15:33:55][0m  [36;1m[0.74ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:31)[0m 
[33m[2020-07-22 15:33:55][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `tags`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 15:33:56][0m  [36;1m[0.56ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 15:33:56][0m  [36;1m[0.23ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:144)[0m 
[33m[2020-07-22 15:33:56][0m  [36;1m[0.63ms][0m   SELECT * FROM `blogs` GROUP BY YEAR DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:157)[0m 
[33m[2020-07-22 15:33:56][0m  [36;1m[1.30ms][0m   SELECT * FROM `blogs` where year = 2020 GROUP BY month DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:169)[0m 
[33m[2020-07-22 15:33:56][0m  [36;1m[0.76ms][0m   SELECT * FROM `blogs` where year = 2020 and month = 7 ORDER BY `id` DESC  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-22 15:33:56][0m  [36;1m[0.42ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=4  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-22 15:33:56][0m  [36;1m[0.35ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=3  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-22 15:33:56][0m  [36;1m[0.33ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=2  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-22 15:33:56][0m  [36;1m[0.34ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 15:33:57][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 15:34:00][0m  [36;1m[0.52ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 15:34:00][0m  [36;1m[0.69ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 15:34:00][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-22 15:34:00][0m  [36;1m[0.32ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-22 15:34:00][0m  [36;1m[0.25ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-22 15:34:00][0m  [36;1m[0.33ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-22 15:34:01][0m  [36;1m[0.50ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 15:34:01][0m  [36;1m[0.25ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 15:34:01][0m  [36;1m[0.66ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-22 15:34:01][0m  [36;1m[0.18ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 15:34:02][0m  [36;1m[0.56ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 15:34:04][0m  [36;1m[2.33ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 15:34:04][0m  [36;1m[0.66ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 15:34:04][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-22 15:34:04][0m  [36;1m[0.30ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-22 15:34:04][0m  [36;1m[0.25ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-22 15:34:04][0m  [36;1m[0.32ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-22 15:34:05][0m  [36;1m[0.54ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 15:34:05][0m  [36;1m[0.26ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 15:34:05][0m  [36;1m[0.83ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-22 15:34:05][0m  [36;1m[0.18ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-22 15:34:07][0m  [36;1m[0.60ms][0m  SELECT * FROM `tags`    
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 15:34:07][0m  [36;1m[0.35ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 15:34:07][0m  [36;1m[0.72ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:31)[0m 
[33m[2020-07-22 15:34:07][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `tags`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 15:34:08][0m  [36;1m[0.62ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 15:34:08][0m  [36;1m[0.75ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 15:34:08][0m  [36;1m[0.22ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-22 15:34:08][0m  [36;1m[0.34ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-22 15:34:08][0m  [36;1m[0.30ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-22 15:34:08][0m  [36;1m[0.35ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-22 15:34:09][0m  [36;1m[0.53ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 15:34:09][0m  [36;1m[0.26ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 15:34:09][0m  [36;1m[0.69ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-22 15:34:09][0m  [36;1m[0.18ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-22 15:34:11][0m  [36;1m[0.52ms][0m  SELECT * FROM `tags`    
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 15:34:11][0m  [36;1m[0.28ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 15:34:11][0m  [36;1m[0.65ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:31)[0m 
[33m[2020-07-22 15:34:11][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `tags`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 15:34:12][0m  [36;1m[0.55ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 15:34:12][0m  [36;1m[0.23ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:144)[0m 
[33m[2020-07-22 15:34:12][0m  [36;1m[0.61ms][0m   SELECT * FROM `blogs` GROUP BY YEAR DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:157)[0m 
[33m[2020-07-22 15:34:12][0m  [36;1m[0.72ms][0m   SELECT * FROM `blogs` where year = 2020 GROUP BY month DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:169)[0m 
[33m[2020-07-22 15:34:12][0m  [36;1m[0.89ms][0m   SELECT * FROM `blogs` where year = 2020 and month = 7 ORDER BY `id` DESC  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-22 15:34:12][0m  [36;1m[0.55ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=4  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-22 15:34:12][0m  [36;1m[0.46ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=3  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-22 15:34:12][0m  [36;1m[0.45ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=2  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-22 15:34:12][0m  [36;1m[0.44ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-22 15:34:13][0m  [36;1m[0.52ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 15:34:13][0m  [36;1m[0.25ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 15:34:13][0m  [36;1m[0.69ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-22 15:34:13][0m  [36;1m[0.18ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-22 15:34:14][0m  [36;1m[0.55ms][0m  SELECT * FROM `tags`    
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 15:34:14][0m  [36;1m[0.25ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 15:34:14][0m  [36;1m[0.70ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:31)[0m 
[33m[2020-07-22 15:34:14][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `tags`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-22 15:34:14][0m  [36;1m[0.53ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 15:34:14][0m  [36;1m[0.26ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 15:34:14][0m  [36;1m[0.67ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-22 15:34:14][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 15:34:15][0m  [36;1m[0.60ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 15:34:15][0m  [36;1m[0.74ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 15:34:15][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-22 15:34:15][0m  [36;1m[0.31ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-22 15:34:15][0m  [36;1m[0.34ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-22 15:34:15][0m  [36;1m[0.35ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-22 15:34:16][0m  [36;1m[0.58ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 15:34:16][0m  [36;1m[0.34ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 15:34:16][0m  [36;1m[0.85ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-22 15:34:16][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-22 15:34:17][0m  [36;1m[0.92ms][0m  SELECT * FROM `tags`    
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 15:34:17][0m  [36;1m[2.12ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 15:34:17][0m  [36;1m[0.68ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:31)[0m 
[33m[2020-07-22 15:34:17][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `tags`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-22 15:34:18][0m  [36;1m[0.55ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 15:34:18][0m  [36;1m[0.23ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 15:34:18][0m  [36;1m[0.67ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-22 15:34:18][0m  [36;1m[0.17ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 15:34:18][0m  [36;1m[0.64ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 15:34:18][0m  [36;1m[0.27ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:144)[0m 
[33m[2020-07-22 15:34:18][0m  [36;1m[0.70ms][0m   SELECT * FROM `blogs` GROUP BY YEAR DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:157)[0m 
[33m[2020-07-22 15:34:18][0m  [36;1m[0.71ms][0m   SELECT * FROM `blogs` where year = 2020 GROUP BY month DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:169)[0m 
[33m[2020-07-22 15:34:18][0m  [36;1m[0.67ms][0m   SELECT * FROM `blogs` where year = 2020 and month = 7 ORDER BY `id` DESC  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-22 15:34:18][0m  [36;1m[0.43ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=4  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-22 15:34:18][0m  [36;1m[0.46ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=3  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-22 15:34:18][0m  [36;1m[0.39ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=2  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-22 15:34:18][0m  [36;1m[0.41ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 15:34:19][0m  [36;1m[0.64ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 15:34:19][0m  [36;1m[0.78ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 15:34:19][0m  [36;1m[0.23ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-22 15:34:19][0m  [36;1m[0.37ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-22 15:34:19][0m  [36;1m[0.30ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-22 15:34:19][0m  [36;1m[0.34ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 15:34:22][0m  [36;1m[0.57ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 15:34:22][0m  [36;1m[0.69ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 15:34:22][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-22 15:34:22][0m  [36;1m[0.33ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-22 15:34:22][0m  [36;1m[0.25ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-22 15:34:22][0m  [36;1m[0.35ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 15:34:25][0m  [36;1m[0.79ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 15:34:25][0m  [36;1m[0.96ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 15:34:25][0m  [36;1m[0.27ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-22 15:34:25][0m  [36;1m[0.41ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-22 15:34:25][0m  [36;1m[0.35ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-22 15:34:25][0m  [36;1m[0.43ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 15:34:27][0m  [36;1m[0.64ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 15:34:27][0m  [36;1m[0.83ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 15:34:27][0m  [36;1m[0.23ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-22 15:34:27][0m  [36;1m[0.35ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-22 15:34:27][0m  [36;1m[0.31ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-22 15:34:27][0m  [36;1m[0.38ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-22 15:34:36][0m  [36;1m[0.60ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 15:34:36][0m  [36;1m[0.28ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 15:34:36][0m  [36;1m[0.75ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-22 15:34:36][0m  [36;1m[0.22ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 15:34:37][0m  [36;1m[0.57ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 15:34:37][0m  [36;1m[0.72ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 15:34:37][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-22 15:34:37][0m  [36;1m[0.34ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-22 15:34:37][0m  [36;1m[0.30ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-22 15:34:37][0m  [36;1m[0.35ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 15:36:23][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-22 15:36:23][0m  [36;1m[0.92ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-22 15:36:23][0m  [36;1m[0.28ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/types.go:52)[0m 
[33m[2020-07-22 15:36:23][0m  [36;1m[1.29ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id WHERE (type_id = 4) ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 15:36:23][0m  [36;1m[4.98ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/comment.go:17)[0m 
[33m[2020-07-22 15:36:23][0m  [36;1m[3.13ms][0m  SELECT * FROM `comments`  WHERE (re_comment_id = -1 AND blog_id = 4)  
[36;31m[0 rows affected or returned ][0m 
<nil> 错误111111111

[35m(/usr/workspace/src/blog/dao/tags.go:86)[0m 
[33m[2020-07-22 15:36:23][0m  [36;1m[0.54ms][0m   SELECT t.id,t.tag_name FROM `tags` t LEFT JOIN `tag_blogs` tb ON t.id = tb.`tag_id` LEFT JOIN `blogs` b ON tb.`blog_id`=b.`id`  WHERE b.`id`=4  
[36;31m[2 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:14)[0m 
[33m[2020-07-22 15:36:23][0m  [36;1m[0.44ms][0m  UPDATE `blogs` SET `title` = '本博客开源公告', `content` = '今天本博客评论功能发布
# 自今天起，本博客基本功能已经完成
## 发布V1.0版本并开源
## 博客语言说明
#### 本博客后端是用golang 的gin框架+gorm编写
前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的
#### 博客效果参考本站
#一、博客简介
## 1.博客目录

    blog
    ├────controller
	├────└───admin
	|	|	├──adminblog.go
	|	|	├───adminController.go
	|	|	├──adminTag.go
	|	|	├──adminType.go
	|	|	└──adminUser.go
	|	└──page
	|		├──404.go
	|		├───about.go
	|		├──archives.go
	|		├──blog.go
	|		├──comment.go
	|		├──pagesController.go
	|		├──researchController.go
	|		└──tagsController.go
    ├── dao
	│	├──blogs.go
	│	├──comment.go
	│	├──sql.go
	│	├──tags.go
	│	├──types.go
	│	└──user.go
    ├── logic
    │   └── user.go
    ├── middlerware
	│	├──function.go
	│	├──getImg.go
	│	├──getTime.go
	│	├──markdown.go
	│	├──select.go
	│	└──session.go
    ├── model
	│	├──blog.go
	│	├──commnent.go
	│	├──tag.go
	│	├──type.go
	│	└──user/go
    ├── static
	│	└──静态文件（头像、图片、logo、css、js等）
    ├── templates
	│	└──html模板文件
    ├── go.mod（依赖）
    └── main.go
    

## 2.相关功能实现简介
### 1、评论及回复功能
comment的结构体属性如下
```go
package model

type Comment struct {
	Id     int //评论id
	BlogId int //博文id
	ReCommentId    int    //父评论id
	CommentName string //评论人姓名
	ReCommentName  string //父评论人姓名
	CommentEmail   string
	Img            string
	CommentContent string `gorm:"type:text" form:"CommentContent" json:"CommentContent"` //评论内容
	CommentTime    string ` json:"comment_time,omitempty"`
	Parent         *Comment
	Comments       []Comment
}
```
#### 实现方法
##### 1先通过查找父评论为-1的顶级评论
父评论Id为-1说明他不是任何评论的子评论
##### 2在html上遍历所有的顶级评论
在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论
###### （1）递归存储每个顶级评论的子评论
这里我用一个切片来储存一个顶级评论的所有子评论
```go
var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
	var comments []model.Comment
	DB.Debug().Where("re_comment_id = -1 AND blog_id = ?", id).Find(&comments)
	return &comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
	if count != 0 {
		fmt.Println("if判断1")
		var comments []model.Comment
		DB.Debug().Where("re_comment_id = ?", id).Find(&comments)
		count = len(comments)
		if count != 0 {
			fmt.Println("if判断2")
			for _, comment := range comments {
				fmt.Println("for判断1")
				Comments = append(Comments, comment)
				SelectCommentByComment(comment.Id, count)
			}
		}
	}
	fmt.Println(Comments)
	return &Comments

}
```
ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来
###### （2）出现问题的原因
因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量
###### （3）解决问题
```go
func ClearComments() bool {
	var comments []model.Comment
	Comments = comments
	return true
}

```
这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现
#### 这里我还加了一个小小的随机头像功能
```go
if  CommentName == user.Name && CommentEmail == user.UserEmail {
		fmt.Println("进入了1")
		comment.Img =user.UserImg
		//找相同评论人
	}else if CommentName == one.CommentName && CommentEmail == one.CommentEmail {
		fmt.Println("进入了2")
		comment.Img =one.Img
		//随机选头像
	}else{
		fmt.Println("进入了3")
		comment.Img =middleware.GetImg()
	}
```
##### 123分别代表三种不同的用户群体
1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
![](/static/images/%e5%a4%b4%e5%83%8f1.png)![](/static/images/%e5%a4%b4%e5%83%8f2.png)![](/static/images/%e5%a4%b4%e5%83%8f3.png)![](/static/images/%e5%a4%b4%e5%83%8f4.png)![](/static/images/%e5%a4%b4%e5%83%8f5.png)![](/static/images/%e5%a4%b4%e5%83%8f6.png)
### 2、归档功能
#### blog的结构体属性如下
```go
package model

type Blog struct {
	Id           int
	Title        string    `form:"title" json:"title"`                          //标题
	Content      string    `gorm:"type:longtext" form:"content" json:"content"` //内容
	Image        string    `gorm:"type:text" form:"image" json:"image"`         //首图
	Numb         int       `form:"numb" json:"numb"`                            //次数
	Flag         string    `form:"flag" json:"flag"`                            //原创或者转载
	Appreciation string    `form:"appreciation" json:"appreciation"`            //打赏开关
	ShareInfo    string    `form:"shareInfo" json:"shareInfo"`                  //版权开关
	Comment      string    `form:"comment" json:"comment"`                      //评论开关
	Recommend    string    `form:"recommend" json:"recommend"`                  //推荐开关
	Description  string    `gorm:"type:text" form:"description" json:"description"`
	CreatTime    string    `form:"creatTime"  json:"creat_time,omitempty"`   //创建时间
	UpdateTime   string    `form:"updateTime"  json:"update_time,omitempty"` //更新时间
	Comments     []Comment `form:"comments" json:"comments"`
	TypeId       int       `form:"typeId" json:"typeId"`
	Type         Type      `form:"type" gorm:"ForeignKey:TypeId"`
	Year         int       `form:"year" json:"year"`
	Month        int       `form:"month" json:"month"`
	Day          int       `form:"day" json:"day"`
}

```
#### 实现方法
我的思路是创建三个时间节点
year month day 
利用sql分组查询
##### Group By分组查询步骤
###### （1）先按照年份查询
###### （2）再按照年份遍历每个月份
并将所有保存在一个切片中
###### （3）按照月份遍历每个月的所有文章
保存在一个Map中，key是对应的月份，value是每个月份的所有文章
#### 自此归档功能实现


## 3.已知BUG
### 后台退出功能
后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧

开源地址
[github](https://github.com/likewl/blog "github")
[gitee](https://gitee.com/nculike/blog "gitee")', `image` = 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1535821573,4166447487&fm=26&gp=0.jpg', `numb` = 59, `flag` = '原创', `appreciation` = '是', `share_info` = '是', `comment` = '是', `recommend` = '是', `description` = '本博客后端是用golang 的gin框架+gorm编写', `creat_time` = '2020-07-20 15:24:23', `update_time` = '2020-07-20 15:24:23', `type_id` = 4, `year` = 2020, `month` = 7, `day` = 20  WHERE `blogs`.`id` = 4  
[36;31m[1 rows affected or returned ][0m 
<p>今天本博客评论功能发布</p>

<h1>自今天起，本博客基本功能已经完成</h1>

<h2>发布V1.0版本并开源</h2>

<h2>博客语言说明</h2>

<h4>本博客后端是用golang 的gin框架+gorm编写</h4>

<p>前端模板是从B站借鉴的springBoot教学视频模板
原谅我现在对前端js不是很熟，但我会重写前端代码的</p>

<h4>博客效果参考本站</h4>

<p>#一、博客简介</p>

<h2>1.博客目录</h2>

<pre><code>blog
├────controller
├────└───admin
|   |   ├──adminblog.go
|   |   ├───adminController.go
|   |   ├──adminTag.go
|   |   ├──adminType.go
|   |   └──adminUser.go
|   └──page
|       ├──404.go
|       ├───about.go
|       ├──archives.go
|       ├──blog.go
|       ├──comment.go
|       ├──pagesController.go
|       ├──researchController.go
|       └──tagsController.go
├── dao
│   ├──blogs.go
│   ├──comment.go
│   ├──sql.go
│   ├──tags.go
│   ├──types.go
│   └──user.go
├── logic
│   └── user.go
├── middlerware
│   ├──function.go
│   ├──getImg.go
│   ├──getTime.go
│   ├──markdown.go
│   ├──select.go
│   └──session.go
├── model
│   ├──blog.go
│   ├──commnent.go
│   ├──tag.go
│   ├──type.go
│   └──user/go
├── static
│   └──静态文件（头像、图片、logo、css、js等）
├── templates
│   └──html模板文件
├── go.mod（依赖）
└── main.go
</code></pre>

<h2>2.相关功能实现简介</h2>

<h3>1、评论及回复功能</h3>

<p>comment的结构体属性如下</p>

<pre><code class="language-go">package model

type Comment struct {
    Id     int //评论id
    BlogId int //博文id
    ReCommentId    int    //父评论id
    CommentName string //评论人姓名
    ReCommentName  string //父评论人姓名
    CommentEmail   string
    Img            string
    CommentContent string `gorm:&#34;type:text&#34; form:&#34;CommentContent&#34; json:&#34;CommentContent&#34;` //评论内容
    CommentTime    string ` json:&#34;comment_time,omitempty&#34;`
    Parent         *Comment
    Comments       []Comment
}
</code></pre>

<h4>实现方法</h4>

<h5>1先通过查找父评论为-1的顶级评论</h5>

<p>父评论Id为-1说明他不是任何评论的子评论</p>

<h5>2在html上遍历所有的顶级评论</h5>

<p>在遍历的同时，每遍历一个顶级评论就需要再查询的它子评论</p>

<h6>（1）递归存储每个顶级评论的子评论</h6>

<p>这里我用一个切片来储存一个顶级评论的所有子评论</p>

<pre><code class="language-go">var Comments []model.Comment

//找到父评论
func SelectCommentByBlog(id int) *[]model.Comment {
    var comments []model.Comment
    DB.Debug().Where(&#34;re_comment_id = -1 AND blog_id = ?&#34;, id).Find(&amp;comments)
    return &amp;comments
}

//找对应的子评论
func SelectCommentByComment(id int, count int) *[]model.Comment {
    if count != 0 {
        fmt.Println(&#34;if判断1&#34;)
        var comments []model.Comment
        DB.Debug().Where(&#34;re_comment_id = ?&#34;, id).Find(&amp;comments)
        count = len(comments)
        if count != 0 {
            fmt.Println(&#34;if判断2&#34;)
            for _, comment := range comments {
                fmt.Println(&#34;for判断1&#34;)
                Comments = append(Comments, comment)
                SelectCommentByComment(comment.Id, count)
            }
        }
    }
    fmt.Println(Comments)
    return &amp;Comments

}
</code></pre>

<p>ps：请忽略多层if中间那层没啥用，可我懒得删的
这里理想是好的
可有一点小小的问题
就是你回复评论没啥问题
可刷新页面就会莫名多出一条评论
越刷新越多
为了解决这个问题我废了好长时间
这就是代码中那么多if和fmt.Println的由来</p>

<h6>（2）出现问题的原因</h6>

<p>因为我用的是切片，还是全局切片
所有的顶级评论的子评论都是用的这个切片
可之前上一个顶级评论的子评论缺没有清除
这就会导致切片中存储的越来越多
每次刷新页面就会成倍的增加子评论数量</p>

<h6>（3）解决问题</h6>

<pre><code class="language-go">func ClearComments() bool {
    var comments []model.Comment
    Comments = comments
    return true
}

</code></pre>

<p>这是我用了一个ClearComments()函数来清除Comments切片中上一个顶级评论的子评论
自此，评论功能实现</p>

<h4>这里我还加了一个小小的随机头像功能</h4>

<pre><code class="language-go">if  CommentName == user.Name &amp;&amp; CommentEmail == user.UserEmail {
        fmt.Println(&#34;进入了1&#34;)
        comment.Img =user.UserImg
        //找相同评论人
    }else if CommentName == one.CommentName &amp;&amp; CommentEmail == one.CommentEmail {
        fmt.Println(&#34;进入了2&#34;)
        comment.Img =one.Img
        //随机选头像
    }else{
        fmt.Println(&#34;进入了3&#34;)
        comment.Img =middleware.GetImg()
    }
</code></pre>

<h5>123分别代表三种不同的用户群体</h5>

<p>1代表博主
2代表之前评论过的人
3代表没有评论过的人
对于没有评论过的随机给ta个头像
<img src="/static/images/%e5%a4%b4%e5%83%8f1.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f2.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f3.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f4.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f5.png" alt=""/><img src="/static/images/%e5%a4%b4%e5%83%8f6.png" alt=""/></p>

<h3>2、归档功能</h3>

<h4>blog的结构体属性如下</h4>

<pre><code class="language-go">package model

type Blog struct {
    Id           int
    Title        string    `form:&#34;title&#34; json:&#34;title&#34;`                          //标题
    Content      string    `gorm:&#34;type:longtext&#34; form:&#34;content&#34; json:&#34;content&#34;` //内容
    Image        string    `gorm:&#34;type:text&#34; form:&#34;image&#34; json:&#34;image&#34;`         //首图
    Numb         int       `form:&#34;numb&#34; json:&#34;numb&#34;`                            //次数
    Flag         string    `form:&#34;flag&#34; json:&#34;flag&#34;`                            //原创或者转载
    Appreciation string    `form:&#34;appreciation&#34; json:&#34;appreciation&#34;`            //打赏开关
    ShareInfo    string    `form:&#34;shareInfo&#34; json:&#34;shareInfo&#34;`                  //版权开关
    Comment      string    `form:&#34;comment&#34; json:&#34;comment&#34;`                      //评论开关
    Recommend    string    `form:&#34;recommend&#34; json:&#34;recommend&#34;`                  //推荐开关
    Description  string    `gorm:&#34;type:text&#34; form:&#34;description&#34; json:&#34;description&#34;`
    CreatTime    string    `form:&#34;creatTime&#34;  json:&#34;creat_time,omitempty&#34;`   //创建时间
    UpdateTime   string    `form:&#34;updateTime&#34;  json:&#34;update_time,omitempty&#34;` //更新时间
    Comments     []Comment `form:&#34;comments&#34; json:&#34;comments&#34;`
    TypeId       int       `form:&#34;typeId&#34; json:&#34;typeId&#34;`
    Type         Type      `form:&#34;type&#34; gorm:&#34;ForeignKey:TypeId&#34;`
    Year         int       `form:&#34;year&#34; json:&#34;year&#34;`
    Month        int       `form:&#34;month&#34; json:&#34;month&#34;`
    Day          int       `form:&#34;day&#34; json:&#34;day&#34;`
}

</code></pre>

<h4>实现方法</h4>

<p>我的思路是创建三个时间节点
year month day
利用sql分组查询</p>

<h5>Group By分组查询步骤</h5>

<h6>（1）先按照年份查询</h6>

<h6>（2）再按照年份遍历每个月份</h6>

<p>并将所有保存在一个切片中</p>

<h6>（3）按照月份遍历每个月的所有文章</h6>

<p>保存在一个Map中，key是对应的月份，value是每个月份的所有文章</p>

<h4>自此归档功能实现</h4>

<h2>3.已知BUG</h2>

<h3>后台退出功能</h3>

<p>后台登录后第一次点退出可以退出，之后就不行了
我怀疑是session出了问题，之后我查查看吧</p>

<p>开源地址
<a href="https://github.com/likewl/blog" title="github" rel="nofollow">github</a>
<a href="https://gitee.com/nculike/blog" title="gitee" rel="nofollow">gitee</a></p>


[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 15:36:23][0m  [36;1m[1.68ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 15:36:26][0m  [36;1m[0.54ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 15:36:26][0m  [36;1m[0.72ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 15:36:26][0m  [36;1m[0.17ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-22 15:36:26][0m  [36;1m[0.29ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-22 15:36:26][0m  [36;1m[0.28ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-22 15:36:26][0m  [36;1m[0.30ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-22 15:36:39][0m  [36;1m[0.55ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 15:36:39][0m  [36;1m[0.29ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 15:36:39][0m  [36;1m[0.66ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-22 15:36:39][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 15:36:40][0m  [36;1m[0.57ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 15:36:40][0m  [36;1m[0.76ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 15:36:40][0m  [36;1m[0.19ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-22 15:36:40][0m  [36;1m[0.28ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-22 15:36:40][0m  [36;1m[0.26ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-22 15:36:40][0m  [36;1m[0.31ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:27)[0m 
[33m[2020-07-22 15:36:45][0m  [36;1m[0.54ms][0m  SELECT * FROM `types`    
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 15:36:45][0m  [36;1m[0.28ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 15:36:45][0m  [36;1m[0.66ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:32)[0m 
[33m[2020-07-22 15:36:45][0m  [36;1m[0.18ms][0m  SELECT count(*) FROM `types`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:26)[0m 
[33m[2020-07-22 15:36:46][0m  [36;1m[0.55ms][0m  SELECT * FROM `tags`    
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 15:36:46][0m  [36;1m[0.33ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 15:36:46][0m  [36;1m[0.70ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/tags.go:31)[0m 
[33m[2020-07-22 15:36:46][0m  [36;1m[0.20ms][0m  SELECT count(*) FROM `tags`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 15:36:47][0m  [36;1m[0.57ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 15:36:47][0m  [36;1m[0.23ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:144)[0m 
[33m[2020-07-22 15:36:47][0m  [36;1m[0.61ms][0m   SELECT * FROM `blogs` GROUP BY YEAR DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:157)[0m 
[33m[2020-07-22 15:36:47][0m  [36;1m[0.68ms][0m   SELECT * FROM `blogs` where year = 2020 GROUP BY month DESC  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:169)[0m 
[33m[2020-07-22 15:36:47][0m  [36;1m[0.66ms][0m   SELECT * FROM `blogs` where year = 2020 and month = 7 ORDER BY `id` DESC  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-22 15:36:47][0m  [36;1m[0.38ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=4  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-22 15:36:47][0m  [36;1m[0.38ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=3  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-22 15:36:47][0m  [36;1m[0.33ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=2  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:65)[0m 
[33m[2020-07-22 15:36:47][0m  [36;1m[0.34ms][0m   SELECT t.id,t.type_name FROM `types` t LEFT JOIN `blogs` b ON t.id = b.`type_id` WHERE b.`id`=1  
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/user.go:7)[0m 
[33m[2020-07-22 15:36:48][0m  [36;1m[0.52ms][0m  SELECT * FROM `users`    
[36;31m[1 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:101)[0m 
[33m[2020-07-22 15:36:48][0m  [36;1m[0.70ms][0m  SELECT blogs.id,blogs.title,types.type_name,blogs.description,blogs.recommend,blogs.numb,blogs.update_time,blogs.image FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY blogs.id  DESC LIMIT 10 OFFSET 0  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:107)[0m 
[33m[2020-07-22 15:36:48][0m  [36;1m[0.21ms][0m  SELECT count(*) FROM `blogs`    
[36;31m[0 rows affected or returned ][0m 
4

[35m(/usr/workspace/src/blog/dao/tags.go:56)[0m 
[33m[2020-07-22 15:36:48][0m  [36;1m[0.31ms][0m   SELECT * FROM `tags` ORDER BY RAND() LIMIT 10  
[36;31m[5 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/types.go:37)[0m 
[33m[2020-07-22 15:36:48][0m  [36;1m[0.27ms][0m   SELECT * FROM `types` ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 

[35m(/usr/workspace/src/blog/dao/blogs.go:114)[0m 
[33m[2020-07-22 15:36:48][0m  [36;1m[0.33ms][0m  SELECT blogs.id,blogs.title,types.type_name FROM `blogs` left join types on types.id = blogs.type_id  ORDER BY RAND() LIMIT 5  
[36;31m[4 rows affected or returned ][0m 
